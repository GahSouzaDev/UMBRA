<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tupãry: O Reino Congelado</title>
    <style>
        /* ===== VARIÁVEIS CSS ===== */
        :root {
            --primary-dark: #000000;
            --primary-medium: #0a0a0a;
            --primary-light: #1a1a1a;
            --accent-gold: #d4af37;
            --accent-gold-light: #f5d76e;
            --accent-blue: #3a86ff;
            --accent-ice: #90e0ef;
            --accent-fire: #ff6b6b;
            --accent-nature: #52b788;
            --text-light: #f0f0f0;
            --text-gray: #aaaaaa;
            --health-color: var(--accent-fire);
            --mana-color: var(--accent-blue);
            --xp-color: var(--accent-gold);
            --shadow-dark: rgba(0, 0, 0, 0.8);
            --spike-color: #666666;
            --archer-color: #4fc3f7; /* Cor para Atirador Gélido */
            --warrior-color: #66bb6a; /* Cor para Guerreiro do Gelo */
            --player-color: #ffffff; /* Cor base para o Escolhido */
        }

        /* ===== RESET E BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: var(--primary-dark); /* Fundo fixo para não interferir com o canvas */
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* ===== CONTAINER PRINCIPAL DO JOGO ===== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1600px;
            max-height: 770px;
            overflow: hidden;
            border: 3px solid var(--accent-gold);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
            background: transparent; /* O background do jogo será desenhado no canvas */
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: transparent;
        }

        /* ===== AVISO DE ORIENTAÇÃO MOBILE ===== */
        .orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--primary-dark);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }

        .orientation-warning h2 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            font-size: 24px;
        }

        .orientation-warning p {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
        }

        .rotate-icon {
            font-size: 48px;
            margin: 20px 0;
            animation: rotatePhone 2s infinite;
        }

        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        /* ===== TELA DE INÍCIO / MENU PRINCIPAL ===== */
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.95) 100%);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-title {
            font-size: 42px;
            font-weight: bold;
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 20px;
            color: var(--accent-ice);
            text-align: center;
            margin-bottom: 40px;
            font-style: italic;
        }

        .character-selection {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 700px;
        }

        .character-selection h3 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            text-align: center;
            font-size: 20px;
        }

        .name-input-group {
            margin-bottom: 25px;
            text-align: center;
        }

        .name-input-group label {
            display: block;
            color: var(--text-light);
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 18px;
        }

        .name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--accent-blue);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
            text-align: center;
        }

        .name-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold-light);
        }

        .class-selection {
            display: none; /* Classe removida, seleção de classe removida do menu principal */
        }

        .start-game-btn {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
        }

        .start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.5);
        }

        .start-game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* ===== UI LAYER ===== */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Permite cliques através da camada, exceto nos elementos interativos */
        }

        /* ===== BARRAS DE STATUS ===== */
        .status-bars {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
        }

        .bar-container {
            width: 200px;
            height: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--text-light);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
        }

        .mana-fill {
            background: linear-gradient(90deg, #4dabf7, #3366ff);
        }

        .xp-fill {
            background: linear-gradient(90deg, var(--accent-gold-light), var(--accent-gold));
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        /* ===== STATS DO JOGADOR ===== */
        .player-stats {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 14px;
            text-align: right;
            min-width: 150px;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-line:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: var(--accent-ice);
            font-weight: bold;
        }

        .stat-value {
            color: var(--accent-gold);
            font-weight: bold;
        }

        /* ===== SISTEMA DE HABILIDADES (Desktop) ===== */
        .abilities-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }

        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
            border: 3px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .ability-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        .ability-btn:active {
            transform: scale(0.95);
        }

        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .ability-btn.cooldown:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(0, 0, 0, 0.8) 0deg);
            transition: background 0.1s linear;
        }

        .ability-tooltip {
            position: absolute;
            bottom: 70px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--accent-blue);
            border-radius: 8px;
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            width: 200px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .ability-btn:hover .ability-tooltip {
            opacity: 1;
        }

        .tooltip-name {
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip-description {
            color: var(--text-light);
            font-size: 12px;
            line-height: 1.3;
            margin-bottom: 5px;
        }

        .tooltip-cost {
            color: var(--mana-color);
            font-size: 11px;
            font-style: italic;
        }

        /* ===== CONTROLES MOBILE (D-pad e Ações) ===== */
        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 5px;
            pointer-events: auto;
            z-index: 5;
            align-items: center;
        }
        .mobile-dpad {
            grid-column: 1 / 2;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 120px;
            height: 120px;
            position: relative;
            margin-left: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .dpad-btn {
            background: var(--primary-medium);
            border: 2px solid var(--accent-blue);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.1s;
            border-radius: 5px;
            pointer-events: auto;
        }
        .dpad-btn:active {
            background: var(--accent-blue);
            transform: scale(0.95);
        }

        .dpad-up { grid-area: 1 / 2 / 2 / 3; }
        .dpad-left { grid-area: 2 / 1 / 3 / 2; }
        .dpad-center { grid-area: 2 / 2 / 3 / 3; opacity: 0.3; pointer-events: none;}
        .dpad-right { grid-area: 2 / 3 / 3 / 4; }
        .dpad-down { grid-area: 3 / 2 / 4 / 3; }

        .mobile-action-buttons {
            grid-column: 3 / 4;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            position: relative;
            margin-right: 20px;
            justify-self: end;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .mobile-btn:active {
            transform: scale(0.9);
            background: rgba(212, 175, 55, 0.3);
        }

        /* ===== SISTEMA DE DIÁLOGO ===== */
        .dialog-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(10, 10, 10, 0.9));
            border: 3px solid var(--accent-blue);
            border-radius: 15px;
            padding: 20px;
            display: none;
            pointer-events: auto;
            z-index: 20;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .dialog-speaker {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dialog-text {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .dialog-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dialog-option {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(255, 107, 107, 0.2));
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-light);
            font-weight: bold;
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .dialog-option:hover {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4), rgba(255, 107, 107, 0.4));
            transform: translateX(5px);
        }

        .dialog-option:active {
            transform: translateX(5px) scale(0.98);
        }

        /* ===== CUTSCENES ===== */
        .cinematic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            z-index: 30;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            overflow: hidden;
            pointer-events: auto; /* Garante que o overlay é interativo */
        }

        .cinematic-overlay.with-image {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(10, 10, 10, 0.8));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .cinematic-image {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1; /* Fica atrás do texto */
            opacity: 0.3; /* Transparência para o texto ser visível */
            transition: opacity 1s ease;
        }

        .cinematic-text {
            font-size: 20px;
            text-align: center;
            max-width: 80%;
            margin-bottom: 30px;
            color: var(--text-light);
            line-height: 1.6;
            opacity: 0;
            animation: fadeInText 3s forwards;
            position: relative; /* Para garantir z-index acima da imagem */
        }

        .cinematic-title {
            font-size: 32px;
            color: var(--accent-gold);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            position: relative; /* Para garantir z-index acima da imagem */
        }

        .next-btn { /* Renomeado de skip-btn para next-btn */
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-weight: bold;
        }

        .next-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
        }

        /* ===== PAUSE MENU ===== */
        .pause-btn {
            position: absolute;
            top: 15px;
            right: 180px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-size: 16px;
        }

        .pause-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: scale(1.1);
        }

        .pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 40;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            pointer-events: auto; /* Garante que o menu é interativo */
        }

        .pause-title {
            font-size: 36px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-option {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 200px;
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .menu-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        /* ===== LEVEL UP (COM ESCOLHAS) ===== */
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            border: 3px solid var(--accent-gold);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            z-index: 35;
            display: none;
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            pointer-events: auto; /* Garante que o menu é interativo */
        }

        .level-up-title {
            font-size: 28px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .level-up-subtitle {
            font-size: 16px;
            color: var(--text-light);
            margin-bottom: 25px;
        }

        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .upgrade-option {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .upgrade-option:hover {
            background: rgba(0, 0, 0, 0.6);
            transform: translateX(5px);
            box-shadow: 0 6px 15px rgba(212, 175, 55, 0.5);
        }

        .upgrade-name {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .upgrade-description {
            color: var(--text-light);
            font-size: 14px;
            line-height: 1.3;
        }

        /* ===== CHECKPOINT SYSTEM ===== */
        .checkpoint-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 25;
            display: none;
            animation: checkpointPulse 2s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        @keyframes checkpointPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }

        .checkpoint-text {
            color: var(--accent-blue);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .checkpoint-description {
            color: var(--text-light);
            font-size: 14px;
        }

        /* ===== ANIMAÇÕES GERAIS ===== */
        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes levelUpAnimation {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* ===== EFEITOS ESPECIAIS ===== */
        .screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 15;
            opacity: 0;
            pointer-events: none;
        }

        .screen-flash.active {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .boss-health-bar {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-fire);
            border-radius: 10px;
            display: none;
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5);
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
            transition: width 0.5s ease;
            position: relative;
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        .boss-name {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--accent-fire);
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 10;
        }

        /* ===== PARTÍCULAS E NÚMEROS ===== */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .damage-number, .xp-number {
            position: absolute;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
            animation: damageNumber 1s ease-out forwards;
        }
        .damage-number { color: var(--accent-fire); }
        .xp-number { color: var(--xp-color); animation: xpNumber 1.5s ease-out forwards; }

        @keyframes damageNumber {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
        }

        @keyframes xpNumber {
            0% { opacity: 1; transform: translateY(0) scale(0.8); }
            100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
        }

        /* ===== RESPONSIVIDADE ===== */
        @media (max-width: 800px) {
            #game-container {
                width: 100vw;
                height: 100vh;
                max-width: none;
                max-height: none;
                border: none;
                border-radius: 0;
            }

            .main-menu {
                padding: 10px;
            }

            .game-title {
                font-size: 36px;
            }

            .game-subtitle {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .character-selection {
                padding: 15px;
                margin-bottom: 15px;
            }

            .class-selection {
                flex-direction: column;
                gap: 15px;
            }

            .class-option {
                min-width: unset;
                width: 100%;
                padding: 15px;
            }

            .mobile-controls {
                display: grid;
            }

            .abilities-container {
                display: none;
            }

            .status-bars {
                top: 10px;
                left: 10px;
            }

            .bar-container {
                width: 150px;
                height: 12px;
            }

            .player-stats {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 12px;
                min-width: 120px;
            }

            .pause-btn {
                top: 10px;
                right: 140px;
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .dialog-container {
                width: 95%;
                padding: 15px;
                bottom: 15px;
            }

            .dialog-text {
                font-size: 14px;
                min-height: 50px;
            }

            .cinematic-text {
                font-size: 16px;
                max-width: 90%;
            }

            .cinematic-title {
                font-size: 24px;
            }

            .next-btn {
                bottom: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 14px;
            }

            .level-up {
                min-width: 90%;
                padding: 20px;
            }

            .upgrade-option {
                padding: 12px;
            }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            .status-bars {
                top: 5px;
                left: 5px;
            }

            .bar-container {
                width: 120px;
                height: 10px;
            }

            .player-stats {
                top: 5px;
                right: 5px;
                padding: 5px 8px;
                font-size: 10px;
                min-width: 100px;
            }

            .mobile-dpad {
                bottom: 10px;
                left: 10px;
                width: 100px;
                height: 100px;
                margin-left: 10px;
            }

            .mobile-action-buttons {
                bottom: 10px;
                right: 10px;
                margin-right: 10px;
            }

            .mobile-btn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- Aviso de Orientação Mobile -->
    <div class="orientation-warning" id="orientation-warning">
        <div class="rotate-icon">📱</div>
        <h2>Vire o Dispositivo</h2>
        <p>Para uma melhor experiência de jogo, por favor vire seu dispositivo para o modo paisagem (horizontal).</p>
    </div>

    <!-- Container Principal do Jogo -->
    <div id="game-container">
        <!-- Tela de Início / Menu Principal -->
        <div class="main-menu" id="main-menu">
            <h1 class="game-title">TUPÃRY</h1>
            <p class="game-subtitle">O Reino Congelado</p>
            
            <div class="character-selection">
                <h3>Desperte, Escolhido! Diga-me seu nome para que o destino o chame:</h3>
                <div class="name-input-group">
                    <label for="player-name">Nome do Escolhido:</label>
                    <input type="text" id="player-name" class="name-input" placeholder="Seu nome, para que o destino o chame..." maxlength="20">
                </div>
                <!-- A seleção de classe é removida, pois o personagem é único -->
            </div>
            
            <button class="start-game-btn" id="start-game-btn" disabled>Iniciar Jornada</button>
        </div>

        <!-- Canvas do Jogo -->
        <canvas id="game-canvas"></canvas>
        
        <!-- Flash de Tela -->
        <div class="screen-flash" id="screen-flash"></div>
        
        <!-- Container de Partículas -->
        <div class="particle-container" id="particle-container"></div>

        <!-- UI Layer -->
        <div class="ui-layer">
            <!-- Barras de Status -->
            <div class="status-bars">
                <div class="status-bar">
                    <div class="status-icon">❤️</div>
                    <div class="bar-container">
                        <div class="bar-fill health-fill" id="health-fill"></div>
                        <div class="bar-text" id="health-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">💙</div>
                    <div class="bar-container">
                        <div class="bar-fill mana-fill" id="mana-fill"></div>
                        <div class="bar-text" id="mana-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">⭐</div>
                    <div class="bar-container">
                        <div class="bar-fill xp-fill" id="xp-fill"></div>
                        <div class="bar-text" id="xp-text">0/100</div>
                    </div>
                </div>
            </div>
            
            <!-- Stats do Jogador -->
            <div class="player-stats" id="player-stats">
                <div class="stat-line">
                    <span class="stat-label">Nível:</span>
                    <span class="stat-value" id="player-level">1</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Classe:</span>
                    <span class="stat-value" id="player-class">Escolhido</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Dano:</span>
                    <span class="stat-value" id="player-damage">15</span>
                </div>
            </div>
            
            <!-- Barra de Vida do Boss -->
            <div class="boss-name" id="boss-name">TAREK, O GUERREIRO</div>
            <div class="boss-health-bar" id="boss-health-bar">
                <div class="boss-health-fill" id="boss-health-fill"></div>
            </div>
            
            <!-- Habilidades (Desktop) -->
            <div class="abilities-container" id="abilities-container">
                <div class="ability-btn" id="ability-u" data-key="U">
                    U
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-u-name">Soco</div>
                        <div class="tooltip-description" id="tooltip-u-desc">Ataque corpo a corpo rápido.</div>
                        <div class="tooltip-cost" id="tooltip-u-cost">Custo: 0 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-i" data-key="I">
                    I
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-i-name">Disparo</div>
                        <div class="tooltip-description" id="tooltip-i-desc">Lança um projétil negro de energia.</div>
                        <div class="tooltip-cost" id="tooltip-i-cost">Custo: 10 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-o" data-key="O">
                    O
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-o-name">Investida</div>
                        <div class="tooltip-description" id="tooltip-o-desc">Dash rápido que causa dano e concede invulnerabilidade temporária.</div>
                        <div class="tooltip-cost" id="tooltip-o-cost">Custo: 25 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-p" data-key="P">
                    P
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-p-name">Fúria de Umbra</div>
                        <div class="tooltip-description" id="tooltip-p-desc">Canaliza a energia de Umbra para ficar mais rápido, resistente e poderoso.</div>
                        <div class="tooltip-cost" id="tooltip-p-cost">Custo: 50 Mana</div>
                    </div>
                </div>
            </div>
            
            <!-- Botão de Pausa -->
            <div class="pause-btn" id="pause-btn">⏸️</div>
            
            <!-- Controles Mobile (D-pad e Ações) -->
            <div class="mobile-controls" id="mobile-controls">
                <div class="mobile-dpad">
                    <div class="dpad-btn dpad-up" id="mobile-up">▲</div>
                    <div class="dpad-btn dpad-left" id="mobile-left">◀</div>
                    <div class="dpad-btn dpad-center"></div>
                    <div class="dpad-btn dpad-right" id="mobile-right">▶</div>
                    <div class="dpad-btn dpad-down" id="mobile-down">▼</div>
                </div>
                
                <div class="mobile-action-buttons">
                    <div class="mobile-btn" id="mobile-ability-u">U</div>
                    <div class="mobile-btn" id="mobile-ability-i">I</div>
                    <div class="mobile-btn" id="mobile-ability-o">O</div>
                    <div class="mobile-btn" id="mobile-ability-p">P</div>
                </div>
            </div>
            
            <!-- Sistema de Diálogo -->
            <div class="dialog-container" id="dialog-container">
                <div class="dialog-speaker" id="dialog-speaker"></div>
                <div class="dialog-text" id="dialog-text"></div>
                <div class="dialog-options" id="dialog-options"></div>
            </div>
            
            <!-- Overlay de Cutscene -->
            <div class="cinematic-overlay" id="cinematic-overlay">
                <img id="cinematic-image" class="cinematic-image" src="" alt="Cinematic Image">
                <div class="cinematic-title" id="cinematic-title"></div>
                <div class="cinematic-text" id="cinematic-text"></div>
                <button class="next-btn" id="next-btn">Próximo</button>
            </div>
            
            <!-- Menu de Pausa -->
            <div class="pause-menu" id="pause-menu">
                <h2 class="pause-title">JOGO PAUSADO</h2>
                <button class="menu-option" id="resume-btn">Continuar</button>
                <button class="menu-option" id="restart-btn">Reiniciar Checkpoint</button>
                <button class="menu-option" id="save-btn">Salvar Progresso</button>
                <button class="menu-option" id="exit-btn">Voltar ao Menu</button>
            </div>
            
            <!-- Sistema de Level Up (Com Escolhas) -->
            <div class="level-up" id="level-up">
                <h2 class="level-up-title">NÍVEL AUMENTADO!</h2>
                <p class="level-up-subtitle">Escolha uma melhoria para fortalecer seu poder:</p>
                <div class="upgrade-options">
                    <div class="upgrade-option" data-upgrade="health">
                        <div class="upgrade-name">+ Vitalidade Aprimorada</div>
                        <div class="upgrade-description">Aumenta sua vida máxima em 25 pontos e restaura completamente sua saúde.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="mana">
                        <div class="upgrade-name">+ Reserva Mística</div>
                        <div class="upgrade-description">Aumenta sua mana máxima em 35 pontos e acelera a regeneração em 50%.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="damage">
                        <div class="upgrade-name">+ Poder Destrutivo</div>
                        <div class="upgrade-description">Aumenta o dano de todas suas habilidades em 8 pontos permanentemente.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="speed">
                        <div class="upgrade-name">+ Agilidade Gélida</div>
                        <div class="upgrade-description">Aumenta velocidade de movimento em 20% e reduz cooldowns em 15%.</div>
                    </div>
                </div>
            </div>
            
            <!-- Notificação de Checkpoint -->
            <div class="checkpoint-notification" id="checkpoint-notification">
                <div class="checkpoint-text">CHECKPOINT SALVO</div>
                <div class="checkpoint-description">Seu progresso foi salvo automaticamente</div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURAÇÕES GLOBAIS =====
        const CONFIG = {
            // Física do jogo
            GRAVITY: 0.6,
            PLAYER_BASE_SPEED: 4, // Velocidade base do jogador
            JUMP_FORCE: 14,
            CROUCH_HEIGHT: 30, // Altura de agachamento
            NORMAL_HEIGHT: 50, // Altura normal do jogador (para hitbox)
            
            // Dimensões do Sprite do Jogador (proporção 2:1, largura 50px, altura 100px)
            PLAYER_SPRITE_WIDTH: 50,
            PLAYER_SPRITE_HEIGHT: 100,
            PLAYER_SPRITE_OFFSET_Y: 50, // Ajuste para o centro da hitbox ficar no pé do sprite original
            // Escala da hitbox em relação ao sprite (ex: 80% da largura, 90% da altura)
            PLAYER_HITBOX_SCALE_X: 0.8,
            PLAYER_HITBOX_SCALE_Y: 0.9,
            
            // Mundo
            WORLD_WIDTH: 5000,
            WORLD_HEIGHT: 450, // Altura total do mundo para queda fatal
            CAMERA_SMOOTHING: 0.08,
            
            // Combate
            DAMAGE_FLASH_DURATION: 200,
            INVINCIBILITY_DURATION: 1000,
            
            // Regeneração
            MANA_REGEN_RATE: 1.5,
            HEALTH_REGEN_RATE: 0.05,
            
            // Partículas
            MAX_PARTICLES: 200,
            SNOW_SPAWN_RATE: 0.15,
            
            // Performance
            TARGET_FPS: 60,
            DELTA_TIME_CAP: 32, // Cap para deltaTime para evitar grandes saltos em lag
            
            // Habilidades do Escolhido (Poderes de Umbra para a classe 'chosenOne')
            UMBRA_FURY_DURATION: 7000,
            UMBRA_FURY_DAMAGE_BOOST: 1.5,
            UMBRA_FURY_SPEED_BOOST: 1.3,
            UMBRA_FURY_DAMAGE_REDUCTION: 0.5,

            // CAMINHOS DE RECURSOS (GIFs e Áudios)
            ASSET_PATHS: {
                // Backgrounds (imagens estáticas que serão usadas em renderBackground)
                bg_sky: 'assets/backgrounds/sky.png',
                bg_mountains: 'assets/backgrounds/mountains.png',
                bg_hills: 'assets/backgrounds/hills.png',
                bg_foreground: 'assets/backgrounds/foreground.png',

                // Plataformas (imagens estáticas)
                platform_ground: 'assets/platforms/ground_platform.png',
                platform_ice: 'assets/platforms/ice_platform.png',
                platform_spike: 'assets/platforms/spike_platform.png',
                
                // Player - Escolhido (GIFs)
                player_idle_right: 'assets/personagens/Escolhido/gifs/escolhido-parado01.gif',
                player_idle_left: 'assets/personagens/Escolhido/gifs/escolhido-parado01_mirrored.gif', // Supondo uma versão espelhada
                player_walk_right: 'assets/personagens/Escolhido/gifs/escolhido-andando01.gif',
                player_walk_left: 'assets/personagens/Escolhido/gifs/escolhido-andando01_mirrored.gif',
                player_jump_right: 'assets/personagens/Escolhido/gifs/escolhido-salto01.gif',
                player_jump_left: 'assets/personagens/Escolhido/gifs/escolhido-salto01_mirrored.gif',
                player_crouch_right: 'assets/personagens/Escolhido/gifs/escolhido-agachar01.gif', // Placeholder
                player_crouch_left: 'assets/personagens/Escolhido/gifs/escolhido-agachar01_mirrored.gif', // Placeholder
                player_attack_u_right: 'assets/personagens/Escolhido/gifs/escolhido-soco01.gif', // Animação de Soco
                player_attack_u_left: 'assets/personagens/Escolhido/gifs/escolhido-soco01_mirrored.gif',
                player_attack_i_right: 'assets/personagens/Escolhido/gifs/escolhido-disparo01.gif', // Animação de Disparo
                player_attack_i_left: 'assets/personagens/Escolhido/gifs/escolhido-disparo01_mirrored.gif',
                player_attack_o_right: 'assets/personagens/Escolhido/gifs/escolhido-investida01.gif', // Animação de Investida
                player_attack_o_left: 'assets/personagens/Escolhido/gifs/escolhido-investida01_mirrored.gif',
                player_ultimate_right: 'assets/personagens/Escolhido/gifs/escolhido-ultimate01.gif', // Animação de Ultimate
                player_ultimate_left: 'assets/personagens/Escolhido/gifs/escolhido-ultimate01_mirrored.gif',

                // Inimigos - Sentinela (GIFs)
                sentinel_idle_right: 'assets/personagens/Sentinelas/gifs/sentinela-parado01.gif',
                sentinel_idle_left: 'assets/personagens/Sentinelas/gifs/sentinela-parado01_mirrored.gif',
                sentinel_attack_right: 'assets/personagens/Sentinelas/gifs/sentinela-ataque01.gif',
                sentinel_attack_left: 'assets/personagens/Sentinelas/gifs/sentinela-ataque01_mirrored.gif',

                // Inimigos - Tarek (GIFs)
                tarek_idle_right: 'assets/personagens/Tarek/gifs/tarek-parado01.gif',
                tarek_idle_left: 'assets/personagens/Tarek/gifs/tarek-parado01_mirrored.gif',
                tarek_walk_right: 'assets/personagens/Tarek/gifs/tarek-andando01.gif',
                tarek_walk_left: 'assets/personagens/Tarek/gifs/tarek-andando01_mirrored.gif',
                tarek_ability1_right: 'assets/personagens/Tarek/gifs/tarek-habilidade1.gif', // Golpe Devastador
                tarek_ability1_left: 'assets/personagens/Tarek/gifs/tarek-habilidade1_mirrored.gif',
                tarek_ability2_right: 'assets/personagens/Tarek/gifs/tarek-habilidade2.gif', // Investida Gélida
                tarek_ability2_left: 'assets/personagens/Tarek/gifs/tarek-habilidade2_mirrored.gif',
                tarek_ability3_right: 'assets/personagens/Tarek/gifs/tarek-habilidade3.gif', // Orbe Congelante
                tarek_ability3_left: 'assets/personagens/Tarek/gifs/tarek-habilidade3_mirrored.gif',
                tarek_ability4_right: 'assets/personagens/Tarek/gifs/tarek-habilidade4.gif', // Prisão de Gelo
                tarek_ability4_left: 'assets/personagens/Tarek/gifs/tarek-habilidade4_mirrored.gif',
                tarek_jump_right: 'assets/personagens/Tarek/gifs/tarek-salto01.gif', // Placeholder
                tarek_jump_left: 'assets/personagens/Tarek/gifs/tarek-salto01_mirrored.gif', // Placeholder
                tarek_roar: 'assets/personagens/Tarek/gifs/tarek-rugido.gif', // Usado na introdução da luta

                // Projéteis e Efeitos (GIFs/Imagens)
                projectile_player_i: 'assets/efeitos/projeteis/pedra-negra.gif', // Projétil do player I
                projectile_player_ultimate: 'assets/efeitos/projeteis/pedra-negra-ultimate.gif', // Projétil do player Ultimate
                explosion_general: 'assets/efeitos/explosao-geral.gif',
                tarek_ice_orb: 'assets/efeitos/projeteis/orbe-gelo-tarek.gif',
                tarek_prison_wall: 'assets/efeitos/prisao-gelo-tarek.gif',
                
                // Cutscenes (GIFs)
                cutscene_intro_1: 'assets/animacoes/BatalhaTelaInicial.gif', // Exemplo de GIF de cutscene
                cutscene_intro_2: 'assets/animacoes/reino-congelado.gif',
                cutscene_intro_3: 'assets/animacoes/umbra-convocacao.gif',
                cutscene_intro_4: 'assets/animacoes/destino-guerra.gif',

                // Audio (MP3s)
                music_menu: 'assets/audio/music/menu.mp3',
                music_platforming: 'assets/audio/music/platforming.mp3',
                music_boss_tarek: 'assets/audio/music/tarek_boss.mp3',
                sfx_jump: 'assets/audio/sfx/jump.mp3',
                sfx_attack_u: 'assets/audio/sfx/attack_u.mp3', // Soco
                sfx_ability_i: 'assets/audio/sfx/ability_i.mp3', // Disparo
                sfx_ability_o: 'assets/audio/sfx/ability_o.mp3', // Investida
                sfx_ability_p: 'assets/audio/sfx/ability_p.mp3', // Ultimate
                sfx_damage_player: 'assets/audio/sfx/damage_player.mp3',
                sfx_damage_enemy: 'assets/audio/sfx/damage_enemy.mp3',
                sfx_level_up: 'assets/audio/sfx/level_up.mp3',
                sfx_boss_roar: 'assets/audio/sfx/boss_roar.mp3',
            }
        };

        // ===== VARIÁVEIS GLOBAIS =====
        let canvas, ctx;
        let isMobile = false;
        let isLandscape = true;
        
        // Estado do jogo
        let gameState = {
            playerName: '',
            playerClass: 'chosenOne', // Classe fixa: Escolhido
            playerHealth: 100,
            playerMaxHealth: 100,
            playerMana: 100,
            playerMaxMana: 100,
            playerPosition: { x: 100, y: 300 },
            playerVelocity: { x: 0, y: 0 },
            playerLevel: 1,
            playerXP: 0,
            playerNextLevelXP: 100,
            playerDamage: 15,
            playerSpeed: CONFIG.PLAYER_BASE_SPEED,
            
            // Estados do Jogador
            isGrounded: false,
            isCrouching: false,
            isInvincible: false,
            invincibilityTimer: 0,
            facing: 'right', // 'right' ou 'left'
            currentAnimation: 'idle', // Nome da animação atual (ex: 'idle', 'walk', 'jump', 'attack_u')
            animationFrameTimer: 0, // Para controlar a duração das animações de ataque
            animationDuration: 300, // Duração padrão de uma animação de ataque em ms
            isUmbraFurious: false,
            umbraFuryTimer: 0,
            
            // Habilidades (cooldowns dinâmicos)
            abilitiesCooldown: { U: 0, I: 0, O: 0, P: 0 },
            abilitiesMaxCooldown: { U: 0.5, I: 1.5, O: 3, P: 15 }, // Ajustado para novo balanceamento
            
            // Controle de jogo
            gamePaused: false,
            inDialog: false,
            inCutscene: false,
            cutsceneCurrentStep: 0, // Novo: controla o passo atual da cutscene
            introCutscenesCompleted: false, // Novo: flag para saber se a intro foi completa
            inMenu: true,
            gameStarted: false,
            
            // Câmera
            cameraOffset: { x: 0, y: 0 },
            targetCameraOffset: { x: 0, y: 0 },
            
            // Fase atual
            currentPhase: 0,
            currentCheckpoint: 'start',
            
            // Boss fight
            inBossFight: false,
            bossDefeated: false,

            // Tarek Encounter
            inTarekEncounter: false,
            tarekDialogStep: 0,
            tarekDialogCompleted: false,

            // Fixed camera for specific encounters
            fixedCamera: false,
            fixedCameraTarget: { x: 0, y: 0 }
        };

        // Arrays de entidades
        let platforms = [];
        let particles = [];
        let backgroundLayers = [];
        let enemies = [];
        let abilityEffects = [];
        let damageNumbers = [];
        let checkpoints = [];
        let fallingSpikes = [];
        
        // Controles
        let keys = {};
        let lastTime = 0;
        let animationFrameId = null;
        
        // Mobile controls (D-pad)
        let mobileControls = {
            up: false,
            down: false,
            left: false,
            right: false,
            abilityU: false,
            abilityI: false,
            abilityO: false,
            abilityP: false
        };

        // Assets carregados
        const assetCache = {};

        // Variáveis de estado UI para otimização
        let lastPlayerHealth = -1;
        let lastPlayerMana = -1;
        let lastPlayerXP = -1;
        let lastPlayerLevel = -1;
        let lastPlayerClass = '';
        let lastPlayerDamage = -1;

        // Pré-cálculo de cores CSS para performance
        let COLOR_HEALTH, COLOR_MANA, COLOR_XP, COLOR_ACCENT_FIRE, COLOR_ACCENT_GOLD, COLOR_ACCENT_BLUE, COLOR_ACCENT_ICE, COLOR_TEXT_LIGHT, COLOR_ARCHER, COLOR_WARRIOR, COLOR_PLAYER;


        // ===== SISTEMA DE ÁUDIO =====
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let currentMusic = null;

        async function loadAsset(name, url, type) {
            if (type === 'audio') {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    assetCache[name] = audioBuffer;
                } catch (error) {
                    console.error(`Erro ao carregar o áudio '${name}':`, error);
                    assetCache[name] = audioContext.createBuffer(2, 22050, 44100); /* Buffer vazio para evitar erros */
                }
            } else if (type === 'image' || type === 'gif') {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = url;
                    img.onload = () => {
                        assetCache[name] = img;
                        resolve(img);
                    };
                    img.onerror = (err) => {
                        console.error(`Erro ao carregar a imagem '${name}':`, err);
                        assetCache[name] = null; // Marcar como falha
                        reject(err);
                    };
                });
            }
        }

        async function loadAllAssets() {
            const assetPromises = [];
            for (const [key, path] of Object.entries(CONFIG.ASSET_PATHS)) {
                let type = 'image';
                if (path.endsWith('.mp3')) type = 'audio';
                if (path.endsWith('.gif')) type = 'gif'; // GIFs são tratados como imagens
                assetPromises.push(loadAsset(key, path, type));
            }
            await Promise.all(assetPromises);
            console.log("Todos os assets carregados.");
        }

        function playSound(name, volume = 1.0) {
            if (!assetCache[name]) {
                console.warn(`Áudio '${name}' não carregado.`);
                return;
            }
            try {
                const source = audioContext.createBufferSource();
                source.buffer = assetCache[name];
                const gainNode = audioContext.createGain();
                gainNode.gain.value = volume * gameSettings.sfxVolume;
                source.connect(gainNode).connect(audioContext.destination);
                source.start(0);
            } catch (error) {
                console.error("Erro ao reproduzir som:", error);
            }
        }

        function playMusic(name, loop = true, volume = 0.7) {
            if (currentMusic) {
                try {
                    currentMusic.stop();
                    currentMusic.disconnect();
                } catch (error) {
                    console.error("Erro ao parar música anterior:", error);
                }
                currentMusic = null;
            }

            if (!assetCache[name]) {
                console.warn(`Música '${name}' não carregada.`);
                return;
            }

            try {
                const source = audioContext.createBufferSource();
                source.buffer = assetCache[name];
                source.loop = loop;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = volume * gameSettings.musicVolume;
                source.connect(gainNode).connect(audioContext.destination);
                source.start(0);
                currentMusic = source;
            } catch (error) {
                console.error("Erro ao reproduzir música:", error);
            }
        }

        function stopMusic() {
            if (currentMusic) {
                try {
                    currentMusic.stop();
                    currentMusic.disconnect();
                } catch (error) {
                    console.error("Erro ao parar música:", error);
                }
                currentMusic = null;
            }
        }

        // ===== DETECÇÃO DE DISPOSITIVO =====
        function detectDevice() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      window.innerWidth <= 800 || 
                      'ontouchstart' in window;
            
            if (isMobile) {
                checkOrientation();
                window.addEventListener('orientationchange', () => {
                    setTimeout(checkOrientation, 100);
                });
                window.addEventListener('resize', checkOrientation);
            }
        }

        function checkOrientation() {
            if (!isMobile) return;
            
            isLandscape = window.innerWidth > window.innerHeight;
            const orientationWarning = document.getElementById('orientation-warning');
            
            if (!isLandscape) {
                orientationWarning.style.display = 'flex';
                if (gameState.gameStarted && !gameState.gamePaused && !gameState.inMenu) {
                    togglePause();
                }
            } else {
                orientationWarning.style.display = 'none';
                if (gameState.gameStarted && gameState.gamePaused && !gameState.inMenu && !gameState.inCutscene) {
                    togglePause();
                }
            }
            updateMobileControlsVisibility();
        }

        // ===== SISTEMA DE COOKIES =====
        function setCookie(name, value, days = 30) {
            const expires = new Date();
            expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function saveProgress() {
            const saveData = {
                playerName: gameState.playerName,
                playerClass: gameState.playerClass,
                playerLevel: gameState.playerLevel,
                playerXP: gameState.playerXP,
                playerMaxHealth: gameState.playerMaxHealth,
                playerMaxMana: gameState.playerMaxMana,
                playerDamage: gameState.playerDamage,
                playerSpeed: gameState.playerSpeed,
                currentPhase: gameState.currentPhase,
                currentCheckpoint: gameState.currentCheckpoint,
                bossDefeated: gameState.bossDefeated,
                abilitiesMaxCooldown: gameState.abilitiesMaxCooldown,
                manaRegenRate: CONFIG.MANA_REGEN_RATE
            };
            
            setCookie('tupary_save', JSON.stringify(saveData));
            showCheckpointNotification('Progresso Salvo', 'Seu progresso foi salvo com sucesso!');
        }

        function loadProgress() {
            const saveData = getCookie('tupary_save');
            if (saveData) {
                try {
                    const data = JSON.parse(saveData);
                    return data;
                } catch (e) {
                    console.error('Erro ao carregar save:', e);
                }
            }
            return null;
        }

        // ===== INICIALIZAÇÃO =====
        async function init() {
            detectDevice();
            
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            await loadAllAssets(); // Carrega todos os assets (imagens, GIFs, áudios)
            
            initGlobalColors(); /* Pré-calcula as cores CSS */
            setupCharacter('chosenOne'); // O Escolhido é a única classe
            initEventListeners();
            initMobileControls();
            
            const savedData = loadProgress();
            if (savedData) {
                populateMainMenuWithSavedData(savedData);
            } else {
                playMusic('music_menu', true);
            }
            
            gameLoop(0);
        }

        /* Nova função: Pré-calcula cores CSS para acesso mais rápido */
        function initGlobalColors() {
            const rootStyle = getComputedStyle(document.documentElement);
            COLOR_HEALTH = rootStyle.getPropertyValue('--health-color');
            COLOR_MANA = rootStyle.getPropertyValue('--mana-color');
            COLOR_XP = rootStyle.getPropertyValue('--xp-color');
            COLOR_ACCENT_FIRE = rootStyle.getPropertyValue('--accent-fire');
            COLOR_ACCENT_GOLD = rootStyle.getPropertyValue('--accent-gold');
            COLOR_ACCENT_BLUE = rootStyle.getPropertyValue('--accent-blue');
            COLOR_ACCENT_ICE = rootStyle.getPropertyValue('--accent-ice');
            COLOR_TEXT_LIGHT = rootStyle.getPropertyValue('--text-light');
            COLOR_ARCHER = rootStyle.getPropertyValue('--archer-color');
            COLOR_WARRIOR = rootStyle.getPropertyValue('--warrior-color');
            COLOR_PLAYER = rootStyle.getPropertyValue('--player-color');
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            if (isMobile) {
                updateMobileControlsVisibility();
            }
        }

        function populateMainMenuWithSavedData(data) {
            document.getElementById('player-name').value = data.playerName || '';
            // Não há seleção de classe, então a classe é sempre 'chosenOne'
            validateMenuInputs();

            // Restaurar habilidades, stats, etc., do save
            Object.assign(gameState, {
                playerHealth: data.playerHealth,
                playerMaxHealth: data.playerMaxHealth,
                playerMana: data.playerMana,
                playerMaxMana: data.playerMaxMana,
                playerLevel: data.playerLevel,
                playerXP: data.playerXP,
                playerDamage: data.playerDamage,
                playerSpeed: data.playerSpeed,
                abilitiesMaxCooldown: data.abilitiesMaxCooldown,
                manaRegenRate: data.manaRegenRate,
                currentPhase: data.currentPhase,
                currentCheckpoint: data.currentCheckpoint,
                bossDefeated: data.bossDefeated,
            });
            
            // Se o jogo já estava iniciado e as cutscenes completas
            if (data.gameStarted && !data.inMenu && data.introCutscenesCompleted) {
                gameState.gameStarted = true;
                gameState.inMenu = false;
                gameState.introCutscenesCompleted = true; // Definir explicitamente como true
                document.getElementById('main-menu').style.display = 'none';
                loadPhase(gameState.currentPhase);
                updateAllUI();
                playMusic('music_platforming', true);
            } else {
                playMusic('music_menu', true); // Se não, volta para o menu
            }
        }

        // ===== CLASSES DE PERSONAGEM (Apenas "chosenOne" agora) =====
        // Adaptação de setupCharacter para receber apenas o nome da classe, ou dados salvos
        function setupCharacter(playerClass, health = null, mana = null, damage = null, speed = null, abilitiesMaxCooldown = null, manaRegenRate = null) {
            // A classe é sempre 'chosenOne'
            const chosenOneClass = {
                id: 'chosenOne',
                name: 'Escolhido',
                type: 'hybrid', // Equilibrado, não extremamente poderoso
                baseHealth: 100,
                baseMana: 100,
                baseSpeed: CONFIG.PLAYER_BASE_SPEED,
                baseDamage: 15,
                abilitiesMaxCooldown: { U: 0.5, I: 1.5, O: 3, P: 15 }, // Ajustado
                manaRegenRate: 1.5,
                abilities: [
                    {
                        key: 'U',
                        name: 'Soco',
                        description: 'Ataque corpo a corpo rápido.',
                        damage: (base) => base * 1.0,
                        manaCost: 0,
                        cooldown: 0.5,
                        animation: 'player_attack_u',
                        execute: function() {
                            playSound('sfx_attack_u');
                            addAbilityEffect({
                                type: 'meleeAttack',
                                x: gameState.playerPosition.x + (gameState.facing === 'right' ? CONFIG.PLAYER_SPRITE_WIDTH * 0.8 : -CONFIG.PLAYER_SPRITE_WIDTH * 0.3),
                                y: gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT * 0.5,
                                width: CONFIG.PLAYER_SPRITE_WIDTH * 0.5,
                                height: CONFIG.PLAYER_SPRITE_HEIGHT * 0.3,
                                duration: 200,
                                damage: this.damage(gameState.playerDamage),
                                origin: 'player'
                            });
                        }
                    },
                    {
                        key: 'I',
                        name: 'Disparo',
                        description: 'Lança um projétil negro de energia.',
                        damage: (base) => base * 1.2,
                        manaCost: 10, // Custa menos mana devido ao personagem híbrido
                        cooldown: 1.5,
                        animation: 'player_attack_i',
                        execute: function() {
                            playSound('sfx_ability_i');
                            addAbilityEffect({
                                type: 'energyProjectile',
                                x: gameState.playerPosition.x + (gameState.facing === 'right' ? CONFIG.PLAYER_SPRITE_WIDTH : -CONFIG.PLAYER_SPRITE_WIDTH * 0.2),
                                y: gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT * 0.5,
                                width: 25,
                                height: 15,
                                duration: 1500,
                                damage: this.damage(gameState.playerDamage),
                                direction: gameState.facing === 'right' ? 1 : -1,
                                speed: 8,
                                origin: 'player',
                                piercing: false,
                                asset: 'projectile_player_i'
                            });
                        }
                    },
                    {
                        key: 'O',
                        name: 'Investida',
                        description: 'Dash rápido que causa dano e concede invulnerabilidade temporária.',
                        damage: (base) => base * 0.8, // Dano base menor, mas com invulnerabilidade
                        manaCost: 25,
                        cooldown: 3,
                        animation: 'player_attack_o',
                        execute: function() {
                            playSound('sfx_ability_o');
                            gameState.playerVelocity.x = (gameState.facing === 'right' ? 12 : -12);
                            gameState.isInvincible = true;
                            gameState.invincibilityTimer = 300; // Duração da invulnerabilidade
                            addParticles('dashEffect', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2, 20);
                            
                            // Aplica dano em área durante o dash
                            addAbilityEffect({
                                type: 'chargeAttack', // Reutiliza a lógica de chargeAttack para dano em área
                                x: gameState.playerPosition.x,
                                y: gameState.playerPosition.y,
                                width: CONFIG.PLAYER_SPRITE_WIDTH,
                                height: CONFIG.PLAYER_SPRITE_HEIGHT,
                                duration: 300,
                                damage: this.damage(gameState.playerDamage),
                                origin: 'player',
                                knockback: 0,
                                areaEffect: true
                            });
                        }
                    },
                    {
                        key: 'P',
                        name: 'Fúria de Umbra',
                        description: 'Canaliza a energia de Umbra para ficar mais rápido, resistente e poderoso.',
                        damage: (base) => base, // O dano base é aumentado pelos bônus
                        manaCost: 50,
                        cooldown: 15,
                        animation: 'player_ultimate',
                        execute: function() {
                            playSound('sfx_ability_p');
                            gameState.isUmbraFurious = true;
                            gameState.umbraFuryTimer = CONFIG.UMBRA_FURY_DURATION;
                            addParticles('umbraFuria', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2, 40);
                            // Aplica um filtro temporário ao canvas para efeito visual da ultimate
                            canvas.style.filter = 'brightness(1.5) saturate(1.5) hue-rotate(90deg)';
                            setTimeout(() => {
                                canvas.style.filter = 'none'; // Remove o filtro após a duração
                            }, CONFIG.UMBRA_FURY_DURATION);
                        }
                    }
                ]
            };

            gameState.playerMaxHealth = health !== null ? health : chosenOneClass.baseHealth;
            gameState.playerHealth = gameState.playerMaxHealth;
            gameState.playerMaxMana = mana !== null ? mana : chosenOneClass.baseMana;
            gameState.playerMana = gameState.playerMaxMana;
            gameState.playerSpeed = speed !== null ? speed : chosenOneClass.baseSpeed;
            gameState.playerDamage = damage !== null ? damage : chosenOneClass.baseDamage;

            // Sobrescreve os cooldowns e taxa de regeneração com os da classe ou salvos
            Object.assign(gameState.abilitiesMaxCooldown, abilitiesMaxCooldown !== null ? abilitiesMaxCooldown : chosenOneClass.abilitiesMaxCooldown);
            CONFIG.MANA_REGEN_RATE = manaRegenRate !== null ? manaRegenRate : chosenOneClass.manaRegenRate;
            
            // Adiciona as habilidades do Escolhido no objeto global para acesso
            gameState.chosenOneAbilities = chosenOneClass.abilities;
            updateAbilityTooltips();
            updateAllUI();
        }

        function updateAbilityTooltips() {
            if (!gameState.chosenOneAbilities) return; // Garante que as habilidades já foram definidas
            
            gameState.chosenOneAbilities.forEach(ability => {
                const key = ability.key.toLowerCase();
                const nameEl = document.getElementById(`tooltip-${key}-name`);
                const descEl = document.getElementById(`tooltip-${key}-desc`);
                const costEl = document.getElementById(`tooltip-${key}-cost`);
                
                if (nameEl) nameEl.textContent = ability.name;
                if (descEl) descEl.textContent = ability.description;
                if (costEl) costEl.textContent = `Custo: ${ability.manaCost} Mana`;
            });
        }

        // ===== EVENT LISTENERS =====
        function initEventListeners() {
            /* Menu Principal */
            document.getElementById('player-name').addEventListener('input', validateMenuInputs);
            document.getElementById('start-game-btn').addEventListener('click', startGame);
            
            /* Controles de teclado */
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            /* Botões da UI */
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('restart-btn').addEventListener('click', restartFromCheckpoint);
            document.getElementById('save-btn').addEventListener('click', saveProgress);
            document.getElementById('exit-btn').addEventListener('click', exitToMenu);
            document.getElementById('next-btn').addEventListener('click', advanceCutscene); // Botão "Próximo" para cutscenes
            
            /* Habilidades desktop */
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.key;
                    if (key) useAbility(key);
                });
            });
            
            /* Level up (com escolhas) */
            document.querySelectorAll('.upgrade-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const upgrade = e.currentTarget.dataset.upgrade;
                    applyUpgrade(upgrade);
                });
            });
        }

        function handleKeyDown(e) {
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            keys[e.key.toLowerCase()] = true;

            if (e.key === 'Escape' && gameState.gameStarted && !gameState.inMenu && !gameState.inCutscene) {
                togglePause();
            }
            
            // O botão "Pular" agora é "Próximo" e tem sua própria função de clique
            // if ((e.key === ' ' || e.key === 'Enter') && gameState.inCutscene) {
            //     advanceCutscene(); 
            // }
            
            if (['u', 'i', 'o', 'p'].includes(e.key.toLowerCase()) && 
                !gameState.gamePaused && !gameState.inDialog && !gameState.inCutscene && !gameState.inMenu) {
                useAbility(e.key.toUpperCase());
            }
        }

        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }

        // ===== CONTROLES MOBILE =====
        function initMobileControls() {
            /* D-pad */
            document.getElementById('mobile-up').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.up = true; });
            document.getElementById('mobile-up').addEventListener('touchend', () => mobileControls.up = false);
            document.getElementById('mobile-down').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.down = true; });
            document.getElementById('mobile-down').addEventListener('touchend', () => mobileControls.down = false);
            document.getElementById('mobile-left').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.left = true; });
            document.getElementById('mobile-left').addEventListener('touchend', () => mobileControls.left = false);
            document.getElementById('mobile-right').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.right = true; });
            document.getElementById('mobile-right').addEventListener('touchend', () => mobileControls.right = false);

            /* Botões de Habilidade */
            document.getElementById('mobile-ability-u').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('U'); });
            document.getElementById('mobile-ability-i').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('I'); });
            document.getElementById('mobile-ability-o').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('O'); });
            document.getElementById('mobile-ability-p').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('P'); });
            updateMobileControlsVisibility();
        }

        function updateMobileControlsVisibility() {
            const mobileControlsDiv = document.getElementById('mobile-controls');
            if (isMobile && isLandscape) {
                mobileControlsDiv.style.display = 'grid';
            } else {
                mobileControlsDiv.style.display = 'none';
            }
        }

        // ===== MENU PRINCIPAL =====
        function validateMenuInputs() {
            const name = document.getElementById('player-name').value.trim();
            // A seleção de classe é fixa, então apenas o nome importa
            const startBtn = document.getElementById('start-game-btn');
            
            if (name.length >= 2) {
                startBtn.disabled = false;
            } else {
                startBtn.disabled = true;
            }
        }

        function startGame() {
            const name = document.getElementById('player-name').value.trim();
            if (name.length < 2) return;
            
            gameState.playerName = name;
            gameState.inMenu = false;
            gameState.gameStarted = true;
            gameState.playerClass = 'chosenOne'; // Garante que a classe é definida no início

            document.getElementById('main-menu').style.display = 'none';
            
            // setupCharacter('chosenOne'); // Já foi chamado na inicialização para carregar tooltips
            
            if (isMobile) {
                updateMobileControlsVisibility();
            }
            
            stopMusic();
            showIntroCutscene();
        }

        function exitToMenu() {
            saveProgress();
            
            /* Reinicia o estado do jogo para o menu principal */
            gameState = {
                playerName: '',
                playerClass: 'chosenOne',
                playerHealth: 100, playerMaxHealth: 100,
                playerMana: 100, playerMaxMana: 100,
                playerPosition: { x: 100, y: 300 },
                playerVelocity: { x: 0, y: 0 },
                playerLevel: 1, playerXP: 0, playerNextLevelXP: 100,
                playerDamage: 15, playerSpeed: CONFIG.PLAYER_BASE_SPEED,
                isGrounded: false, isCrouching: false, isInvincible: false, facing: 'right', currentAnimation: 'idle',
                animationFrameTimer: 0, animationDuration: 300,
                isUmbraFurious: false, umbraFuryTimer: 0,
                abilitiesCooldown: { U: 0, I: 0, O: 0, P: 0 },
                abilitiesMaxCooldown: { U: 0.5, I: 1.5, O: 3, P: 15 },
                gamePaused: false, inDialog: false, inCutscene: false,
                cutsceneCurrentStep: 0,
                introCutscenesCompleted: false,
                inMenu: true,
                gameStarted: false,
                cameraOffset: { x: 0, y: 0 }, targetCameraOffset: { x: 0, y: 0 },
                currentPhase: 0, currentCheckpoint: 'start',
                inBossFight: false, bossDefeated: false,
                inTarekEncounter: false, tarekDialogStep: 0, tarekDialogCompleted: false,
                fixedCamera: false, fixedCameraTarget: { x: 0, y: 0 }
            };

            /* Limpa todas as entidades */
            platforms = []; enemies = []; abilityEffects = []; particles = []; damageNumbers = []; checkpoints = []; fallingSpikes = [];
            
            /* Exibe o menu principal */
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'none';
            document.getElementById('abilities-container').style.display = 'flex';
            document.getElementById('player-name').value = '';
            document.getElementById('start-game-btn').disabled = true;

            updateAllUI(); /* Limpa os últimos valores para forçar atualização ao carregar */
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            stopMusic();
            playMusic('music_menu', true);
        }

        // ===== SISTEMA DE FASES E NARRATIVA =====
        function loadPhase(phaseNumber) {
            gameState.currentPhase = phaseNumber;
            
            gameState.playerPosition = { x: 100, y: 300 };
            gameState.playerVelocity = { x: 0, y: 0 };
            gameState.isGrounded = false;
            gameState.isCrouching = false;
            
            enemies = [];
            abilityEffects = [];
            particles = [];
            damageNumbers = [];
            fallingSpikes = [];
            
            switch(phaseNumber) {
                case 1:
                    setupPhase1_MuralhasAurora();
                    stopMusic();
                    playMusic('music_platforming', true);
                    break;
                case 2:
                    setupPhase1_TarekEncounter();
                    break;
                case 3:
                    setupPhase1_TarekBossFight();
                    break;
                default:
                    setupPhase1_MuralhasAurora();
            }
            
            gameState.cameraOffset = { x: 0, y: 0 };
            gameState.targetCameraOffset = { x: 0, y: 0 };
        }

        function setupPhase1_MuralhasAurora() {
            platforms = [
                { x: 0, y: 400, width: 6000, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 200, y: 350, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 350, y: 300, width: 80, height: 20, type: 'platform', slippery: true, asset: 'platform_ice' },
                { x: 500, y: 250, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 700, y: 320, width: 120, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 900, y: 380, width: 50, height: 20, type: 'platform', asset: 'platform_ground' },
                
                { x: 1100, y: 400, width: 150, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 1100, y: 350, width: 150, height: 50, type: 'spike', asset: 'platform_spike' },
                { x: 1300, y: 400, width: 100, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 1500, y: 300, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 1700, y: 250, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 2000, y: 350, width: 120, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 2300, y: 400, width: 200, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 2300, y: 350, width: 200, height: 50, type: 'spike', asset: 'platform_spike' },
                { x: 2600, y: 300, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 2800, y: 250, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 3100, y: 400, width: 150, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 3400, y: 350, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 3600, y: 300, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 3900, y: 400, width: 200, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 4200, y: 350, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 4400, y: 300, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 4700, y: 250, width: 120, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 5000, y: 400, width: 1000, height: 50, type: 'ground', asset: 'platform_ground' },
            ];

            fallingSpikes = [
                { x: 800, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 1200, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 1800, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 2400, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 3000, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 3800, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 4500, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
            ];

            enemies = [
                {
                    type: 'sentinel',
                    position: { x: 600, y: 300 },
                    health: 50, maxHealth: 50, damage: 10, speed: 1,
                    patrolRange: 100, xpValue: 20, direction: 1, attackCooldown: 0,
                    currentAnimation: 'idle', animationTimer: 0, animationDuration: 500
                },
                {
                    type: 'sentinel',
                    position: { x: 1600, y: 250 },
                    health: 50, maxHealth: 50, damage: 10, speed: 1,
                    patrolRange: 120, xpValue: 20, direction: 1, attackCooldown: 0,
                    currentAnimation: 'idle', animationTimer: 0, animationDuration: 500
                },
                {
                    type: 'sentinel',
                    position: { x: 2700, y: 250 },
                    health: 50, maxHealth: 50, damage: 10, speed: 1,
                    patrolRange: 100, xpValue: 20, direction: -1, attackCooldown: 0,
                    currentAnimation: 'idle', animationTimer: 0, animationDuration: 500
                },
                {
                    type: 'sentinel',
                    position: { x: 3700, y: 300 },
                    health: 50, maxHealth: 50, damage: 10, speed: 1,
                    patrolRange: 150, xpValue: 20, direction: 1, attackCooldown: 0,
                    currentAnimation: 'idle', animationTimer: 0, animationDuration: 500
                },
                {
                    type: 'sentinel',
                    position: { x: 4600, y: 250 },
                    health: 50, maxHealth: 50, damage: 10, speed: 1,
                    patrolRange: 100, xpValue: 20, direction: -1, attackCooldown: 0,
                    currentAnimation: 'idle', animationTimer: 0, animationDuration: 500
                }
            ];

            checkpoints = [
                { x: 1000, y: 350, width: 50, height: 50, name: 'checkpoint1', description: 'Primeiro Checkpoint' },
                { x: 2500, y: 350, width: 50, height: 50, name: 'checkpoint2', description: 'Segundo Checkpoint' },
                { x: 4000, y: 350, width: 50, height: 50, name: 'checkpoint3', description: 'Terceiro Checkpoint' },
            ];
            
            // As camadas de fundo agora usam assets de imagem
            backgroundLayers = [
                { asset: 'bg_sky', speed: 0.1 },
                { asset: 'bg_mountains', speed: 0.3 },
                { asset: 'bg_hills', speed: 0.5 },
                { asset: 'bg_foreground', speed: 0.7 }
            ];

            CONFIG.WORLD_WIDTH = 6000;
            
            gameState.inTarekEncounter = false;
            gameState.tarekDialogStep = 0;
            gameState.tarekDialogCompleted = false;
            gameState.fixedCamera = false;
        }

        function setupPhase1_TarekEncounter() {
            platforms = [
                { x: 0, y: 400, width: canvas.width, height: 50, type: 'ground', asset: 'platform_ground' }
            ];
            enemies = [];
            checkpoints = [];
            
            backgroundLayers = [
                { asset: 'bg_sky', speed: 0.1 },
                { asset: 'bg_mountains', speed: 0.3 }
            ];

            gameState.fixedCamera = true;
            gameState.fixedCameraTarget = { x: 0, y: 0 };
            gameState.playerPosition = { x: 150, y: 300 };
            gameState.playerVelocity = { x: 0, y: 0 };

            const tarek = {
                type: 'boss_dialogue', // Tipo especial para Tarek apenas em diálogo
                name: 'Tarek, o Guerreiro',
                position: { x: canvas.width - 150, y: 300 }, // Posiciona Tarek no canto direito da tela
                facing: 'left',
                health: 1, maxHealth: 1,
                damage: 0,
                currentAnimation: 'idle', animationTimer: 0, animationDuration: 500
            };
            enemies.push(tarek);
            
            gameState.inTarekEncounter = true;
            startTarekDialogue();
        }

        function setupPhase1_TarekBossFight() {
            platforms = [
                { x: 0, y: 400, width: canvas.width, height: 50, type: 'ground', asset: 'platform_ground' }
            ];
            enemies = [];
            checkpoints = [];
            
            backgroundLayers = [
                { asset: 'bg_sky', speed: 0.1 },
                { asset: 'bg_mountains', speed: 0.3 }
            ];

            gameState.fixedCamera = true;
            gameState.fixedCameraTarget = { x: 0, y: 0 };
            gameState.playerPosition = { x: 150, y: 300 };
            
            gameState.playerHealth = gameState.playerMaxHealth;
            gameState.playerMana = gameState.playerMaxMana;
            updateHealthBar();
            updateManaBar();
            
            triggerBossFight();
            stopMusic();
            playMusic('music_boss_tarek', true);
        }

        // ===== CUTSCENES E NARRATIVA =====
        const cinematicSequence = [
            {
                title: "A CONVOCAÇÃO",
                text: `Umbra, a entidade primordial do equilíbrio, convoca você, %PLAYER_NAME%, o Escolhido.`,
                image: 'cutscene_intro_3',
                minTextTime: 4000
            },
            {
                title: "O DESEQUILÍBRIO",
                text: "O mundo treme sob o peso do desequilíbrio. Ignys, o Reino do Fogo, deseja guerra e já move suas tropas em direção aos reinos vizinhos.",
                image: 'cutscene_intro_1',
                minTextTime: 5000
            },
            {
                title: "O CORAÇÃO DE GELO",
                text: "Em Tupãry, o Reino Congelado, guarda-se a metade maligna de Anhangá, o espírito que traz caos. Se Ignys a obter, será o fim de tudo.",
                image: 'cutscene_intro_2',
                minTextTime: 6000
            },
            {
                title: "O DESTINO",
                text: "Recupere o Coração de Gelo e impeça que Ignys domine todos os reinos. Cada passo, cada luta, cada escolha será decisiva para a sobrevivência de todos.",
                image: 'cutscene_intro_4',
                minTextTime: 7000
            }
        ];

        function showIntroCutscene() {
            gameState.inCutscene = true;
            gameState.cutsceneCurrentStep = 0;
            document.getElementById('cinematic-overlay').style.display = 'flex';
            advanceCutscene(); // Inicia a primeira cutscene
        }

        function advanceCutscene() {
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            const imageElement = document.getElementById('cinematic-image');
            const nextBtn = document.getElementById('next-btn');

            if (gameState.cutsceneCurrentStep < cinematicSequence.length) {
                const step = cinematicSequence[gameState.cutsceneCurrentStep];

                titleElement.textContent = step.title;
                textElement.textContent = step.text.replace('%PLAYER_NAME%', gameState.playerName);

                // Exibir ou ocultar imagem
                if (step.image && assetCache[step.image]) {
                    imageElement.src = assetCache[step.image].src;
                    imageElement.style.opacity = '0.3'; // Garante que a imagem esteja visível mas discreta
                    overlay.classList.add('with-image');
                } else {
                    imageElement.src = '';
                    imageElement.style.opacity = '0';
                    overlay.classList.remove('with-image');
                }
                
                titleElement.style.animation = 'none';
                textElement.style.animation = 'none';
                void titleElement.offsetWidth; // Trigger reflow
                void textElement.offsetWidth; // Trigger reflow
                
                titleElement.style.animation = 'fadeInText 2s forwards';
                textElement.style.animation = 'fadeInText 3s forwards 0.5s';

                // O botão "Próximo" já está visível por padrão na cutscene
                // nextBtn.style.display = 'block'; // Garante que o botão esteja visível

                gameState.cutsceneCurrentStep++;
            } else {
                endIntroCutscenes();
            }
        }
            
        function endIntroCutscenes() {
            document.getElementById('cinematic-overlay').style.display = 'none';
            gameState.inCutscene = false;
            gameState.introCutscenesCompleted = true; // Marca que as cutscenes foram completas
            loadPhase(1); // Inicia o jogo na primeira fase
        }

        function showDialog(speaker, text, options = null) {
            gameState.inDialog = true;
            gameState.gamePaused = true;
            const dialogContainer = document.getElementById('dialog-container');
            const speakerElement = document.getElementById('dialog-speaker');
            const textElement = document.getElementById('dialog-text');
            const optionsElement = document.getElementById('dialog-options');
            
            dialogContainer.style.display = 'block';
            speakerElement.textContent = speaker;
            textElement.textContent = text;
            
            optionsElement.innerHTML = '';
            
            if (options && options.length > 0) {
                options.forEach((option, index) => {
                    const button = document.createElement('div');
                    button.className = 'dialog-option';
                    button.textContent = option.text;
                    button.addEventListener('click', () => {
                        dialogContainer.style.display = 'none';
                        gameState.inDialog = false;
                        gameState.gamePaused = false;
                        if (option.action) option.action();
                    });
                    optionsElement.appendChild(button);
                });
            } else {
                const button = document.createElement('div');
                button.className = 'dialog-option';
                button.textContent = 'Continuar';
                button.addEventListener('click', () => {
                    dialogContainer.style.display = 'none';
                    gameState.inDialog = false;
                    gameState.gamePaused = false;
                });
                optionsElement.appendChild(button);
            }
        }

        function startTarekDialogue() {
            gameState.tarekDialogStep = 0;
            const tarekDialogs = [
                { speaker: "TAREK, O GUERREIRO", text: `Então você é ${gameState.playerName}, o tal Escolhido?` },
                { speaker: "TAREK, O GUERREIRO", text: "Estas muralhas não são lugar para forasteiros fracos." },
                { speaker: "TAREK, O GUERREIRO", text: "Prove que merece passar por aqui, ou volte de onde veio!" }
            ];

            function showTarekLine() {
                if (gameState.tarekDialogStep < tarekDialogs.length) {
                    const line = tarekDialogs[gameState.tarekDialogStep];
                    showDialog(line.speaker, line.text, [{ text: "Continuar", action: () => {
                        gameState.tarekDialogStep++;
                        showTarekLine();
                    }}]);
                } else {
                    gameState.tarekDialogCompleted = true;
                    gameState.inTarekEncounter = false;
                    loadPhase(3); // Inicia a luta contra Tarek
                }
            }
            showTarekLine();
        }

        // ===== SISTEMA DE CHECKPOINTS =====
        function saveCheckpoint(checkpointName) {
            gameState.currentCheckpoint = checkpointName;
            
            const checkpointData = {
                name: checkpointName,
                phase: gameState.currentPhase,
                position: { ...gameState.playerPosition },
                health: gameState.playerHealth,
                mana: gameState.playerMana,
                xp: gameState.playerXP,
                level: gameState.playerLevel,
                playerClass: gameState.playerClass,
                playerMaxHealth: gameState.playerMaxHealth,
                playerMaxMana: gameState.playerMaxMana,
                playerDamage: gameState.playerDamage,
                playerSpeed: gameState.playerSpeed,
                abilitiesMaxCooldown: gameState.abilitiesMaxCooldown,
                manaRegenRate: CONFIG.MANA_REGEN_RATE
            };
            
            setCookie('tupary_checkpoint', JSON.stringify(checkpointData));
            showCheckpointNotification('Checkpoint Salvo', `Progresso salvo em: ${getCheckpointDescription(checkpointName)}`);
        }

        function loadCheckpoint() {
            const checkpointData = getCookie('tupary_checkpoint');
            if (checkpointData) {
                try {
                    const data = JSON.parse(checkpointData);
                    
                    gameState.currentPhase = data.phase;
                    gameState.currentCheckpoint = data.name;
                    gameState.playerPosition = { ...data.position };
                    gameState.playerHealth = data.health;
                    gameState.playerMana = data.mana;
                    gameState.playerXP = data.xp;
                    gameState.playerLevel = data.level;
                    gameState.playerClass = data.playerClass;

                    setupCharacter(data.playerClass, data.playerMaxHealth, data.playerMaxMana, data.playerDamage, data.playerSpeed, data.abilitiesMaxCooldown, data.manaRegenRate);
                    
                    loadPhase(data.phase);
                    updateAllUI();
                    return true;
                } catch (e) {
                    console.error('Erro ao carregar checkpoint:', e);
                }
            }
            return false;
        }

        function getCheckpointDescription(checkpointName) {
            const checkpoint = checkpoints.find(cp => cp.name === checkpointName);
            return checkpoint ? checkpoint.description : 'Localização Desconhecida';
        }

        function showCheckpointNotification(title, description) {
            const notification = document.getElementById('checkpoint-notification');
            const titleEl = notification.querySelector('.checkpoint-text');
            const descEl = notification.querySelector('.checkpoint-description');
            
            titleEl.textContent = title;
            descEl.textContent = description;
            
            notification.style.display = 'block';
            notification.style.animation = 'checkpointPulse 2s ease-in-out';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }

        function restartFromCheckpoint() {
            togglePause();
            
            if (loadCheckpoint()) {
                showCheckpointNotification('Checkpoint Carregado', 'Retornando ao último checkpoint salvo...');
            } else {
                loadPhase(gameState.currentPhase);
                gameState.playerHealth = gameState.playerMaxHealth;
                gameState.playerMana = gameState.playerMaxMana;
                updateAllUI();
            }
        }

        // ===== LOOP PRINCIPAL DO JOGO =====
        function gameLoop(timestamp) {
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            deltaTime = Math.min(deltaTime, CONFIG.DELTA_TIME_CAP);
            
            if (!gameState.gamePaused && gameState.gameStarted) {
                if (!gameState.inCutscene && !gameState.inDialog) {
                    update(deltaTime);
                }
                render();
            } else if (gameState.inMenu) {
                renderMenu();
            } else { // Jogo pausado, mas não no menu
                render(); // Continua renderizando a cena pausada
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            updatePlayer(deltaTime);
            updateEnemies(deltaTime);
            updateAbilityEffects(deltaTime);
            updateParticles(deltaTime);
            updateDamageNumbers(deltaTime);
            updateCooldowns(deltaTime);
            updateRegeneration(deltaTime);
            updateCamera(deltaTime);
            updateFallingSpikes(deltaTime);
            
            if (gameState.currentPhase === 1) {
                checkCheckpoints();
            }
            
            checkGameConditions();
        }

        function updatePlayer(deltaTime) {
            let moveX = 0;
            if (keys['a'] || keys['arrowleft'] || mobileControls.left) moveX = -1;
            if (keys['d'] || keys['arrowright'] || mobileControls.right) moveX = 1;
            
            let currentSpeed = gameState.playerSpeed;
            if (gameState.isUmbraFurious) { // Verifica se é a Fúria de Umbra
                currentSpeed *= CONFIG.UMBRA_FURY_SPEED_BOOST;
                gameState.umbraFuryTimer -= deltaTime;
                if (gameState.umbraFuryTimer <= 0) {
                    gameState.isUmbraFurious = false;
                }
            }

            gameState.playerVelocity.x = moveX * currentSpeed;
            
            if ((keys['w'] || keys['arrowup'] || keys[' '] || mobileControls.up) && gameState.isGrounded && !gameState.isCrouching) {
                gameState.playerVelocity.y = -CONFIG.JUMP_FORCE;
                gameState.isGrounded = false;
                playSound('sfx_jump');
                addParticles('jumpDust', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT, 8);
                
                keys['w'] = false; keys['arrowup'] = false; keys[' '] = false; mobileControls.up = false;
            }
            
            if (keys['s'] || keys['arrowdown'] || mobileControls.down) {
                if (!gameState.isCrouching && gameState.isGrounded) {
                    gameState.isCrouching = true;
                    // Ajusta a posição Y ao agachar para manter a parte inferior do sprite no chão
                    gameState.playerPosition.y += CONFIG.NORMAL_HEIGHT - CONFIG.CROUCH_HEIGHT;
                }
            } else {
                if (gameState.isCrouching) {
                    // Previne que o jogador levante se houver algo acima
                    const newY = gameState.playerPosition.y - (CONFIG.NORMAL_HEIGHT - CONFIG.CROUCH_HEIGHT);
                    if (canStandUp(gameState.playerPosition.x, newY)) {
                        gameState.isCrouching = false;
                        gameState.playerPosition.y = newY;
                    }
                }
            }
            
            gameState.playerVelocity.y += CONFIG.GRAVITY;
            
            if (gameState.playerVelocity.y > 15) { // Cap de velocidade de queda
                gameState.playerVelocity.y = 15;
            }
            
            gameState.playerPosition.x += gameState.playerVelocity.x;
            gameState.playerPosition.y += gameState.playerVelocity.y;
            
            checkPlatformCollisions();
            checkEnemyCollisions();
            checkEffectCollisions();
            checkFallingSpikeCollisions();
            
            // Controle do timer de animação de ataque
            if (gameState.animationFrameTimer > 0) {
                gameState.animationFrameTimer -= deltaTime;
                if (gameState.animationFrameTimer <= 0) {
                    gameState.animationFrameTimer = 0;
                    gameState.currentAnimation = 'idle'; // Volta para idle após animação de ataque
                }
            } else {
                updatePlayerAnimation(); // Atualiza animação normal (idle, walk, jump)
            }
            
            if (moveX > 0) gameState.facing = 'right';
            if (moveX < 0) gameState.facing = 'left';
            
            if (!gameState.fixedCamera) {
                if (gameState.playerPosition.x < 0) {
                    gameState.playerPosition.x = 0;
                    gameState.playerVelocity.x = 0;
                }
                if (gameState.playerPosition.x > CONFIG.WORLD_WIDTH - CONFIG.PLAYER_SPRITE_WIDTH) {
                    gameState.playerPosition.x = CONFIG.WORLD_WIDTH - CONFIG.PLAYER_SPRITE_WIDTH;
                    gameState.playerVelocity.x = 0;
                    
                    if (gameState.currentPhase === 1) { // Transição para encontro com Tarek
                        loadPhase(2);
                    }
                }
            } else { // Câmera fixa (e.g., boss fight)
                if (gameState.playerPosition.x < 0) gameState.playerPosition.x = 0;
                if (gameState.playerPosition.x > canvas.width - CONFIG.PLAYER_SPRITE_WIDTH) gameState.playerPosition.x = canvas.width - CONFIG.PLAYER_SPRITE_WIDTH;
            }

            // Queda fatal
            if (gameState.playerPosition.y > CONFIG.WORLD_HEIGHT + 100) {
                takeDamage(gameState.playerMaxHealth); // Dano letal
            }
            
            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= deltaTime;
                if (gameState.invincibilityTimer <= 0) {
                    gameState.isInvincible = false;
                }
            }
        }

        // Retorna a hitbox ajustada do jogador
        function getPlayerHitbox() {
            const playerWidth = CONFIG.PLAYER_SPRITE_WIDTH;
            const playerHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
            
            const hitboxWidth = playerWidth * CONFIG.PLAYER_HITBOX_SCALE_X;
            const hitboxHeight = playerHeight * CONFIG.PLAYER_HITBOX_SCALE_Y;
            
            const hitboxX = gameState.playerPosition.x + (playerWidth - hitboxWidth) / 2;
            const hitboxY = gameState.playerPosition.y + (playerHeight - hitboxHeight); // Ajuste para parte inferior do sprite
            
            return { x: hitboxX, y: hitboxY, width: hitboxWidth, height: hitboxHeight };
        }

        function canStandUp(x, y) {
            const tempPlayerHeight = CONFIG.NORMAL_HEIGHT; // Altura se o jogador levantar
            const tempHitboxWidth = CONFIG.PLAYER_SPRITE_WIDTH * CONFIG.PLAYER_HITBOX_SCALE_X;
            const tempHitboxHeight = tempPlayerHeight * CONFIG.PLAYER_HITBOX_SCALE_Y;
            const tempHitboxX = x + (CONFIG.PLAYER_SPRITE_WIDTH - tempHitboxWidth) / 2;
            const tempHitboxY = y + (tempPlayerHeight - tempHitboxHeight);
            
            for (const platform of platforms) {
                if (platform.type === 'spike') continue; // Espinhos não bloqueiam o levantar
                
                if (tempHitboxX < platform.x + platform.width &&
                    tempHitboxX + tempHitboxWidth > platform.x &&
                    tempHitboxY < platform.y + platform.height &&
                    tempHitboxY + tempHitboxHeight > platform.y) {
                    return false; // Há uma colisão se ele levantar
                }
            }
            return true; // Não há colisão, pode levantar
        }

        function checkPlatformCollisions() {
            gameState.isGrounded = false;
            const playerHitbox = getPlayerHitbox();
            
            for (const platform of platforms) {
                // Check if hitboxes overlap
                if (playerHitbox.x < platform.x + platform.width &&
                    playerHitbox.x + playerHitbox.width > platform.x &&
                    playerHitbox.y < platform.y + platform.height &&
                    playerHitbox.y + playerHitbox.height > platform.y) {
                    
                    if (platform.type === 'spike') {
                        takeDamage(10);
                        continue; // Não interrompe a colisão normal
                    }

                    // Colisão pelo topo (pouso)
                    if (gameState.playerVelocity.y > 0 && 
                        playerHitbox.y + playerHitbox.height - gameState.playerVelocity.y <= platform.y) {
                        gameState.playerPosition.y = platform.y - playerHitbox.height - (CONFIG.PLAYER_SPRITE_HEIGHT - playerHitbox.height) - 0.1; // Ajuste para posição do sprite + pequena margem
                        gameState.playerVelocity.y = 0;
                        gameState.isGrounded = true;
                        
                        if (gameState.playerVelocity.y > 8) { // Partículas de poeira ao cair pesado
                            addParticles('landDust', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT, 12);
                            screenShake(3, 150);
                        }
                        
                        if (platform.slippery) { // Plataforma escorregadia
                            gameState.playerVelocity.x *= 1.2; // Aumenta o "escorregar"
                        }
                    }
                    // Colisão por baixo (cabeça batendo)
                    else if (gameState.playerVelocity.y < 0 &&
                             playerHitbox.y - gameState.playerVelocity.y >= platform.y + platform.height) {
                        gameState.playerPosition.y = platform.y + platform.height - (CONFIG.PLAYER_SPRITE_HEIGHT - playerHitbox.height); // Ajuste para posição do sprite
                        gameState.playerVelocity.y = 0;
                    }
                    // Colisão lateral
                    else if (gameState.playerVelocity.x !== 0) {
                        if (playerHitbox.x < platform.x) { // Colisão pela esquerda da plataforma
                            gameState.playerPosition.x = platform.x - playerHitbox.width - (CONFIG.PLAYER_SPRITE_WIDTH - playerHitbox.width) - 0.1; // Ajuste para o sprite + pequena margem
                        } else { // Colisão pela direita da plataforma
                            gameState.playerPosition.x = platform.x + platform.width - (CONFIG.PLAYER_SPRITE_WIDTH - playerHitbox.width) + 0.1; // Ajuste para o sprite + pequena margem
                        }
                        gameState.playerVelocity.x = 0;
                    }
                }
            }
        }

        function checkEnemyCollisions() {
            if (gameState.isInvincible) return;
            
            const playerHitbox = getPlayerHitbox();

            for (const enemy of enemies) {
                if (enemy.type === 'boss_dialogue') continue;

                // Definir hitbox do inimigo (usando proporção de sprite)
                const enemySpriteWidth = enemy.type === 'boss' ? 70 : 50;
                const enemySpriteHeight = enemy.type === 'boss' ? 70 : 50;
                const enemyHitboxWidth = enemySpriteWidth * 0.8;
                const enemyHitboxHeight = enemySpriteHeight * 0.9; // Baseado no original, ajuste se necessário
                const enemyHitboxX = enemy.position.x + (enemySpriteWidth - enemyHitboxWidth) / 2;
                const enemyHitboxY = enemy.position.y + (enemySpriteHeight - enemyHitboxHeight);

                // Colisão entre hitboxes
                if (playerHitbox.x < enemyHitboxX + enemyHitboxWidth &&
                    playerHitbox.x + playerHitbox.width > enemyHitboxX &&
                    playerHitbox.y < enemyHitboxY + enemyHitboxHeight &&
                    playerHitbox.y + playerHitbox.height > enemyHitboxY) {
                    
                    takeDamage(enemy.damage);
                    
                    const knockbackForce = 8;
                    const knockDirection = (playerHitbox.x + playerHitbox.width / 2) > (enemyHitboxX + enemyHitboxWidth / 2) ? 1 : -1;
                    gameState.playerVelocity.x = knockDirection * knockbackForce;
                    gameState.playerVelocity.y = -5;
                    
                    break;
                }
            }
        }

        function checkEffectCollisions() {
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                
                // Colisão de efeito do jogador com inimigos
                if (effect.damage && effect.origin === 'player' && effect.active !== false) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (enemy.type === 'boss_dialogue') continue;

                        // Se o efeito já atingiu este inimigo (para efeitos piercing ou area que só acertam uma vez por inimigo)
                        if (effect.hitTargets && effect.hitTargets.includes(enemy)) {
                            continue;
                        }
                        
                        // Hitbox do inimigo
                        const enemySpriteWidth = enemy.type === 'boss' ? 70 : 50;
                        const enemySpriteHeight = enemy.type === 'boss' ? 70 : 50;
                        const enemyHitboxWidth = enemySpriteWidth * 0.8;
                        const enemyHitboxHeight = enemySpriteHeight * 0.9;
                        const enemyHitboxX = enemy.position.x + (enemySpriteWidth - enemyHitboxWidth) / 2;
                        const enemyHitboxY = enemy.position.y + (enemySpriteHeight - enemyHitboxHeight);

                        // Hitbox do efeito
                        const effectHitboxX = effect.x; // Assumimos que x/y do efeito já são sua hitbox
                        const effectHitboxY = effect.y;
                        const effectHitboxWidth = effect.width;
                        const effectHitboxHeight = effect.height;

                        if (effectHitboxX < enemyHitboxX + enemyHitboxWidth &&
                            effectHitboxX + effectHitboxWidth > enemyHitboxX &&
                            effectHitboxY < enemyHitboxY + enemyHitboxHeight &&
                            effectHitboxY + effectHitboxHeight > enemyHitboxY) {
                            
                            enemy.health -= effect.damage;
                            playSound('sfx_damage_enemy');
                            
                            if (effect.hitTargets) {
                                effect.hitTargets.push(enemy); // Adiciona o inimigo aos alvos atingidos
                            }
                            
                            showDamageNumber(effect.damage, enemy.position.x + enemySpriteWidth / 2, enemy.position.y);
                            addParticles('hitSpark', enemy.position.x + enemySpriteWidth / 2, enemy.position.y + enemySpriteHeight / 2, 8);
                            screenShake(2, 100);
                            
                            if (effect.knockback) {
                                const knockDirection = (enemy.position.x + enemySpriteWidth / 2) - (effect.x + effectHitboxWidth / 2) > 0 ? 1 : -1;
                                enemy.position.x += knockDirection * effect.knockback;
                            }

                            if (effect.freezeChance && Math.random() < effect.freezeChance) {
                                enemy.frozen = true;
                                enemy.frozenTimer = 2000;
                            }
                            
                            if (enemy.health <= 0) {
                                gainXP(enemy.xpValue);
                                addParticles('deathExplosion', enemy.position.x + enemySpriteWidth / 2, enemy.position.y + enemySpriteHeight / 2, 20);
                                screenShake(4, 200);
                                enemies.splice(j, 1);
                                
                                if (enemy.type === 'boss') {
                                    defeatBoss(enemy);
                                }
                            }
                            
                            if (!effect.piercing && !effect.areaEffect) {
                                effect.active = false; // Desativa o efeito se não for piercing ou área
                            }
                        }
                    }
                }
                
                // Colisão de efeito do inimigo com o jogador
                if (effect.damage && effect.origin === 'enemy' && !gameState.isInvincible && effect.active !== false) {
                    const playerHitbox = getPlayerHitbox();

                    // Hitbox do efeito
                    const effectHitboxX = effect.x;
                    const effectHitboxY = effect.y;
                    const effectHitboxWidth = effect.width;
                    const effectHitboxHeight = effect.height;

                    if (playerHitbox.x < effectHitboxX + effectHitboxWidth &&
                        playerHitbox.x + playerHitbox.width > effectHitboxX &&
                        playerHitbox.y < effectHitboxY + effectHitboxHeight &&
                        playerHitbox.y + playerHitbox.height > effectHitboxY) {
                        
                        takeDamage(effect.damage);
                        effect.active = false;
                    }
                }
            }
        }

        function updatePlayerAnimation() {
            if (gameState.animationFrameTimer > 0) {
                // Animação de ataque/habilidade está ativa, não mudar
                return; 
            }
            if (gameState.isUmbraFurious) {
                gameState.currentAnimation = 'player_ultimate';
            } else if (!gameState.isGrounded) {
                gameState.currentAnimation = 'player_jump';
            } else if (gameState.isCrouching) {
                gameState.currentAnimation = 'player_crouch';
            } else if (Math.abs(gameState.playerVelocity.x) > 0.1) {
                gameState.currentAnimation = 'player_walk';
            } else {
                gameState.currentAnimation = 'player_idle';
            }
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                if (enemy.type === 'boss_dialogue') {
                     // Inimigo de diálogo, apenas para renderização e posicionamento
                     // O playerCollision (abaixo) move Tarek no encontro
                     if (enemy.name === 'Tarek, o Guerreiro' && gameState.inTarekEncounter) {
                         const targetX = canvas.width - 150;
                         const currentX = enemy.position.x;
                         if (Math.abs(currentX - targetX) > 5) {
                             enemy.position.x += (targetX - currentX) * 0.05 * (deltaTime / 16);
                         } else {
                             enemy.position.x = targetX;
                         }
                     }
                     continue;
                }

                if (enemy.frozen) {
                    enemy.frozenTimer -= deltaTime;
                    if (enemy.frozenTimer <= 0) {
                        enemy.frozen = false;
                    }
                    // Atualiza animação para "congelado" ou para quando descongelar
                    if (enemy.type === 'sentinel') enemy.currentAnimation = 'sentinel_idle';
                    else if (enemy.type === 'boss') enemy.currentAnimation = 'tarek_idle';
                    continue;
                }
                
                // Gerenciamento de animação do inimigo
                if (enemy.animationTimer > 0) {
                    enemy.animationTimer -= deltaTime;
                    if (enemy.animationTimer <= 0) {
                        enemy.animationTimer = 0;
                        if (enemy.type === 'sentinel') enemy.currentAnimation = 'sentinel_idle';
                        else if (enemy.type === 'boss') enemy.currentAnimation = 'tarek_idle';
                    }
                }

                if (enemy.type === 'sentinel') {
                    updateEnemyPatrol(enemy, deltaTime);
                    updateEnemyAI(enemy, deltaTime);
                } else if (enemy.type === 'boss') {
                    updateBossAI(enemy, deltaTime);
                }
                
                enemy.velocity = enemy.velocity || { x: 0, y: 0 };
                enemy.velocity.y += CONFIG.GRAVITY;
                
                enemy.position.x += enemy.velocity.x;
                enemy.position.y += enemy.velocity.y;
                
                checkEnemyPlatformCollisions(enemy);
            }
        }

        function updateEnemyPatrol(enemy, deltaTime) {
            if (!enemy.patrolStartX) {
                enemy.patrolStartX = enemy.position.x;
            }
            
            if (enemy.currentAnimation.includes('attack')) return; // Não patrulha enquanto ataca
            
            enemy.position.x += enemy.speed * enemy.direction * (deltaTime / 16); // Usar deltaTime para movimento
            
            // Verifica se o inimigo chegou ao limite de patrulha
            if (enemy.direction === 1 && enemy.position.x > enemy.patrolStartX + enemy.patrolRange) {
                enemy.direction = -1;
            } else if (enemy.direction === -1 && enemy.position.x < enemy.patrolStartX - enemy.patrolRange) {
                enemy.direction = 1;
            }
            // Atualiza a direção visual do inimigo
            enemy.facing = enemy.direction === 1 ? 'right' : 'left';

            // Define animação de andar se estiver patrulhando
            if (Math.abs(enemy.velocity.x) > 0.1 || enemy.speed > 0) {
                enemy.currentAnimation = 'sentinel_idle'; // Sentinelas podem não ter animação de "andar", usar idle
            }
        }

        function updateEnemyAI(enemy, deltaTime) {
            const playerHitbox = getPlayerHitbox();
            const distanceToPlayer = Math.abs((enemy.position.x + 25) - (playerHitbox.x + playerHitbox.width / 2));
            const playerInRange = distanceToPlayer < 200;
            
            if (playerInRange) {
                enemy.attackCooldown = (enemy.attackCooldown || 0) - deltaTime;
                if (enemy.attackCooldown <= 0) {
                    enemyAttack(enemy);
                    enemy.attackCooldown = 2000 + Math.random() * 1000;
                    enemy.animationTimer = enemy.animationDuration; // Reinicia o timer da animação de ataque
                }
                
                // Persegue o jogador se estiver longe o suficiente para atacar
                if (distanceToPlayer > 60) {
                    const directionToPlayer = (playerHitbox.x + playerHitbox.width / 2) > (enemy.position.x + 25) ? 1 : -1;
                    enemy.position.x += directionToPlayer * enemy.speed * 0.5 * (deltaTime / 16);
                }
                enemy.facing = (playerHitbox.x + playerHitbox.width / 2) > (enemy.position.x + 25) ? 'right' : 'left';
            }
        }

        function enemyAttack(enemy) {
            const direction = enemy.facing === 'right' ? 1 : -1;
            
            switch(enemy.type) {
                case 'sentinel':
                    enemy.currentAnimation = 'sentinel_attack'; // Define animação de ataque
                    addAbilityEffect({
                        type: 'enemyIceShot',
                        x: enemy.position.x + (direction > 0 ? 50 : -25),
                        y: enemy.position.y + 15,
                        width: 20,
                        height: 6,
                        duration: 2000,
                        damage: enemy.damage,
                        direction: direction,
                        speed: 5,
                        origin: 'enemy',
                        asset: 'tarek_ice_orb' // Reutiliza asset do orbe de gelo
                    });
                    addParticles('enemyMuzzle', enemy.position.x + 25, enemy.position.y + 15, 6);
                    break;
            }
        }

        function checkEnemyPlatformCollisions(enemy) {
            enemy.isGrounded = false;
            const enemyWidth = enemy.type === 'boss' ? 70 : 50;
            const enemyHeight = enemy.type === 'boss' ? 70 : 50;
            const enemyHitboxWidth = enemyWidth * 0.8;
            const enemyHitboxHeight = enemyHeight * 0.9;
            const enemyHitboxX = enemy.position.x + (enemyWidth - enemyHitboxWidth) / 2;
            const enemyHitboxY = enemy.position.y + (enemyHeight - enemyHitboxHeight);
            
            for (const platform of platforms) {
                if (platform.type === 'spike') continue;

                if (enemyHitboxX < platform.x + platform.width &&
                    enemyHitboxX + enemyHitboxWidth > platform.x &&
                    enemyHitboxY < platform.y + platform.height &&
                    enemyHitboxY + enemyHitboxHeight > platform.y) {
                    
                    if (enemy.velocity.y > 0 && 
                        enemyHitboxY + enemyHitboxHeight - enemy.velocity.y <= platform.y) {
                        enemy.position.y = platform.y - enemyHitboxHeight - (enemyHeight - enemyHitboxHeight) - 0.1; // Ajuste para o sprite + margem
                        enemy.velocity.y = 0;
                        enemy.isGrounded = true;
                    }
                    else if (enemy.velocity.y < 0 &&
                             enemyHitboxY - enemy.velocity.y >= platform.y + platform.height) {
                        enemy.position.y = platform.y + platform.height - (enemyHeight - enemyHitboxHeight);
                        enemy.velocity.y = 0;
                    }
                    else if (enemy.velocity.x !== 0) {
                        if (enemyHitboxX < platform.x) {
                            enemy.position.x = platform.x - enemyHitboxWidth - (enemyWidth - enemyHitboxWidth) - 0.1;
                        } else {
                            enemy.position.x = platform.x + platform.width - (enemyWidth - enemyHitboxWidth) + 0.1;
                        }
                        enemy.velocity.x = 0;
                        // Inverter direção se bater em parede durante patrulha
                        if (enemy.type === 'sentinel') enemy.direction *= -1;
                    }
                }
            }
        }

        function updateAbilityEffects(deltaTime) {
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                effect.timer -= deltaTime;
                
                switch(effect.type) {
                    case 'energyProjectile':
                    case 'enemyIceShot':
                    case 'bossIceOrb':
                        effect.x += effect.speed * effect.direction * (deltaTime / 16);
                        if (Math.random() < 0.4) {
                            let trailColor;
                            if (effect.type === 'bossIceOrb') trailColor = COLOR_ACCENT_ICE;
                            else trailColor = COLOR_ACCENT_BLUE; // Player projectile
                            addParticles('projectileTrail', effect.x + effect.width/2, effect.y + effect.height/2, 2, trailColor);
                        }
                        break;
                    case 'bossDash':
                        if (effect.followBoss && effect.followBoss.position) {
                            effect.x = effect.followBoss.position.x;
                            effect.y = effect.followBoss.position.y;
                        }
                        break;
                    case 'bossPrison':
                        if (effect.delay && effect.delay > 0) {
                            effect.delay -= deltaTime;
                            if (effect.delay <= 0) {
                                effect.active = true;
                                addParticles('prisonActivate', effect.x + effect.width/2, effect.y + effect.height/2, 20);
                            }
                        }
                        if (effect.trapping && effect.active) {
                            const playerHitbox = getPlayerHitbox();
                            const playerInTrap = 
                                playerHitbox.x < effect.x + effect.width && playerHitbox.x + playerHitbox.width > effect.x &&
                                playerHitbox.y < effect.y + effect.height && playerHitbox.y + playerHitbox.height > effect.y;
                            
                            if (playerInTrap) {
                                gameState.playerVelocity.x *= 0.1; // Reduz movimento
                                gameState.playerVelocity.y *= 0.1;
                                
                                if (Math.random() < 0.05) { // Dano periódico
                                    takeDamage(effect.damage * (deltaTime / 1000));
                                }
                            }
                        }
                        break;
                    case 'chargeAttack': // Investida do Escolhido
                        // O dano é aplicado na colisão com checkEffectCollisions, aqui apenas partículas
                        addParticles('dashEffect', effect.x + effect.width / 2, effect.y + effect.height / 2, 5);
                        break;
                }
                
                if (effect.timer <= 0 || effect.active === false) {
                    abilityEffects.splice(i, 1);
                }
            }
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.x += particle.vx * (deltaTime / 16);
                particle.y += particle.vy * (deltaTime / 16);
                
                if (particle.gravity) {
                    particle.vy += CONFIG.GRAVITY * 0.3;
                }
                
                particle.life -= deltaTime;
                
                if (particle.life < particle.maxLife * 0.3) {
                    particle.alpha = particle.life / (particle.maxLife * 0.3);
                }
            }
            /* Remove partículas mortas e limita o número total de partículas */
            particles = particles.filter(p => p.life > 0);
            if (particles.length > CONFIG.MAX_PARTICLES) {
                particles.splice(0, particles.length - CONFIG.MAX_PARTICLES); /* Remove as partículas mais antigas */
            }
            
            if (!gameState.inMenu && !gameState.gamePaused) {
                if (Math.random() < CONFIG.SNOW_SPAWN_RATE) {
                    // Adiciona partículas de neve em relação à câmera
                    addParticles('snow', gameState.cameraOffset.x + Math.random() * canvas.width, -10 + gameState.cameraOffset.y, 1);
                }
            }
        }

        function updateDamageNumbers(deltaTime) {
            const damageContainer = document.getElementById('particle-container');
            const existingNumbers = damageContainer.querySelectorAll('.damage-number, .xp-number');
            
            existingNumbers.forEach(number => {
                const timeLeft = parseFloat(number.dataset.timeLeft) - deltaTime;
                number.dataset.timeLeft = timeLeft;
                
                if (timeLeft <= 0) {
                    number.remove();
                }
            });
        }

        function updateCooldowns(deltaTime) {
            for (const key in gameState.abilitiesCooldown) {
                if (gameState.abilitiesCooldown[key] > 0) {
                    gameState.abilitiesCooldown[key] -= deltaTime / 1000;
                    updateCooldownVisual(key);
                }
            }
        }

        function updateCooldownVisual(key) {
            const btn = document.getElementById(`ability-${key.toLowerCase()}`);
            const overlay = btn?.querySelector('.cooldown-overlay');
            
            if (btn && overlay) {
                const cooldownRatio = gameState.abilitiesCooldown[key] / gameState.abilitiesMaxCooldown[key];
                
                if (cooldownRatio > 0) {
                    btn.classList.add('cooldown');
                    const angle = 360 * (1 - cooldownRatio);
                    overlay.style.background = `conic-gradient(from 0deg, transparent ${angle}deg, rgba(0, 0, 0, 0.8) ${angle}deg)`;
                } else {
                    btn.classList.remove('cooldown');
                    overlay.style.background = '';
                }
            }
        }

        function updateRegeneration(deltaTime) {
            if (gameState.playerMana < gameState.playerMaxMana) {
                gameState.playerMana += CONFIG.MANA_REGEN_RATE * (deltaTime / 1000);
                gameState.playerMana = Math.min(gameState.playerMana, gameState.playerMaxMana);
                updateManaBar();
            }
            
            if (gameState.playerHealth < gameState.playerMaxHealth && !gameState.isInvincible) {
                gameState.playerHealth += CONFIG.HEALTH_REGEN_RATE * (deltaTime / 1000);
                gameState.playerHealth = Math.min(gameState.playerHealth, gameState.playerMaxHealth);
                updateHealthBar();
            }
        }

        function updateCamera(deltaTime) {
            if (gameState.fixedCamera) {
                gameState.cameraOffset.x = gameState.fixedCameraTarget.x;
                gameState.cameraOffset.y = gameState.fixedCameraTarget.y;
                return;
            }

            gameState.targetCameraOffset.x = gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2 - canvas.width / 2;
            gameState.targetCameraOffset.y = gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2 - canvas.height / 2;
            
            // Limita a câmera aos limites do mundo
            gameState.targetCameraOffset.x = Math.max(0, Math.min(gameState.targetCameraOffset.x, CONFIG.WORLD_WIDTH - canvas.width));
            gameState.targetCameraOffset.y = Math.max(0, Math.min(gameState.targetCameraOffset.y, CONFIG.WORLD_HEIGHT - canvas.height)); // Ajuste Y para não ir abaixo do chão

            // Suavização da câmera
            gameState.cameraOffset.x += (gameState.targetCameraOffset.x - gameState.cameraOffset.x) * CONFIG.CAMERA_SMOOTHING;
            gameState.cameraOffset.y += (gameState.targetCameraOffset.y - gameState.cameraOffset.y) * CONFIG.CAMERA_SMOOTHING;
        }

        function updateFallingSpikes(deltaTime) {
            for (let i = fallingSpikes.length - 1; i >= 0; i--) {
                const spike = fallingSpikes[i];
                
                if (!spike.active && 
                    gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH > spike.x - 100 && 
                    gameState.playerPosition.x < spike.x + spike.width + 100 &&
                    gameState.playerPosition.y < spike.y) { // Ativa quando o jogador está abaixo do espinho
                    spike.active = true;
                }
                
                if (spike.active) {
                    spike.y += spike.speed * (deltaTime / 16); // Movimento com deltaTime
                    
                    if (spike.y > CONFIG.WORLD_HEIGHT + 100) { // Remove se cair muito
                        fallingSpikes.splice(i, 1);
                    }
                }
            }
        }

        function checkFallingSpikeCollisions() {
            if (gameState.isInvincible) return;
            
            const playerHitbox = getPlayerHitbox();
            
            for (const spike of fallingSpikes) {
                if (!spike.active) continue;
                
                // Colisão entre hitbox do jogador e espinho
                if (playerHitbox.x < spike.x + spike.width &&
                    playerHitbox.x + playerHitbox.width > spike.x &&
                    playerHitbox.y < spike.y + spike.height &&
                    playerHitbox.y + playerHitbox.height > spike.y) {
                    
                    takeDamage(15);
                    addParticles('hitSpark', spike.x + spike.width/2, spike.y + spike.height/2, 10);
                    break; // Atingido por um espinho
                }
            }
        }

        function checkCheckpoints() {
            const playerHitbox = getPlayerHitbox();
            
            for (const checkpoint of checkpoints) {
                if (playerHitbox.x < checkpoint.x + checkpoint.width &&
                    playerHitbox.x + playerHitbox.width > checkpoint.x &&
                    playerHitbox.y < checkpoint.y + checkpoint.height &&
                    playerHitbox.y + playerHitbox.height > checkpoint.y) {
                    
                    if (gameState.currentCheckpoint !== checkpoint.name) {
                        saveCheckpoint(checkpoint.name);
                    }
                    break;
                }
            }
        }

        function checkGameConditions() {
            if (gameState.playerHealth <= 0) {
                gameOver();
            }
        }

        // ===== SISTEMA DE HABILIDADES =====
        function useAbility(key) {
            const ability = gameState.chosenOneAbilities.find(a => a.key === key);
            if (!ability || gameState.abilitiesCooldown[key] > 0) return;
            
            if (gameState.playerMana < ability.manaCost) {
                flashScreen(COLOR_MANA, 200);
                return;
            }
            
            gameState.playerMana -= ability.manaCost;
            gameState.abilitiesCooldown[key] = ability.cooldown;

            // Ativa a animação de ataque do jogador
            gameState.currentAnimation = ability.animation;
            gameState.animationFrameTimer = gameState.animationDuration; // Define a duração da animação de ataque

            // Se for Ultimate, ajusta a duração da animação para um tempo mais longo
            if (key === 'P') {
                gameState.animationFrameTimer = CONFIG.UMBRA_FURY_DURATION;
            }

            // Executa a lógica da habilidade
            ability.execute();
            updateManaBar();
        }

        function addAbilityEffect(effect) {
            effect.timer = effect.duration || 1000;
            effect.origin = effect.origin || 'player';
            effect.active = effect.active !== false;
            effect.hitTargets = effect.hitTargets || [];
            
            abilityEffects.push(effect);
        }

        // ===== SISTEMA DE PARTÍCULAS =====
        function addParticles(type, x, y, count, color = null) {
            for (let i = 0; i < count; i++) {
                const particle = createParticle(type, x, y, color);
                particles.push(particle);
            }
        }

        function createParticle(type, x, y, customColor = null) {
            const baseParticle = {
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                size: 2 + Math.random() * 3,
                alpha: 1,
                gravity: false,
                type: type,
                asset: null // Pode ter um asset de imagem
            };
            
            switch(type) {
                case 'snow':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: 1 + Math.random() * 2,
                        size: 2 + Math.random() * 4,
                        color: customColor || '#ffffff',
                        life: 8000 + Math.random() * 4000,
                        maxLife: 12000
                    };
                case 'jumpDust':
                case 'landDust':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -1 - Math.random() * 2,
                        color: customColor || '#aaaaaa',
                        life: 400 + Math.random() * 200,
                        maxLife: 600,
                        gravity: true
                    };
                case 'hitSpark':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        color: customColor || '#ffff00',
                        life: 300 + Math.random() * 200,
                        maxLife: 500
                    };
                case 'deathExplosion':
                case 'explosion':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: customColor || (Math.random() > 0.5 ? COLOR_ACCENT_FIRE : COLOR_ACCENT_GOLD),
                        life: 800 + Math.random() * 400,
                        maxLife: 1200,
                        size: 3 + Math.random() * 5,
                        asset: 'explosion_general' // Asset para explosões
                    };
                case 'projectileTrail':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        color: customColor || COLOR_ACCENT_BLUE,
                        life: 300 + Math.random() * 200,
                        maxLife: 500,
                        size: 1 + Math.random() * 2
                    };
                case 'umbraFuria':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        color: customColor || COLOR_ACCENT_GOLD,
                        life: 500 + Math.random() * 300,
                        maxLife: 800,
                        size: 3 + Math.random() * 4,
                        gravity: false
                    };
                case 'bossIntro':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        color: customColor || COLOR_ACCENT_FIRE,
                        life: 1000 + Math.random() * 500,
                        maxLife: 1500,
                        size: 4 + Math.random() * 6
                    };
                case 'dashEffect': // Partículas para a Investida do Escolhido
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 4,
                        color: customColor || COLOR_ACCENT_ICE,
                        life: 400 + Math.random() * 300,
                        maxLife: 700
                    };
                default:
                    return { ...baseParticle, color: customColor || '#ffffff', life: 500, maxLife: 500 };
            }
        }

        // ===== SISTEMA DE DANO E COMBATE =====
        function takeDamage(amount) {
            if (gameState.isInvincible) return;
            
            let finalDamage = amount;
            if (gameState.isUmbraFurious) { // Bônus de defesa da Fúria de Umbra
                finalDamage *= CONFIG.UMBRA_FURY_DAMAGE_REDUCTION;
            }

            gameState.playerHealth -= finalDamage;
            gameState.playerHealth = Math.max(0, gameState.playerHealth);
            
            playSound('sfx_damage_player');
            
            gameState.isInvincible = true;
            gameState.invincibilityTimer = CONFIG.INVINCIBILITY_DURATION;
            
            flashScreen(COLOR_HEALTH, CONFIG.DAMAGE_FLASH_DURATION);
            screenShake(5, 300);
            showDamageNumber(finalDamage, gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y, true);
            
            updateHealthBar();
            
            if (gameState.playerHealth <= 0) {
                gameOver();
            }
        }

        function showDamageNumber(damage, x, y, isPlayerDamage = false) {
            const damageContainer = document.getElementById('particle-container');
            const damageNumber = document.createElement('div');
            
            damageNumber.className = isPlayerDamage ? 'damage-number' : 'damage-number';
            damageNumber.textContent = Math.round(damage);
            damageNumber.style.left = (x - gameState.cameraOffset.x) + 'px';
            damageNumber.style.top = (y - gameState.cameraOffset.y) + 'px';
            damageNumber.style.color = isPlayerDamage ? COLOR_HEALTH : COLOR_TEXT_LIGHT;
            damageNumber.dataset.timeLeft = '1000';
            
            damageContainer.appendChild(damageNumber);
        }

        function gainXP(amount) {
            gameState.playerXP += amount;
            
            const xpContainer = document.getElementById('particle-container');
            const xpNumber = document.createElement('div');
            xpNumber.className = 'xp-number';
            xpNumber.textContent = `+${amount} XP`;
            xpNumber.style.left = (gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2 - gameState.cameraOffset.x) + 'px';
            xpNumber.style.top = (gameState.playerPosition.y - gameState.cameraOffset.y) + 'px';
            xpNumber.dataset.timeLeft = '1500';
            xpContainer.appendChild(xpNumber);
            
            addParticles('xpGain', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2, 8, COLOR_XP);
            
            if (gameState.playerXP >= gameState.playerNextLevelXP) {
                levelUp();
            }
            
            updateXPBar();
            updatePlayerStats();
        }

        function levelUp() {
            playSound('sfx_level_up');
            gameState.playerLevel++;
            gameState.playerXP -= gameState.playerNextLevelXP;
            gameState.playerNextLevelXP = Math.floor(gameState.playerNextLevelXP * 1.5);
            
            flashScreen(COLOR_XP, 500);
            addParticles('umbraFuria', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2, 30);
            
            showLevelUpMenu();
        }

        function showLevelUpMenu() {
            const levelUpMenu = document.getElementById('level-up');
            levelUpMenu.style.display = 'block';
            levelUpMenu.style.animation = 'levelUpAnimation 0.8s forwards';
            gameState.gamePaused = true;
        }

        function applyUpgrade(upgradeType) {
            switch(upgradeType) {
                case 'health':
                    gameState.playerMaxHealth += 25;
                    gameState.playerHealth = gameState.playerMaxHealth;
                    break;
                case 'mana':
                    gameState.playerMaxMana += 35;
                    gameState.playerMana = gameState.playerMaxMana;
                    CONFIG.MANA_REGEN_RATE *= 1.5;
                    break;
                case 'damage':
                    gameState.playerDamage += 8;
                    break;
                case 'speed':
                    gameState.playerSpeed += 0.8;
                    // Reduz cooldowns em 15%
                    for (const key in gameState.abilitiesMaxCooldown) {
                        gameState.abilitiesMaxCooldown[key] *= 0.85;
                    }
                    break;
            }
            
            document.getElementById('level-up').style.display = 'none';
            gameState.gamePaused = false;
            
            updateAllUI();
            saveProgress();
        }

        // ===== BOSS FIGHT - TAREK =====
        function triggerBossFight() {
            gameState.inBossFight = true;
            gameState.fixedCamera = true;
            
            playSound('sfx_boss_roar');

            const tarek = {
                type: 'boss',
                name: 'Tarek, o Guerreiro',
                position: { x: canvas.width - 150, y: 300 },
                facing: 'left',
                health: 500,
                maxHealth: 500,
                damage: 25,
                speed: 1.5,
                velocity: { x: 0, y: 0 },
                isGrounded: false,
                xpValue: 500,
                currentAnimation: 'tarek_idle', // Animação inicial
                animationTimer: 0,
                animationDuration: 500,
                
                aiState: 'combat',
                aiTimer: 0,
                attackCooldown: 0,
                lastAttack: 0,
                
                abilities: [
                    { name: 'Golpe Devastador', cooldown: 3000, range: 80, damage: 35, animation: 'tarek_ability1' },
                    { name: 'Investida Gélida', cooldown: 6000, range: 300, damage: 45, animation: 'tarek_ability2' },
                    { name: 'Orbe Congelante', cooldown: 5000, range: 400, damage: 30, animation: 'tarek_ability3' },
                    { name: 'Prisão de Gelo', cooldown: 10000, range: 200, damage: 20, animation: 'tarek_ability4' }
                ]
            };
            
            enemies.push(tarek);
            
            document.getElementById('boss-name').style.display = 'block';
            document.getElementById('boss-health-bar').style.display = 'block';
            updateBossHealthBar(tarek);
            
            saveCheckpoint('tarek_fight_start');
            
            screenShake(8, 500);
            flashScreen(COLOR_ACCENT_FIRE, 300);
            addParticles('bossIntro', tarek.position.x + 35, tarek.position.y + 35, 40);
        }

        function updateBossAI(boss, deltaTime) {
            const playerHitbox = getPlayerHitbox();
            const distanceToPlayer = Math.abs((boss.position.x + 35) - (playerHitbox.x + playerHitbox.width / 2));
            const currentTime = Date.now();
            
            const arenaLeft = 50;
            const arenaRight = canvas.width - 120;
            if (boss.position.x < arenaLeft) {
                boss.position.x = arenaLeft;
                boss.velocity.x = 0;
            }
            if (boss.position.x > arenaRight) {
                boss.position.x = arenaRight;
                boss.velocity.x = 0;
            }
            
            if (boss.health < boss.maxHealth * 0.4 && !boss.enraged) {
                boss.enraged = true;
                boss.speed *= 1.3;
                boss.damage *= 1.1;
                boss.abilities.forEach(ab => ab.cooldown *= 0.8);

                flashScreen(COLOR_ACCENT_FIRE, 500);
                addParticles('bossIntro', boss.position.x + 35, boss.position.y + 35, 50);

                showDialog("TAREK", "Você... é mais forte do que pensei! Mas não vou cair facilmente!", []);
            }
            
            boss.abilities.forEach(ability => {
                if (currentTime - (ability.lastUsed || 0) < ability.cooldown) {
                    ability.ready = false;
                } else {
                    ability.ready = true;
                }
            });
            
            boss.aiTimer += deltaTime;
            
            switch(boss.aiState) {
                case 'combat':
                    let chosenAbility = null;
                    // Lógica para escolher a habilidade
                    if (distanceToPlayer < boss.abilities[0].range && boss.abilities[0].ready) {
                        chosenAbility = boss.abilities[0];
                    } else if (distanceToPlayer > 100 && distanceToPlayer < boss.abilities[1].range && boss.abilities[1].ready) {
                        chosenAbility = boss.abilities[1];
                    } else if (distanceToPlayer > 150 && boss.abilities[2].ready) {
                        chosenAbility = boss.abilities[2];
                    } else if (boss.abilities[3].ready && Math.random() < 0.3) {
                        chosenAbility = boss.abilities[3];
                    }
                    
                    if (chosenAbility && boss.aiTimer > 500) {
                        executeBossAbility(boss, chosenAbility);
                        boss.currentAnimation = chosenAbility.animation; // Ativa animação de ataque do Tarek
                        boss.animationTimer = boss.animationDuration; // Duração padrão para animações de ataque
                        boss.aiState = 'attacking';
                        boss.aiTimer = 0;
                    } else {
                        moveBossTowardsPlayer(boss, distanceToPlayer, deltaTime);
                        // Animação de idle/walk enquanto se move
                        if (Math.abs(boss.velocity.x) > 0.1) {
                            boss.currentAnimation = 'tarek_walk';
                        } else {
                            boss.currentAnimation = 'tarek_idle';
                        }
                    }
                    break;
                    
                case 'attacking':
                    if (boss.aiTimer > boss.animationDuration) { // Permite que a animação de ataque termine
                        boss.aiState = 'combat';
                        boss.aiTimer = 0;
                        boss.currentAnimation = 'tarek_idle'; // Volta para idle
                    }
                    break;
            }
            updateBossHealthBar(boss);
        }

        function moveBossTowardsPlayer(boss, distance, deltaTime) {
            const playerHitbox = getPlayerHitbox();
            if (distance > 50) {
                const direction = (playerHitbox.x + playerHitbox.width / 2) > (boss.position.x + 35) ? 1 : -1;
                boss.position.x += direction * boss.speed * (deltaTime / 16);
                boss.facing = direction === 1 ? 'right' : 'left';

                if (gameState.isGrounded && playerHitbox.y < boss.position.y - 50 && boss.isGrounded) {
                    boss.velocity.y = -CONFIG.JUMP_FORCE * 0.8;
                    boss.isGrounded = false;
                    boss.currentAnimation = 'tarek_jump'; // Animação de salto para Tarek
                    boss.animationTimer = boss.animationDuration;
                }
            } else {
                boss.velocity.x = 0;
            }
        }

        function executeBossAbility(boss, ability) {
            const direction = boss.facing === 'right' ? 1 : -1;
            ability.lastUsed = Date.now();
            
            switch(ability.name) {
                case 'Golpe Devastador':
                    addAbilityEffect({
                        type: 'bossSlash',
                        x: boss.position.x + (direction > 0 ? 70 : -50),
                        y: boss.position.y + 10,
                        width: 70,
                        height: 30,
                        duration: 300,
                        damage: ability.damage,
                        origin: 'enemy',
                        knockback: 20
                    });
                    screenShake(6, 300);
                    break;
                case 'Investida Gélida':
                    boss.velocity.x = direction * 10;
                    addAbilityEffect({
                        type: 'bossDash',
                        x: boss.position.x,
                        y: boss.position.y,
                        width: 70,
                        height: 50,
                        duration: 800,
                        damage: ability.damage,
                        origin: 'enemy',
                        followBoss: boss
                    });
                    addParticles('dashEffect', boss.position.x + 35, boss.position.y + 35, 30);
                    screenShake(8, 400);
                    break;
                case 'Orbe Congelante':
                    addAbilityEffect({
                        type: 'bossIceOrb',
                        x: boss.position.x + (direction > 0 ? 80 : -30),
                        y: boss.position.y + 20,
                        width: 40,
                        height: 40,
                        duration: 3000,
                        damage: ability.damage,
                        direction: direction,
                        speed: 4,
                        origin: 'enemy',
                        asset: 'tarek_ice_orb'
                    });
                    break;
                case 'Prisão de Gelo':
                    for (let i = 0; i < 3; i++) {
                        const offsetX = (i - 1) * 80;
                        addAbilityEffect({
                            type: 'bossPrison',
                            x: gameState.playerPosition.x + offsetX - 15,
                            y: gameState.playerPosition.y - 60,
                            width: 30,
                            height: 120,
                            duration: 5000,
                            damage: ability.damage,
                            origin: 'enemy',
                            trapping: true,
                            delay: i * 200,
                            active: false,
                            asset: 'tarek_prison_wall'
                        });
                    }
                    screenShake(5, 600);
                    break;
            }
        }

        function updateBossHealthBar(boss) {
            const healthFill = document.getElementById('boss-health-fill');
            const healthPercentage = (boss.health / boss.maxHealth) * 100;
            healthFill.style.width = healthPercentage + '%';
            
            if (healthPercentage > 60) {
                healthFill.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
            } else if (healthPercentage > 30) {
                healthFill.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, #f44336, #e53935)';
            }
        }

        function defeatBoss(boss) {
            gameState.bossDefeated = true;
            gameState.inBossFight = false;
            
            stopMusic();
            
            document.getElementById('boss-name').style.display = 'none';
            document.getElementById('boss-health-bar').style.display = 'none';
            
            flashScreen(COLOR_ACCENT_GOLD, 800);
            screenShake(10, 1000);
            addParticles('deathExplosion', boss.position.x + 35, boss.position.y + 35, 60); // Usa asset de explosão geral
            
            gainXP(boss.xpValue);
            
            const bossIndex = enemies.indexOf(boss);
            if (bossIndex > -1) {
                enemies.splice(bossIndex, 1);
            }
            
            setTimeout(() => {
                showDialog(
                    "TAREK",
                    `Impressionante, ${gameState.playerName}... Você realmente tem a força de um Escolhido. Pode passar, mas saiba que desafios ainda maiores o aguardam adiante.`,
                    [
                        {
                            text: "Obrigado pela luta honrosa, Tarek.",
                            action: () => {
                                showDialog(
                                    "TAREK",
                                    "Que os ventos gelados guiem seus passos, Escolhido. E que você encontre o que procura antes que seja tarde demais.",
                                    [
                                        {
                                            text: "Continuar jornada",
                                            action: () => {
                                                saveCheckpoint('boss_defeated');
                                                showDialog(
                                                    "NARRAÇÃO",
                                                    "Com Tarek derrotado, o caminho para o interior de Tupãry está aberto. Mas esta é apenas a primeira de muitas provações que aguardam o Escolhido...",
                                                    [
                                                        {
                                                            text: "Fim da Demo (Avance para a Missão 2 em breve)",
                                                            action: () => showVictoryScreen()
                                                        }
                                                    ]
                                                );
                                            }
                                        }
                                    ]
                                );
                            }
                        }
                    ]
                );
            }, 2000);
        }

        // ===== EFEITOS VISUAIS =====
        function screenShake(intensity, duration) {
            if (!gameSettings.screenShake) return;
            const gameContainer = document.getElementById('game-container');
            const originalTransform = gameContainer.style.transform;
            
            const startTime = Date.now();
            
            function shake() {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    const currentIntensity = intensity * (1 - progress);
                    
                    const offsetX = (Math.random() - 0.5) * currentIntensity;
                    const offsetY = (Math.random() - 0.5) * currentIntensity;
                    
                    gameContainer.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                    requestAnimationFrame(shake);
                } else {
                    gameContainer.style.transform = originalTransform;
                }
            }
            
            shake();
        }

        function flashScreen(color, duration) {
            const flash = document.getElementById('screen-flash');
            flash.style.background = color;
            flash.classList.add('active');
            
            setTimeout(() => {
                flash.classList.remove('active');
            }, duration);
        }

        // ===== RENDERIZAÇÃO =====
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            renderBackground();
            renderPlatforms();
            renderFallingSpikes();
            renderAbilityEffects();
            renderEnemies(); // Inimigos antes do player para sobreposição correta
            renderPlayer();
            renderParticles();
            
            if (window.DEBUG_MODE) {
                renderDebugInfo();
            }
        }

        function renderMenu() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--primary-dark'));
            gradient.addColorStop(0.3, getComputedStyle(document.documentElement).getPropertyValue('--primary-medium'));
            gradient.addColorStop(0.7, getComputedStyle(document.documentElement).getPropertyValue('--primary-light'));
            gradient.addColorStop(1, '#2c3e50');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        function renderBackground() {
            // Renderiza o gradiente de fundo básico
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--primary-dark'));
            gradient.addColorStop(0.3, getComputedStyle(document.documentElement).getPropertyValue('--primary-medium'));
            gradient.addColorStop(0.7, getComputedStyle(document.documentElement).getPropertyValue('--primary-light'));
            gradient.addColorStop(1, '#2c3e50');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Renderiza as camadas de parallax com imagens
            backgroundLayers.forEach((layer, index) => {
                const asset = assetCache[layer.asset];
                if (!asset) return;

                const parallaxOffset = (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x) * layer.speed;
                const layerWidth = canvas.width * (1 + layer.speed); // Faz a imagem ser um pouco maior para o parallax
                const layerHeight = canvas.height;

                // Desenha a imagem duas vezes para cobrir o espaço ao rolar
                ctx.globalAlpha = 1; // Alpha pode ser ajustado por camada se necessário
                ctx.drawImage(asset, -parallaxOffset % asset.width, 0, asset.width, asset.height, 0, 0, canvas.width, canvas.height);
                // Desenha a segunda cópia se a primeira não cobrir a tela ou para rolagem infinita
                ctx.drawImage(asset, (-parallaxOffset % asset.width) + asset.width, 0, asset.width, asset.height, 0, 0, canvas.width, canvas.height);

                ctx.globalAlpha = 1; // Reseta o alpha
            });
        }

        function renderPlatforms() {
            for (const platform of platforms) {
                const x = platform.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = platform.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                if (x + platform.width < -50 || x > canvas.width + 50 || 
                    y + platform.height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                const asset = assetCache[platform.asset];
                if (asset) {
                    ctx.drawImage(asset, x, y, platform.width, platform.height);
                } else {
                    // Fallback para cores se o asset não carregar
                    if (platform.type === 'ground' || platform.type === 'platform') {
                        ctx.fillStyle = platform.slippery ? COLOR_ACCENT_ICE : '#3a3a3a';
                        ctx.fillRect(x, y, platform.width, platform.height);
                    } else if (platform.type === 'spike') {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--spike-color');
                        ctx.beginPath();
                        for (let i = 0; i < platform.width; i += 10) {
                            ctx.moveTo(x + i, y + platform.height);
                            ctx.lineTo(x + i + 5, y);
                            ctx.lineTo(x + i + 10, y + platform.height);
                            ctx.fill();
                        }
                        ctx.closePath();
                    }
                }
            }
        }

        function renderFallingSpikes() {
            for (const spike of fallingSpikes) {
                if (!spike.active) continue;
                
                const x = spike.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = spike.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                if (x + spike.width < -50 || x > canvas.width + 50 || 
                    y + spike.height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                const asset = assetCache[spike.asset];
                if (asset) {
                    ctx.drawImage(asset, x, y, spike.width, spike.height);
                } else {
                    // Fallback para cor
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--spike-color');
                    ctx.beginPath();
                    ctx.moveTo(x, y + spike.height);
                    ctx.lineTo(x + spike.width/2, y);
                    ctx.lineTo(x + spike.width, y + spike.height);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        function renderPlayer() {
            const x = gameState.playerPosition.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
            const y = gameState.playerPosition.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
            const width = CONFIG.PLAYER_SPRITE_WIDTH;
            const height = CONFIG.PLAYER_SPRITE_HEIGHT; // Usa altura total do sprite

            // Ajusta a posição Y do sprite para manter a base no chão, considerando a altura total
            const adjustedY = y - CONFIG.PLAYER_SPRITE_OFFSET_Y;
            
            if (x + width < -50 || x > canvas.width + 50 || adjustedY + height < -50 || adjustedY > canvas.height + 50) {
                return;
            }
            
            if (gameState.isInvincible && Math.floor(Date.now() / 100) % 2) {
                ctx.globalAlpha = 0.5; // Efeito de piscar durante invencibilidade
            }
            
            // Seleciona o asset do GIF com base na animação e direção
            const assetKey = `${gameState.currentAnimation}_${gameState.facing}`;
            const playerAsset = assetCache[assetKey];

            if (playerAsset) {
                ctx.drawImage(playerAsset, x, adjustedY, width, height);
            } else {
                // Fallback: Desenha um retângulo branco se o asset não carregar
                ctx.fillStyle = COLOR_PLAYER;
                ctx.fillRect(x, adjustedY, width, height);
            }

            // Opcional: Adiciona um efeito visual para a fúria de Umbra (além do filtro no canvas)
            if (gameState.isUmbraFurious) {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = COLOR_ACCENT_GOLD;
                ctx.fillRect(x, adjustedY, width, height);
            }
            
            ctx.globalAlpha = 1; // Reseta o alpha

            // DEBUG: Desenha a hitbox do jogador
            if (window.DEBUG_MODE) {
                const hitbox = getPlayerHitbox();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                ctx.strokeRect(hitbox.x - gameState.cameraOffset.x, hitbox.y - gameState.cameraOffset.y, hitbox.width, hitbox.height);
            }
        }

        function renderEnemies() {
            for (const enemy of enemies) {
                const enemyWidth = enemy.type === 'boss' || enemy.type === 'boss_dialogue' ? 70 : 50;
                const enemyHeight = enemy.type === 'boss' || enemy.type === 'boss_dialogue' ? 70 : 50;
                
                const x = enemy.position.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = enemy.position.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                if (x + enemyWidth < -50 || x > canvas.width + 50 || y + enemyHeight < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                if (enemy.frozen) {
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = COLOR_ACCENT_ICE;
                    ctx.fillRect(x - 5, y - 5, enemyWidth + 10, enemyHeight + 10); // Efeito visual de congelado
                    ctx.globalAlpha = 1;
                }
                
                let assetKey = `${enemy.currentAnimation}_${enemy.facing}`;
                let enemyAsset = assetCache[assetKey];

                if (!enemyAsset) { // Fallback para idle se animação específica não existir
                    assetKey = `${enemy.type === 'sentinel' ? 'sentinel_idle' : 'tarek_idle'}_${enemy.facing}`;
                    enemyAsset = assetCache[assetKey];
                }

                if (enemyAsset) {
                    ctx.drawImage(enemyAsset, x, y, enemyWidth, enemyHeight);
                } else {
                    // Fallback para cores se o asset não carregar
                    if (enemy.type === 'sentinel') {
                        renderSentinelFallback(enemy, x, y, enemyWidth, enemyHeight);
                    } else if (enemy.type === 'boss' || enemy.type === 'boss_dialogue') {
                        renderBossFallback(enemy, x, y, enemyWidth, enemyHeight);
                    }
                }
                
                // Renderiza barra de vida
                if (enemy.health < enemy.maxHealth && enemy.health > 0 && enemy.type !== 'boss_dialogue') {
                    const barWidth = enemyWidth + 10;
                    const barHeight = 6;
                    const barX = x - 5;
                    const barY = y - 15;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = healthPercent > 0.5 ? '#4caf50' : healthPercent > 0.25 ? '#ff9800' : '#f44336';
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
                
                // Renderiza nome do boss
                if ((enemy.type === 'boss' || enemy.type === 'boss_dialogue') && enemy.name) {
                    ctx.fillStyle = COLOR_TEXT_LIGHT;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(enemy.name, x + enemyWidth/2, y - 25);
                    ctx.textAlign = 'left';
                }

                // DEBUG: Desenha hitbox do inimigo
                if (window.DEBUG_MODE) {
                    const enemyHitboxWidth = enemyWidth * 0.8;
                    const enemyHitboxHeight = enemyHeight * 0.9;
                    const enemyHitboxX = enemy.position.x + (enemyWidth - enemyHitboxWidth) / 2;
                    const enemyHitboxY = enemy.position.y + (enemyHeight - enemyHitboxHeight);
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(enemyHitboxX - gameState.cameraOffset.x, enemyHitboxY - gameState.cameraOffset.y, enemyHitboxWidth, enemyHitboxHeight);
                }
            }
        }

        // Fallback para renderizar Sentinela se o GIF não carregar
        function renderSentinelFallback(enemy, x, y, width, height) {
            ctx.fillStyle = '#78909c';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#cfd8dc';
            ctx.fillRect(x + 10, y + 10, width - 20, height - 20);
            ctx.fillStyle = '#00e5ff';
            ctx.fillRect(x + 15, y + 5, 4, 4);
            ctx.fillRect(x + 31, y + 5, 4, 4);
        }

        // Fallback para renderizar Boss (Tarek) se o GIF não carregar
        function renderBossFallback(enemy, x, y, width, height) {
            if (enemy.enraged) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(x - 5, y - 5, width + 10, height + 10);
            }
            const bossGradient = ctx.createLinearGradient(x, y, x, y + height);
            bossGradient.addColorStop(0, '#a0522d');
            bossGradient.addColorStop(0.5, '#8b4513');
            bossGradient.addColorStop(1, '#692e0e');
            ctx.fillStyle = bossGradient;
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#4a2d1d';
            ctx.fillRect(x + 10, y + 15, width - 20, 20);
            ctx.fillStyle = COLOR_ACCENT_FIRE;
            ctx.fillRect(x + 20, y + 8, 6, 6);
            ctx.fillRect(x + width - 26, y + 8, 6, 6);
        }


        function renderAbilityEffects() {
            for (const effect of abilityEffects) {
                const x = effect.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = effect.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                if (x + effect.width < -50 || x > canvas.width + 50 || 
                    y + effect.height < -50 || y > canvas.height + 50 || !effect.active) {
                    continue;
                }
                
                const effectAsset = assetCache[effect.asset];

                if (effectAsset) {
                    ctx.drawImage(effectAsset, x, y, effect.width, effect.height);
                } else {
                    // Fallback para renderização de cor se o asset não carregar
                    switch(effect.type) {
                        case 'meleeAttack':
                            renderMeleeAttackFallback(effect, x, y);
                            break;
                        case 'energyProjectile':
                            renderEnergyProjectileFallback(effect, x, y);
                            break;
                        case 'arcaneExplosion':
                            renderArcaneExplosionFallback(effect, x, y);
                            break;
                        case 'bossSlash':
                            renderBossSlashFallback(effect, x, y);
                            break;
                        case 'bossIceOrb':
                            renderBossIceOrbFallback(effect, x, y);
                            break;
                        case 'bossPrison':
                            renderBossPrisonFallback(effect, x, y);
                            break;
                        case 'enemyIceShot':
                            renderEnemyIceShotFallback(effect, x, y);
                            break;
                        case 'chargeAttack':
                            renderChargeAttackFallback(effect, x, y);
                            break;
                    }
                }
            }
        }

        // Fallbacks para renderização de efeitos se os assets não carregarem
        function renderMeleeAttackFallback(effect, x, y) {
            const alpha = 1 - (effect.duration - effect.timer) / effect.duration;
            ctx.globalAlpha = alpha * 0.8;
            ctx.fillStyle = COLOR_TEXT_LIGHT;
            ctx.fillRect(x, y, effect.width, effect.height);
            ctx.globalAlpha = 1;
        }

        function renderEnergyProjectileFallback(effect, x, y) {
            ctx.fillStyle = COLOR_ACCENT_BLUE;
            ctx.fillRect(x, y, effect.width, effect.height);
        }

        function renderArcaneExplosionFallback(effect, x, y) {
            const progress = 1 - (effect.timer / effect.duration);            
            const maxRadius = effect.width / 2;
            const currentRadius = maxRadius * progress;
            ctx.globalAlpha = (1 - progress) * 0.7;
            const gradient = ctx.createRadialGradient(
                x + effect.width/2, y + effect.height/2, 0,
                x + effect.width/2, y + effect.height/2, currentRadius
            );
            gradient.addColorStop(0, COLOR_ACCENT_GOLD);
            gradient.addColorStop(0.5, COLOR_ACCENT_GOLD);
            gradient.addColorStop(1, 'rgba(255, 107, 107, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        function renderBossSlashFallback(effect, x, y) {
            const alpha = 1 - (effect.duration - effect.timer) / effect.duration;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = COLOR_ACCENT_FIRE;
            ctx.fillRect(x, y, effect.width, effect.height);
            ctx.globalAlpha = 1;
        }

        function renderBossIceOrbFallback(effect, x, y) {
            ctx.fillStyle = COLOR_ACCENT_ICE;
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, effect.width/2, 0, Math.PI * 2);
            ctx.fill();
        }

        function renderBossPrisonFallback(effect, x, y) {
            ctx.fillStyle = 'rgba(168, 208, 230, 0.7)';
            ctx.fillRect(x, y, effect.width, effect.height);
            ctx.strokeStyle = COLOR_ACCENT_ICE;
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, effect.width, effect.height);
        }

        function renderEnemyIceShotFallback(effect, x, y) {
            ctx.fillStyle = COLOR_ACCENT_ICE;
            ctx.fillRect(x, y, effect.width, effect.height);
        }

        function renderChargeAttackFallback(effect, x, y) {
            const alpha = 1 - (effect.duration - effect.timer) / effect.duration;
            ctx.globalAlpha = alpha * 0.7;
            ctx.fillStyle = COLOR_WARRIOR; // Usando a cor do Guerreiro do Gelo como fallback
            ctx.fillRect(x, y, effect.width, effect.height);
            ctx.globalAlpha = 1;
        }


        function renderParticles() {
            for (const particle of particles) {
                const x = particle.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = particle.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                if (x < -20 || x > canvas.width + 20 || y < -20 || y > canvas.height + 20) {
                    continue;
                }
                
                ctx.globalAlpha = particle.alpha || 1;
                
                const particleAsset = assetCache[particle.asset]; // Tenta usar um asset para a partícula
                if (particleAsset) {
                    ctx.drawImage(particleAsset, x, y, particle.size, particle.size);
                } else {
                    // Fallback para desenho de círculo
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = 1; // Reseta o alpha
        }

        function renderDebugInfo() {
            if (!window.DEBUG_MODE) return;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, canvas.height - 150, 200, 140);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px monospace';
            ctx.fillText(`FPS: ${Math.round(1000 / (Date.now() - lastTime))}`, 15, canvas.height - 130);
            ctx.fillText(`Player: ${Math.round(gameState.playerPosition.x)}, ${Math.round(gameState.playerPosition.y)}`, 15, canvas.height - 115);
            ctx.fillText(`Velocity: ${Math.round(gameState.playerVelocity.x)}, ${Math.round(gameState.playerVelocity.y)}`, 15, canvas.height - 100);
            ctx.fillText(`Camera: ${Math.round(gameState.cameraOffset.x)}, ${Math.round(gameState.cameraOffset.y)}`, 15, canvas.height - 85);
            ctx.fillText(`Enemies: ${enemies.length}`, 15, canvas.height - 70);
            ctx.fillText(`Particles: ${particles.length}`, 15, canvas.height - 55);
            ctx.fillText(`Effects: ${abilityEffects.length}`, 15, canvas.height - 40);
            ctx.fillText(`Grounded: ${gameState.isGrounded}`, 15, canvas.height - 25);
            ctx.fillText(`Animation: ${gameState.currentAnimation}`, 15, canvas.height - 10);
        }

        // ===== ATUALIZAÇÃO DE UI (Otimizada) =====
        function updateAllUI() {
            updateHealthBar();
            updateManaBar();
            updateXPBar();
            updatePlayerStats();
        }

        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            const healthText = document.getElementById('health-text');
            
            const currentHealth = Math.round(gameState.playerHealth);
            const currentMaxHealth = gameState.playerMaxHealth;

            if (currentHealth !== lastPlayerHealth || currentMaxHealth !== healthFill.dataset.maxHealth) {
                const percentage = (currentHealth / currentMaxHealth) * 100;
                healthFill.style.width = percentage + '%';
                healthText.textContent = `${currentHealth}/${currentMaxHealth}`;
                healthFill.dataset.maxHealth = currentMaxHealth; /* Armazena o maxHealth no dataset para comparação futura */
                lastPlayerHealth = currentHealth;
            }
        }

        function updateManaBar() {
            const manaFill = document.getElementById('mana-fill');
            const manaText = document.getElementById('mana-text');
            
            const currentMana = Math.round(gameState.playerMana);
            const currentMaxMana = gameState.playerMaxMana;

            if (currentMana !== lastPlayerMana || currentMaxMana !== manaFill.dataset.maxMana) {
                const percentage = (currentMana / currentMaxMana) * 100;
                manaFill.style.width = percentage + '%';
                manaText.textContent = `${currentMana}/${currentMaxMana}`;
                manaFill.dataset.maxMana = currentMaxMana;
                lastPlayerMana = currentMana;
            }
        }

        function updateXPBar() {
            const xpFill = document.getElementById('xp-fill');
            const xpText = document.getElementById('xp-text');
            
            const currentXP = gameState.playerXP;
            const currentNextLevelXP = gameState.playerNextLevelXP;

            if (currentXP !== lastPlayerXP || currentNextLevelXP !== xpFill.dataset.nextLevelXP) {
                const percentage = (currentXP / currentNextLevelXP) * 100;
                xpFill.style.width = percentage + '%';
                xpText.textContent = `${currentXP}/${currentNextLevelXP}`;
                xpFill.dataset.nextLevelXP = currentNextLevelXP;
                lastPlayerXP = currentXP;
            }
        }

        function updatePlayerStats() {
            const levelEl = document.getElementById('player-level');
            const classEl = document.getElementById('player-class');
            const damageEl = document.getElementById('player-damage');
            
            if (levelEl && gameState.playerLevel !== lastPlayerLevel) {
                levelEl.textContent = gameState.playerLevel;
                lastPlayerLevel = gameState.playerLevel;
            }
            if (classEl && gameState.playerClass !== lastPlayerClass) {
                classEl.textContent = gameState.playerClass === 'chosenOne' ? 'Escolhido' : gameState.playerClass;
                lastPlayerClass = gameState.playerClass;
            }
            if (damageEl && Math.round(gameState.playerDamage) !== lastPlayerDamage) {
                damageEl.textContent = Math.round(gameState.playerDamage);
                lastPlayerDamage = Math.round(gameState.playerDamage);
            }
        }

        // ===== CONTROLE DE JOGO =====
        function togglePause() {
            if (gameState.inMenu || gameState.inCutscene || gameState.inDialog) return;
            
            gameState.gamePaused = !gameState.gamePaused;
            const pauseMenu = document.getElementById('pause-menu');
            
            if (gameState.gamePaused) {
                pauseMenu.style.display = 'flex';
                stopMusic();
            } else {
                pauseMenu.style.display = 'none';
                if (gameState.inBossFight) {
                    playMusic('music_boss_tarek', true);
                } else {
                    playMusic('music_platforming', true);
                }
            }
        }

        function gameOver() {
            gameState.gamePaused = true;
            stopMusic();
            
            flashScreen('rgba(0, 0, 0, 0.8)', 1000);
            
            setTimeout(() => {
                showDialog(
                    "SISTEMA",
                    `${gameState.playerName} foi derrotado... Mas a jornada não termina aqui. O destino de todos os reinos ainda depende de suas escolhas.`,
                    [
                        {
                            text: "Voltar ao último checkpoint",
                            action: () => {
                                restartFromCheckpoint();
                            }
                        },
                        {
                            text: "Reiniciar fase atual",
                            action: () => {
                                loadPhase(gameState.currentPhase);
                                gameState.gamePaused = false;
                            }
                        },
                        {
                            text: "Voltar ao menu principal",
                            action: () => {
                                exitToMenu();
                            }
                        }
                    ]
                );
            }, 1500);
        }

        function showVictoryScreen() {
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            const imageElement = document.getElementById('cinematic-image');
            
            overlay.style.display = 'flex';
            imageElement.src = ''; // Remove imagem da cutscene
            imageElement.style.opacity = '0';
            overlay.classList.remove('with-image');
            
            titleElement.textContent = "VITÓRIA!";
            textElement.innerHTML = `
                <p>Parabéns, ${gameState.playerName}!</p>
                <br>
                <p>Você completou a primeira parte da jornada em Tupãry. Tarek foi derrotado e o caminho para o interior do reino gelado está aberto.</p>
                <br>
                <p>Mas esta é apenas a primeira de muitas provações. O Coração de Gelo ainda aguarda, e Ignys se aproxima...</p>
                <br>
                <p><strong>Estatísticas Finais:</strong></p>
                <p>Nível Alcançado: ${gameState.playerLevel}</p>
                <p>Classe: Escolhido</p>
                <p>XP Total: ${gameState.playerXP}</p>
                <br>
                <p><em>Obrigado por jogar Tupãry: O Reino Congelado!</em></p>
                <p><em>Mais capítulos em breve...</em></p>
            `;
            
            titleElement.style.animation = 'none';
            textElement.style.animation = 'none';
            void titleElement.offsetWidth;
            void textElement.offsetWidth;
            titleElement.style.animation = 'fadeInText 2s forwards';
            textElement.style.animation = 'fadeInText 3s forwards 1s';
            
            const nextBtn = document.getElementById('next-btn');
            nextBtn.textContent = 'Voltar ao Menu';
            nextBtn.onclick = () => {
                setCookie('tupary_save', '', -1);
                setCookie('tupary_checkpoint', '', -1);
                exitToMenu();
            };
        }

        // ===== SISTEMA DE CONFIGURAÇÕES =====
        const gameSettings = {
            volume: 0.7,
            sfxVolume: 0.8,
            musicVolume: 0.6,
            showFPS: false,
            particleQuality: 'high',
            screenShake: true,
            
            load: function() {
                const saved = getCookie('tupary_settings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        Object.assign(this, settings);
                    } catch (e) {
                        console.error('Erro ao carregar configurações:', e);
                    }
                }
            },
            
            save: function() {
                setCookie('tupary_settings', JSON.stringify(this));
            }
        };

        // ===== OTIMIZAÇÕES DE PERFORMANCE =====
        function optimizePerformance() {
            const fps = 1000 / (Date.now() - lastTime);
            
            if (fps < 30) {
                CONFIG.MAX_PARTICLES = Math.max(50, CONFIG.MAX_PARTICLES - 10);
                CONFIG.SNOW_SPAWN_RATE *= 0.8;
            } else if (fps > 55) {
                CONFIG.MAX_PARTICLES = Math.min(200, CONFIG.MAX_PARTICLES + 5);
                CONFIG.SNOW_SPAWN_RATE = Math.min(0.15, CONFIG.SNOW_SPAWN_RATE * 1.1);
            }
        }

        // ===== INICIALIZAÇÃO FINAL =====
        function finalizeInitialization() {
            gameSettings.load();
            
            if (window.location.hash === '#debug') {
                window.DEBUG_MODE = true;
            }
            
            setInterval(optimizePerformance, 5000);
            
            console.log('Tupãry: O Reino Congelado - Inicializado com sucesso!');
        }

        // ===== EVENTOS DE JANELA =====
        window.addEventListener('beforeunload', (e) => {
            if (gameState.gameStarted && !gameState.inMenu) {
                saveProgress();
            }
        });

        window.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.gameStarted && !gameState.inMenu && !gameState.gamePaused) {
                togglePause();
            }
        });

        // ===== INÍCIO DO JOGO =====
        window.addEventListener('DOMContentLoaded', () => {
            init();
            finalizeInitialization();
        });

        // ===== EXPOSIÇÃO GLOBAL PARA DEBUG =====
        if (window.DEBUG_MODE) {
            window.gameState = gameState;
            window.CONFIG = CONFIG;
            window.enemies = enemies;
            window.particles = particles;
            window.abilityEffects = abilityEffects;
            window.platforms = platforms;
            
            window.debugCommands = {
                godMode: () => {
                    gameState.playerMaxHealth = 9999;
                    gameState.playerHealth = 9999;
                    gameState.playerMaxMana = 9999;
                    gameState.playerMana = 9999;
                    updateAllUI();
                },
                
                levelUp: () => {
                    gainXP(gameState.playerNextLevelXP);
                },
                
                teleport: (x, y) => {
                    gameState.playerPosition.x = x || 4800;
                    gameState.playerPosition.y = y || 300;
                },
                
                spawnBoss: () => {
                    loadPhase(3);
                },
                
                clearEnemies: () => {
                    enemies.length = 0;
                },
                
                addParticles: (type, count) => {
                    addParticles(type || 'snow', gameState.playerPosition.x, gameState.playerPosition.y, count || 50);
                }
            };
        }
    </script>
</body>
</html>