<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tupãry: O Reino Congelado</title>
    <style>
        /* ===== VARIÁVEIS CSS ===== */
        :root {
            --primary-dark: #000000;
            --primary-medium: #0a0a0a;
            --primary-light: #1a1a1a;
            --accent-gold: #d4af37;
            --accent-gold-light: #f5d76e;
            --accent-blue: #3a86ff;
            --accent-ice: #90e0ef;
            --accent-fire: #ff6b6b;
            --accent-nature: #52b788;
            --text-light: #f0f0f0;
            --text-gray: #aaaaaa;
            --health-color: var(--accent-fire);
            --mana-color: var(--accent-blue);
            --xp-color: var(--accent-gold);
            --shadow-dark: rgba(0, 0, 0, 0.8);
            --spike-color: #666666;
            --archer-color: #4fc3f7; /* Cor para Atirador Gélido */
            --warrior-color: #66bb6a; /* Cor para Guerreiro do Gelo */
            --player-color: #ffffff; /* Cor base para o Escolhido */
        }

        /* ===== RESET E BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: var(--primary-dark); /* Fundo fixo para não interferir com o canvas */
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* ===== CONTAINER PRINCIPAL DO JOGO ===== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1600px; /* Limite de largura para desktop */
            max-height: 900px; /* Ajustado para permitir mais espaço vertical se necessário */
            overflow: hidden;
            border: 3px solid var(--accent-gold);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
            background: transparent; /* O background do jogo será desenhado no canvas */
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Abaixo da UI */
            background: transparent;
            pointer-events: auto; /* Permite interação com o canvas quando UI não está em cima */
        }

        /* ===== AVISO DE ORIENTAÇÃO MOBILE ===== */
        .orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--primary-dark);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
            pointer-events: auto;
        }

        .orientation-warning h2 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            font-size: 24px;
        }

        .orientation-warning p {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
        }

        .rotate-icon {
            font-size: 48px;
            margin: 20px 0;
            animation: rotatePhone 2s infinite;
        }

        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        /* ===== TELA DE INÍCIO / MENU PRINCIPAL ===== */
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.95) 100%);
            z-index: 50; /* Acima de tudo menos avisos */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            pointer-events: auto; /* Menu recebe cliques */
        }

        .game-title {
            font-size: 42px;
            font-weight: bold;
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 20px;
            color: var(--accent-ice);
            text-align: center;
            margin-bottom: 40px;
            font-style: italic;
        }

        .character-selection {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 700px;
        }

        .character-selection h3 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            text-align: center;
            font-size: 20px;
        }

        .name-input-group {
            margin-bottom: 25px;
            text-align: center;
        }

        .name-input-group label {
            display: block;
            color: var(--text-light);
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 18px;
        }

        .name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--accent-blue);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
            text-align: center;
        }

        .name-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold-light);
        }

        .start-game-btn {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
            pointer-events: auto; /* Botão recebe cliques */
        }

        .start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.5);
        }

        .start-game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            pointer-events: none; /* Desabilitado não recebe cliques */
        }

        /* ===== UI LAYER ===== */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Acima do canvas, abaixo de menus */
            pointer-events: none; /* Permite cliques através da camada, exceto nos elementos interativos */
        }

        /* ===== BARRAS DE STATUS ===== */
        .status-bars {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
        }

        .bar-container {
            width: 200px;
            height: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--text-light);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
        }

        .mana-fill {
            background: linear-gradient(90deg, #4dabf7, #3366ff);
        }

        .xp-fill {
            background: linear-gradient(90deg, var(--accent-gold-light), var(--accent-gold));
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        /* ===== STATS DO JOGADOR ===== */
        .player-stats {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 14px;
            text-align: right;
            min-width: 150px;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-line:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: var(--accent-ice);
            font-weight: bold;
        }

        .stat-value {
            color: var(--accent-gold);
            font-weight: bold;
        }

        /* ===== SISTEMA DE HABILIDADES (Desktop) ===== */
        .abilities-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 12px;
            pointer-events: auto; /* Permite interação com os botões */
        }

        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
            border: 3px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .ability-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        .ability-btn:active {
            transform: scale(0.95);
        }

        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            pointer-events: none; /* Desabilitado não recebe cliques */
        }

        .ability-btn.cooldown:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(0, 0, 0, 0.8) 0deg);
            transition: background 0.1s linear;
        }

        .ability-tooltip {
            position: absolute;
            bottom: 70px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--accent-blue);
            border-radius: 8px;
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none; /* Tooltip não bloqueia cliques atrás */
            width: 200px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .ability-btn:hover .ability-tooltip {
            opacity: 1;
        }

        .tooltip-name {
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip-description {
            color: var(--text-light);
            font-size: 12px;
            line-height: 1.3;
            margin-bottom: 5px;
        }

        .tooltip-cost {
            color: var(--mana-color);
            font-size: 11px;
            font-style: italic;
        }

        /* ===== CONTROLES MOBILE (D-pad e Ações) ===== */
        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 5px;
            pointer-events: auto;
            z-index: 5;
            align-items: center;
        }
        .mobile-dpad {
            grid-column: 1 / 2;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 120px;
            height: 120px;
            position: relative;
            margin-left: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .dpad-btn {
            background: var(--primary-medium);
            border: 2px solid var(--accent-blue);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.1s;
            border-radius: 5px;
            pointer-events: auto;
        }
        .dpad-btn:active {
            background: var(--accent-blue);
            transform: scale(0.95);
        }

        .dpad-up { grid-area: 1 / 2 / 2 / 3; }
        .dpad-left { grid-area: 2 / 1 / 3 / 2; }
        .dpad-center { grid-area: 2 / 2 / 3 / 3; opacity: 0.3; pointer-events: none;}
        .dpad-right { grid-area: 2 / 3 / 3 / 4; }
        .dpad-down { grid-area: 3 / 2 / 4 / 3; }

        .mobile-action-buttons {
            grid-column: 3 / 4;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            position: relative;
            margin-right: 20px;
            justify-self: end;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .mobile-btn:active {
            transform: scale(0.9);
            background: rgba(212, 175, 55, 0.3);
        }

        /* ===== SISTEMA DE DIÁLOGO ===== */
        .dialog-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(10, 10, 10, 0.9));
            border: 3px solid var(--accent-blue);
            border-radius: 15px;
            padding: 20px;
            display: none;
            pointer-events: auto; /* Recebe cliques */
            z-index: 20; /* Acima da UI normal */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .dialog-speaker {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dialog-text {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .dialog-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dialog-option {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(255, 107, 107, 0.2));
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-light);
            font-weight: bold;
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .dialog-option:hover {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4), rgba(255, 107, 107, 0.4));
            transform: translateX(5px);
        }

        .dialog-option:active {
            transform: translateX(5px) scale(0.98);
        }

        /* ===== CUTSCENES ===== */
        .cinematic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            z-index: 30; /* Acima da UI e diálogos */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            overflow: hidden;
            pointer-events: auto; /* Garante que o overlay é interativo */
        }

        .cinematic-overlay.with-image {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(10, 10, 10, 0.8));
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .cinematic-image {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -1; /* Fica atrás do texto */
            opacity: 0.3; /* Transparência para o texto ser visível */
            transition: opacity 1s ease;
        }

        .cinematic-text {
            font-size: 20px;
            text-align: center;
            max-width: 80%;
            margin-bottom: 30px;
            color: var(--text-light);
            line-height: 1.6;
            opacity: 0;
            animation: fadeInText 3s forwards;
            position: relative; /* Para garantir z-index acima da imagem */
        }

        .cinematic-title {
            font-size: 32px;
            color: var(--accent-gold);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            position: relative; /* Para garantir z-index acima da imagem */
        }

        .next-btn { /* Renomeado de skip-btn para next-btn */
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto; /* Garante que o botão é clicável */
            transition: all 0.3s;
            font-weight: bold;
        }

        .next-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
        }

        /* ===== PAUSE MENU ===== */
        .pause-btn {
            position: absolute;
            top: 15px;
            right: 180px;
            z-index: 10; /* Acima da UI normal */
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto; /* Garante que o botão é clicável */
            transition: all 0.3s;
            font-size: 16px;
        }

        .pause-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: scale(1.1);
        }

        .pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 40; /* Acima da UI e cutscenes */
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            pointer-events: auto; /* Garante que o menu é interativo */
        }

        .pause-title {
            font-size: 36px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-option {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 200px;
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .menu-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        /* ===== LEVEL UP (COM ESCOLHAS) ===== */
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            border: 3px solid var(--accent-gold);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            z-index: 35; /* Acima de cutscenes, abaixo do pause menu */
            display: none;
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            pointer-events: auto; /* Garante que o menu é interativo */
        }

        .level-up-title {
            font-size: 28px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .level-up-subtitle {
            font-size: 16px;
            color: var(--text-light);
            margin-bottom: 25px;
        }

        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .upgrade-option {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            pointer-events: auto; /* Garante que o botão é clicável */
        }

        .upgrade-option:hover {
            background: rgba(0, 0, 0, 0.6);
            transform: translateX(5px);
            box-shadow: 0 6px 15px rgba(212, 175, 55, 0.5);
        }

        /* ===== CHECKPOINT SYSTEM ===== */
        .checkpoint-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 25; /* Acima da UI */
            display: none;
            animation: checkpointPulse 2s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            pointer-events: none; /* Notificação não bloqueia cliques */
        }

        @keyframes checkpointPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }

        .checkpoint-text {
            color: var(--accent-blue);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .checkpoint-description {
            color: var(--text-light);
            font-size: 14px;
        }

        /* ===== ANIMAÇÕES GERAIS ===== */
        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes levelUpAnimation {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* ===== EFEITOS ESPECIAIS ===== */
        .screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 15;
            opacity: 0;
            pointer-events: none;
        }

        .screen-flash.active {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .boss-health-bar {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-fire);
            border-radius: 10px;
            display: none;
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5);
            pointer-events: none;
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
            transition: width 0.5s ease;
            position: relative;
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        .boss-name {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--accent-fire);
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 10;
            pointer-events: none;
        }

        /* ===== PARTÍCULAS E NÚMEROS ===== */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .damage-number, .xp-number {
            position: absolute;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
            animation: damageNumber 1s ease-out forwards;
        }
        .damage-number { color: var(--accent-fire); }
        .xp-number { color: var(--xp-color); animation: xpNumber 1.5s ease-out forwards; }

        @keyframes damageNumber {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
        }

        @keyframes xpNumber {
            0% { opacity: 1; transform: translateY(0) scale(0.8); }
            100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
        }

        /* ===== RESPONSIVIDADE ===== */
        @media (max-width: 800px) {
            #game-container {
                width: 100vw;
                height: 100vh;
                max-width: none;
                max-height: none;
                border: none;
                border-radius: 0;
            }

            .main-menu {
                padding: 10px;
            }

            .game-title {
                font-size: 36px;
            }

            .game-subtitle {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .character-selection {
                padding: 15px;
                margin-bottom: 15px;
            }

            .class-selection { /* Não usado, mas mantido para consistência */
                flex-direction: column;
                gap: 15px;
            }

            .class-option { /* Não usado, mas mantido para consistência */
                min-width: unset;
                width: 100%;
                padding: 15px;
            }

            .mobile-controls {
                display: grid;
            }

            .abilities-container {
                display: none; /* Desktop abilities hidden on mobile */
            }

            .status-bars {
                top: 10px;
                left: 10px;
            }

            .bar-container {
                width: 150px;
                height: 12px;
            }

            .player-stats {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 12px;
                min-width: 120px;
            }

            .pause-btn {
                top: 10px;
                right: 140px;
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .dialog-container {
                width: 95%;
                padding: 15px;
                bottom: 15px;
            }

            .dialog-text {
                font-size: 14px;
                min-height: 50px;
            }

            .cinematic-text {
                font-size: 16px;
                max-width: 90%;
            }

            .cinematic-title {
                font-size: 24px;
            }

            .next-btn {
                bottom: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 14px;
            }

            .level-up {
                min-width: 90%;
                padding: 20px;
            }

            .upgrade-option {
                padding: 12px;
            }
        }

        /* Landscape orientation for smaller mobile heights */
        @media (max-height: 500px) and (orientation: landscape) {
            .status-bars {
                top: 5px;
                left: 5px;
            }

            .bar-container {
                width: 120px;
                height: 10px;
            }

            .player-stats {
                top: 5px;
                right: 5px;
                padding: 5px 8px;
                font-size: 10px;
                min-width: 100px;
            }

            .mobile-dpad {
                bottom: 10px;
                left: 10px;
                width: 100px;
                height: 100px;
                margin-left: 10px;
            }

            .mobile-action-buttons {
                bottom: 10px;
                right: 10px;
                margin-right: 10px;
            }

            .mobile-btn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- Aviso de Orientação Mobile -->
    <div class="orientation-warning" id="orientation-warning">
        <div class="rotate-icon">📱</div>
        <h2>Vire o Dispositivo</h2>
        <p>Para uma melhor experiência de jogo, por favor vire seu dispositivo para o modo paisagem (horizontal).</p>
    </div>

    <!-- Container Principal do Jogo -->
    <div id="game-container">
        <!-- Tela de Início / Menu Principal -->
        <div class="main-menu" id="main-menu">
            <h1 class="game-title">TUPÃRY</h1>
            <p class="game-subtitle">O Reino Congelado</p>
            
            <div class="character-selection">
                <h3>Desperte, Escolhido! Diga-me seu nome para que o destino o chame:</h3>
                <div class="name-input-group">
                    <label for="player-name">Nome do Escolhido:</label>
                    <input type="text" id="player-name" class="name-input" placeholder="Seu nome, para que o destino o chame..." maxlength="20">
                </div>
            </div>
            
            <button class="start-game-btn" id="start-game-btn" disabled>Iniciar Jornada</button>
        </div>

        <!-- Canvas do Jogo -->
        <canvas id="game-canvas"></canvas>
        
        <!-- Flash de Tela -->
        <div class="screen-flash" id="screen-flash"></div>
        
        <!-- Container de Partículas -->
        <div class="particle-container" id="particle-container"></div>

        <!-- UI Layer -->
        <div class="ui-layer">
            <!-- Barras de Status -->
            <div class="status-bars">
                <div class="status-bar">
                    <div class="status-icon">❤️</div>
                    <div class="bar-container">
                        <div class="bar-fill health-fill" id="health-fill"></div>
                        <div class="bar-text" id="health-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">💙</div>
                    <div class="bar-container">
                        <div class="bar-fill mana-fill" id="mana-fill"></div>
                        <div class="bar-text" id="mana-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">⭐</div>
                    <div class="bar-container">
                        <div class="bar-fill xp-fill" id="xp-fill"></div>
                        <div class="bar-text" id="xp-text">0/100</div>
                    </div>
                </div>
            </div>
            
            <!-- Stats do Jogador -->
            <div class="player-stats" id="player-stats">
                <div class="stat-line">
                    <span class="stat-label">Nível:</span>
                    <span class="stat-value" id="player-level">1</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Classe:</span>
                    <span class="stat-value" id="player-class">Escolhido</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Dano:</span>
                    <span class="stat-value" id="player-damage">15</span>
                </div>
            </div>
            
            <!-- Barra de Vida do Boss -->
            <div class="boss-name" id="boss-name">TAREK, O GUERREIRO</div>
            <div class="boss-health-bar" id="boss-health-bar">
                <div class="boss-health-fill" id="boss-health-fill"></div>
            </div>
            
            <!-- Habilidades (Desktop) -->
            <div class="abilities-container" id="abilities-container">
                <div class="ability-btn" id="ability-u" data-key="U">
                    U
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-u-name">Soco</div>
                        <div class="tooltip-description" id="tooltip-u-desc">Ataque corpo a corpo rápido.</div>
                        <div class="tooltip-cost" id="tooltip-u-cost">Custo: 0 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-i" data-key="I">
                    I
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-i-name">Disparo</div>
                        <div class="tooltip-description" id="tooltip-i-desc">Lança um projétil negro de energia.</div>
                        <div class="tooltip-cost" id="tooltip-i-cost">Custo: 10 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-o" data-key="O">
                    O
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-o-name">Investida</div>
                        <div class="tooltip-description" id="tooltip-o-desc">Dash rápido que causa dano e concede invulnerabilidade temporária.</div>
                        <div class="tooltip-cost" id="tooltip-o-cost">Custo: 25 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-p" data-key="P">
                    P
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-p-name">Fúria de Umbra</div>
                        <div class="tooltip-description" id="tooltip-p-desc">Canaliza a energia de Umbra para ficar mais rápido, resistente e poderoso.</div>
                        <div class="tooltip-cost" id="tooltip-p-cost">Custo: 50 Mana</div>
                    </div>
                </div>
            </div>
            
            <!-- Botão de Pausa -->
            <div class="pause-btn" id="pause-btn">⏸️</div>
            
            <!-- Controles Mobile (D-pad e Ações) -->
            <div class="mobile-controls" id="mobile-controls">
                <div class="mobile-dpad">
                    <div class="dpad-btn dpad-up" id="mobile-up">▲</div>
                    <div class="dpad-btn dpad-left" id="mobile-left">◀</div>
                    <div class="dpad-btn dpad-center"></div>
                    <div class="dpad-btn dpad-right" id="mobile-right">▶</div>
                    <div class="dpad-btn dpad-down" id="mobile-down">▼</div>
                </div>
                
                <div class="mobile-action-buttons">
                    <div class="mobile-btn" id="mobile-ability-u">U</div>
                    <div class="mobile-btn" id="mobile-ability-i">I</div>
                    <div class="mobile-btn" id="mobile-ability-o">O</div>
                    <div class="mobile-btn" id="mobile-ability-p">P</div>
                </div>
            </div>
            
            <!-- Sistema de Diálogo -->
            <div class="dialog-container" id="dialog-container">
                <div class="dialog-speaker" id="dialog-speaker"></div>
                <div class="dialog-text" id="dialog-text"></div>
                <div class="dialog-options" id="dialog-options"></div>
            </div>
            
            <!-- Overlay de Cutscene -->
            <div class="cinematic-overlay" id="cinematic-overlay">
                <img id="cinematic-image" class="cinematic-image" src="" alt="Cinematic Image">
                <div class="cinematic-title" id="cinematic-title"></div>
                <div class="cinematic-text" id="cinematic-text"></div>
                <button class="next-btn" id="next-btn">Próximo</button>
            </div>
            
            <!-- Menu de Pausa -->
            <div class="pause-menu" id="pause-menu">
                <h2 class="pause-title">JOGO PAUSADO</h2>
                <button class="menu-option" id="resume-btn">Continuar</button>
                <button class="menu-option" id="restart-btn">Reiniciar Checkpoint</button>
                <button class="menu-option" id="save-btn">Salvar Progresso</button>
                <button class="menu-option" id="exit-btn">Voltar ao Menu</button>
            </div>
            
            <!-- Sistema de Level Up (Com Escolhas) -->
            <div class="level-up" id="level-up">
                <h2 class="level-up-title">NÍVEL AUMENTADO!</h2>
                <p class="level-up-subtitle">Escolha uma melhoria para fortalecer seu poder:</p>
                <div class="upgrade-options">
                    <div class="upgrade-option" data-upgrade="health">
                        <div class="upgrade-name">+ Vitalidade Aprimorada</div>
                        <div class="upgrade-description">Aumenta sua vida máxima em 25 pontos e restaura completamente sua saúde.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="mana">
                        <div class="upgrade-name">+ Reserva Mística</div>
                        <div class="upgrade-description">Aumenta sua mana máxima em 35 pontos e acelera a regeneração em 50%.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="damage">
                        <div class="upgrade-name">+ Poder Destrutivo</div>
                        <div class="upgrade-description">Aumenta o dano de todas suas habilidades em 8 pontos permanentemente.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="speed">
                        <div class="upgrade-name">+ Agilidade Gélida</div>
                        <div class="upgrade-description">Aumenta velocidade de movimento em 20% e reduz cooldowns em 15%.</div>
                    </div>
                </div>
            </div>
            
            <!-- Notificação de Checkpoint -->
            <div class="checkpoint-notification" id="checkpoint-notification">
                <div class="checkpoint-text">CHECKPOINT SALVO</div>
                <div class="checkpoint-description">Seu progresso foi salvo automaticamente</div>
            </div>
        </div>
    </div>

    <script>
        // =========================================================
        //  0. CONFIGURAÇÕES GLOBAIS E CAMINHOS DE ASSETS
        // =========================================================
        const CONFIG = {
            // Física do jogo
            GRAVITY: 0.6,
            PLAYER_BASE_SPEED: 4, // Velocidade base do jogador
            JUMP_FORCE: 14,
            CROUCH_HEIGHT: 30, // Altura de agachamento para hitbox
            NORMAL_HEIGHT: 50, // Altura normal para hitbox
            
            // Dimensões VISUAIS do Sprite do Jogador (proporção 2:1, ex: 50px largura, 100px altura)
            PLAYER_SPRITE_WIDTH: 50,
            PLAYER_SPRITE_HEIGHT: 100,
            PLAYER_SPRITE_OFFSET_Y: 0, // Ajuste vertical do sprite em relação ao Y da hitbox (se 0, sprite começa em Y da hitbox)
            
            // Escala da HITBOX em relação ao tamanho VISUAL do sprite (Ex: 80% da largura, 90% da altura do sprite visual)
            PLAYER_HITBOX_SCALE_X: 0.8,
            PLAYER_HITBOX_SCALE_Y: 0.9,
            
            // Mundo
            WORLD_WIDTH: 6000, // Largura total do mundo em pixels
            WORLD_HEIGHT: 450, // Altura vertical máxima (usado para queda fatal)
            CAMERA_SMOOTHING: 0.08, // Suavização da câmera
            
            // Combate
            DAMAGE_FLASH_DURATION: 200,
            INVINCIBILITY_DURATION: 1000,
            
            // Regeneração
            MANA_REGEN_RATE: 1.5,
            HEALTH_REGEN_RATE: 0.05, // Regeneração de vida passiva (por ms)
            
            // Partículas
            MAX_PARTICLES: 200,
            SNOW_SPAWN_RATE: 0.15, // Chance de nevar a cada frame
            
            // Performance
            TARGET_FPS: 60,
            DELTA_TIME_CAP: 32, // Limite para deltaTime para evitar grandes saltos em lag
            
            // Habilidades do Escolhido (Poderes de Umbra para a classe 'chosenOne')
            UMBRA_FURY_DURATION: 7000, // Duração da Ultimate em ms
            UMBRA_FURY_DAMAGE_BOOST: 1.5, // Multiplicador de dano na Ultimate
            UMBRA_FURY_SPEED_BOOST: 1.3, // Multiplicador de velocidade na Ultimate
            UMBRA_FURY_DAMAGE_REDUCTION: 0.5, // Redução de dano recebido na Ultimate (0.5 = 50% menos dano)

            // CAMINHOS DE RECURSOS (GIFs e Áudios)
            // IMPORTANTE: Assumimos que GIFs espelhados têm "_mirrored" no nome.
            // Se você não tiver a versão "_mirrored", o jogo tentará usar a versão original.
            ASSET_PATHS: {
                // Backgrounds (imagens estáticas que serão usadas em renderBackground)
                bg_sky: 'assets/backgrounds/sky.png',
                bg_mountains: 'assets/backgrounds/mountains.png',
                bg_hills: 'assets/backgrounds/hills.png',
                bg_foreground: 'assets/backgrounds/foreground.png',

                // Plataformas (imagens estáticas)
                platform_ground: 'assets/plataformas/plataforma01.png', // Exemplo de imagem para chão/plataforma
                platform_ice: 'assets/plataformas/bloco01.png', // Exemplo para plataforma escorregadia
                platform_spike: 'assets/plataformas/bloco02.png', // Exemplo para espinhos
                
                // Player - Escolhido (GIFs)
                player_idle_right: 'assets/personagens/Escolhido/gifs/escolhido-parado01.gif',
                player_idle_left: 'assets/personagens/Escolhido/gifs/escolhido-parado01_mirrored.gif', // Supondo uma versão espelhada
                player_walk_right: 'assets/personagens/Escolhido/gifs/escolhido-andando01.gif',
                player_walk_left: 'assets/personagens/Escolhido/gifs/escolhido-andando01_mirrored.gif',
                player_jump_right: 'assets/personagens/Escolhido/gifs/escolhido-salto01.gif',
                player_jump_left: 'assets/personagens/Escolhido/gifs/escolhido-salto01_mirrored.gif',
                player_crouch_right: 'assets/personagens/Escolhido/gifs/escolhido-agachar01.gif', // Placeholder, se não tiver, usará o idle
                player_crouch_left: 'assets/personagens/Escolhido/gifs/escolhido-agachar01_mirrored.gif', // Placeholder
                player_attack_u_right: 'assets/personagens/Escolhido/gifs/escolhido-ataqueU01.gif', // Animação de Soco
                player_attack_u_left: 'assets/personagens/Escolhido/gifs/escolhido-ataqueU01_mirrored.gif',
                player_attack_i_right: 'assets/personagens/Escolhido/gifs/escolhido-ataqueI01.gif', // Animação de Disparo
                player_attack_i_left: 'assets/personagens/Escolhido/gifs/escolhido-ataqueI01_mirrored.gif',
                player_attack_o_right: 'assets/personagens/Escolhido/gifs/escolhido-ataqueO01.gif', // Animação de Investida
                player_attack_o_left: 'assets/personagens/Escolhido/gifs/escolhido-ataqueO01_mirrored.gif',
                player_ultimate_right: 'assets/personagens/Escolhido/gifs/escolhido-ultimateP01.gif', // Animação de Ultimate
                player_ultimate_left: 'assets/personagens/Escolhido/gifs/escolhido-ultimateP01_mirrored.gif',

                // Inimigos - Sentinela (GIFs)
                sentinel_idle_right: 'assets/personagens/Sentinelas/gifs/sentinela-parado01.gif',
                sentinel_idle_left: 'assets/personagens/Sentinelas/gifs/sentinela-parado01_mirrored.gif',
                sentinel_attack_right: 'assets/personagens/Sentinelas/gifs/sentinela-ataque01.gif',
                sentinel_attack_left: 'assets/personagens/Sentinelas/gifs/sentinela-ataque01_mirrored.gif',

                // Inimigos - Tarek (GIFs)
                tarek_idle_right: 'assets/personagens/Tarek/gifs/tarek-parado01.gif',
                tarek_idle_left: 'assets/personagens/Tarek/gifs/tarek-parado01_mirrored.gif',
                tarek_walk_right: 'assets/personagens/Tarek/gifs/tarek-andando01.gif',
                tarek_walk_left: 'assets/personagens/Tarek/gifs/tarek-andando01_mirrored.gif',
                tarek_jump_right: 'assets/personagens/Tarek/gifs/tarek-salto01.gif',
                tarek_jump_left: 'assets/personagens/Tarek/gifs/tarek-salto01_mirrored.gif',
                tarek_ability1_right: 'assets/personagens/Tarek/gifs/tarek-ataque1.gif', // Golpe Devastador
                tarek_ability1_left: 'assets/personagens/Tarek/gifs/tarek-ataque1_mirrored.gif',
                tarek_ability2_right: 'assets/personagens/Tarek/gifs/tarek-ataque2.gif', // Investida Gélida
                tarek_ability2_left: 'assets/personagens/Tarek/gifs/tarek-ataque2_mirrored.gif',
                tarek_ability3_right: 'assets/personagens/Tarek/gifs/tarek-ataque3.gif', // Orbe Congelante
                tarek_ability3_left: 'assets/personagens/Tarek/gifs/tarek-ataque3_mirrored.gif',
                tarek_ability4_right: 'assets/personagens/Tarek/gifs/tarek-ataque4.gif', // Prisão de Gelo
                tarek_ability4_left: 'assets/personagens/Tarek/gifs/tarek-ataque4_mirrored.gif',
                tarek_roar: 'assets/personagens/Tarek/gifs/tarek-rugido.gif', // Usado na introdução da luta

                // Projéteis e Efeitos (GIFs/Imagens)
                projectile_player_i: 'assets/efeitos/projeteis/pedra-negra.gif', // Projétil do player I
                projectile_player_ultimate: 'assets/efeitos/projeteis/pedra-negra-ultimate.gif', // Projétil do player Ultimate
                explosion_general: 'assets/efeitos/explosao-geral.gif',
                tarek_ice_orb: 'assets/efeitos/projeteis/orbe-gelo-tarek.gif',
                tarek_prison_wall: 'assets/efeitos/prisao-gelo-tarek.gif',
                
                // Cutscenes (GIFs)
                cutscene_intro_1: 'assets/animacoes/BatalhaTelaInicial.gif', // Exemplo de GIF de cutscene
                cutscene_intro_2: 'assets/animacoes/Cutscene02.gif', // Exemplo
                cutscene_intro_3: 'assets/animacoes/Cutscene03.gif', // Exemplo
                cutscene_intro_4: 'assets/animacoes/Cutscene04.gif', // Exemplo

                // Audio (MP3s)
                music_menu: 'assets/audio/music/menu.mp3',
                music_platforming: 'assets/audio/music/platforming.mp3',
                music_boss_tarek: 'assets/audio/music/tarek_boss.mp3',
                sfx_jump: 'assets/audio/sfx/jump.mp3',
                sfx_attack_u: 'assets/audio/sfx/attack_u.mp3', // Soco
                sfx_ability_i: 'assets/audio/sfx/ability_i.mp3', // Disparo
                sfx_ability_o: 'assets/audio/sfx/ability_o.mp3', // Investida
                sfx_ability_p: 'assets/audio/sfx/ability_p.mp3', // Ultimate
                sfx_damage_player: 'assets/audio/sfx/damage_player.mp3',
                sfx_damage_enemy: 'assets/audio/sfx/damage_enemy.mp3',
                sfx_level_up: 'assets/audio/sfx/level_up.mp3',
                sfx_boss_roar: 'assets/audio/sfx/boss_roar.mp3',
            }
        };

        // =========================================================
        //  1. VARIÁVEIS GLOBAIS E ESTADO DO JOGO
        // =========================================================
        let canvas, ctx;
        let isMobile = false;
        let isLandscape = true;
        
        // Estado do jogo (single source of truth)
        let gameState = {
            playerName: '',
            playerClass: 'chosenOne', // Classe fixa: Escolhido
            playerHealth: 100,
            playerMaxHealth: 100,
            playerMana: 100,
            playerMaxMana: 100,
            playerPosition: { x: 100, y: 300 },
            playerVelocity: { x: 0, y: 0 },
            playerLevel: 1,
            playerXP: 0,
            playerNextLevelXP: 100,
            playerDamage: 15,
            playerSpeed: CONFIG.PLAYER_BASE_SPEED,
            
            // Estados do Jogador
            isGrounded: false,
            isCrouching: false,
            isInvincible: false,
            invincibilityTimer: 0,
            facing: 'right', // 'right' ou 'left'
            currentAnimation: 'player_idle', // Animação atual do jogador
            animationFrameTimer: 0, // Para controlar a duração das animações de ataque/habilidade
            animationDuration: 300, // Duração padrão de uma animação de ataque em ms
            isUmbraFurious: false,
            umbraFuryTimer: 0,
            
            // Habilidades (cooldowns dinâmicos)
            abilitiesCooldown: { U: 0, I: 0, O: 0, P: 0 },
            abilitiesMaxCooldown: { U: 0.5, I: 1.5, O: 3, P: 15 }, // Ajustado para novo balanceamento
            
            // Controle de jogo
            gamePaused: false,
            inDialog: false,
            inCutscene: false,
            cutsceneCurrentStep: 0, // Novo: controla o passo atual da cutscene
            introCutscenesCompleted: false, // Novo: flag para saber se a intro foi completa
            inMenu: true, // Estado inicial: menu principal
            gameStarted: false, // Jogo ainda não começou
            
            // Câmera
            cameraOffset: { x: 0, y: 0 },
            targetCameraOffset: { x: 0, y: 0 },
            
            // Fase atual
            currentPhase: 0, // 0 = menu, 1 = Muralhas Aurora, 2 = Encontro Tarek, 3 = Boss Fight Tarek
            currentCheckpoint: 'start', // Nome do último checkpoint salvo
            
            // Boss fight
            inBossFight: false,
            bossDefeated: false,

            // Tarek Encounter
            inTarekEncounter: false, // Flag para o encontro com Tarek (antes da luta)
            tarekDialogStep: 0, // Passo atual do diálogo com Tarek
            tarekDialogCompleted: false, // Diálogo com Tarek concluído
            
            // Câmera fixa para encontros específicos (e.g., boss fight)
            fixedCamera: false,
            fixedCameraTarget: { x: 0, y: 0 }
        };

        // Arrays de entidades no mundo
        let platforms = [];
        let particles = [];
        let backgroundLayers = [];
        let enemies = [];
        let abilityEffects = [];
        let damageNumbers = [];
        let checkpoints = [];
        let fallingSpikes = [];
        
        // Controles (estado das teclas pressionadas)
        let keys = {};
        let lastTime = 0; // Para cálculo do deltaTime
        let animationFrameId = null; // ID para cancelar requestAnimationFrame
        
        // Mobile controls (D-pad e botões de ação)
        let mobileControls = {
            up: false, down: false, left: false, right: false,
            abilityU: false, abilityI: false, abilityO: false, abilityP: false
        };

        // Cache de assets carregados (Image objects, AudioBuffers)
        const assetCache = {};

        // Variáveis de estado UI para otimização de updates
        let lastPlayerHealth = -1;
        let lastPlayerMana = -1;
        let lastPlayerXP = -1;
        let lastPlayerLevel = -1;
        let lastPlayerClass = '';
        let lastPlayerDamage = -1;

        // Cores CSS pré-calculadas para acesso rápido no canvas
        let COLOR_HEALTH, COLOR_MANA, COLOR_XP, COLOR_ACCENT_FIRE, COLOR_ACCENT_GOLD, COLOR_ACCENT_BLUE, COLOR_ACCENT_ICE, COLOR_TEXT_LIGHT, COLOR_ARCHER, COLOR_WARRIOR, COLOR_PLAYER;


        // =========================================================
        //  2. GERENCIAMENTO DE ASSETS (IMAGENS, GIFS, ÁUDIOS)
        // =========================================================
        const audioContext = new (window.AudioContext || window.webkitAudioContext)(); // Contexto de áudio para sfx e música
        let currentMusic = null; // Referência à música atualmente tocando

        /**
         * Carrega um asset (imagem, gif ou áudio) para o cache.
         * @param {string} name - Nome da chave para o asset no cache (ex: 'player_idle_right').
         * @param {string} url - URL do asset.
         * @param {string} type - Tipo do asset ('image', 'gif', 'audio').
         * @returns {Promise<any>} Uma Promise que resolve com o asset carregado.
         */
        async function loadAsset(name, url, type) {
            if (type === 'audio') {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    assetCache[name] = audioBuffer;
                } catch (error) {
                    console.error(`Erro ao carregar o áudio '${name}' (${url}):`, error);
                    // Retorna um buffer vazio para evitar erros futuros se o áudio não carregar
                    assetCache[name] = audioContext.createBuffer(2, 22050, 44100); 
                }
            } else if (type === 'image' || type === 'gif') {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = url;
                    img.onload = () => {
                        assetCache[name] = img;
                        resolve(img);
                    };
                    img.onerror = (err) => {
                        console.error(`Erro ao carregar a imagem '${name}' (${url}):`, err);
                        assetCache[name] = null; // Marcar como falha para não tentar renderizar
                        reject(err);
                    };
                });
            }
        }

        /**
         * Carrega todos os assets definidos em CONFIG.ASSET_PATHS.
         * Garante que todos os assets estejam carregados antes de iniciar o jogo.
         */
        async function loadAllAssets() {
            const assetPromises = [];
            for (const [key, path] of Object.entries(CONFIG.ASSET_PATHS)) {
                let type = 'image';
                if (path.endsWith('.mp3')) type = 'audio';
                if (path.endsWith('.gif')) type = 'gif'; // GIFs são tratados como imagens pelo HTMLImageElement
                assetPromises.push(loadAsset(key, path, type));
            }
            // Use Promise.allSettled para que o jogo não pare se um asset falhar, mas logue o erro.
            await Promise.allSettled(assetPromises);
            console.log("Todos os assets carregados (ou tentativas concluídas).");
        }

        /**
         * Reproduz um efeito sonoro (SFX).
         * @param {string} name - Nome do SFX no assetCache.
         * @param {number} [volume=1.0] - Volume do SFX (0.0 a 1.0).
         */
        function playSound(name, volume = 1.0) {
            const audioBuffer = assetCache[name];
            if (!audioBuffer) {
                console.warn(`SFX '${name}' não encontrado ou carregado.`);
                return;
            }
            try {
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = volume * gameSettings.sfxVolume;
                source.connect(gainNode).connect(audioContext.destination);
                source.start(0);
            } catch (error) {
                console.error(`Erro ao reproduzir SFX '${name}':`, error);
            }
        }

        /**
         * Reproduz uma música de fundo. Para um jogo complexo, considere um gerenciador de música mais sofisticado.
         * @param {string} name - Nome da música no assetCache.
         * @param {boolean} [loop=true] - Se a música deve repetir.
         * @param {number} [volume=0.7] - Volume da música (0.0 a 1.0).
         */
        function playMusic(name, loop = true, volume = 0.7) {
            stopMusic(); // Para qualquer música anterior

            const audioBuffer = assetCache[name];
            if (!audioBuffer) {
                console.warn(`Música '${name}' não encontrada ou carregada.`);
                return;
            }

            try {
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.loop = loop;
                const gainNode = audioContext.createGain();
                gainNode.gain.value = volume * gameSettings.musicVolume;
                source.connect(gainNode).connect(audioContext.destination);
                source.start(0);
                currentMusic = source;
            } catch (error) {
                console.error(`Erro ao reproduzir música '${name}':`, error);
            }
        }

        /**
         * Para a música atualmente tocando.
         */
        function stopMusic() {
            if (currentMusic) {
                try {
                    currentMusic.stop();
                    currentMusic.disconnect();
                } catch (error) {
                    console.error("Erro ao parar música anterior:", error);
                }
                currentMusic = null;
            }
        }

        // =========================================================
        //  3. DETECÇÃO DE DISPOSITIVO E RESPONSIVIDADE
        // =========================================================

        /**
         * Detecta se o dispositivo é mobile com base no user agent e dimensões.
         */
        function detectDevice() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      window.innerWidth <= 800 || 
                      'ontouchstart' in window;
            
            if (isMobile) {
                checkOrientation();
                window.addEventListener('orientationchange', () => {
                    setTimeout(checkOrientation, 100); // Pequeno delay para a tela se ajustar
                });
                window.addEventListener('resize', checkOrientation);
            }
        }

        /**
         * Verifica a orientação da tela e mostra aviso se não for paisagem em mobile.
         * Também ajusta a visibilidade dos controles móveis.
         */
        function checkOrientation() {
            if (!isMobile) return;
            
            isLandscape = window.innerWidth > window.innerHeight;
            const orientationWarning = document.getElementById('orientation-warning');
            
            if (!isLandscape) {
                orientationWarning.style.display = 'flex';
                // Pausa o jogo se ele estiver rodando e não for paisagem
                if (gameState.gameStarted && !gameState.gamePaused && !gameState.inMenu) {
                    togglePause();
                }
            } else {
                orientationWarning.style.display = 'none';
                // Se o jogo estava pausado pelo aviso de orientação e voltou para paisagem, tenta despausar
                if (gameState.gameStarted && gameState.gamePaused && !gameState.inMenu && !gameState.inCutscene) {
                    togglePause();
                }
            }
            updateMobileControlsVisibility();
        }

        /**
         * Redimensiona o canvas para preencher o container do jogo.
         */
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            if (isMobile) {
                updateMobileControlsVisibility();
            }
        }

        // =========================================================
        //  4. SISTEMA DE COOKIES / SALVAR E CARREGAR PROGRESSO
        // =========================================================

        /**
         * Define um cookie com nome, valor e tempo de expiração.
         * @param {string} name - Nome do cookie.
         * @param {string} value - Valor do cookie (deve ser string, usar JSON.stringify para objetos).
         * @param {number} [days=30] - Número de dias para o cookie expirar.
         */
        function setCookie(name, value, days = 30) {
            const expires = new Date();
            expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }

        /**
         * Obtém o valor de um cookie.
         * @param {string} name - Nome do cookie.
         * @returns {string|null} O valor do cookie ou null se não encontrado.
         */
        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        /**
         * Salva o progresso atual do jogo em um cookie.
         */
        function saveProgress() {
            const saveData = {
                playerName: gameState.playerName,
                playerClass: gameState.playerClass,
                playerLevel: gameState.playerLevel,
                playerXP: gameState.playerXP,
                playerMaxHealth: gameState.playerMaxHealth,
                playerMaxMana: gameState.playerMaxMana,
                playerDamage: gameState.playerDamage,
                playerSpeed: gameState.playerSpeed,
                currentPhase: gameState.currentPhase,
                currentCheckpoint: gameState.currentCheckpoint,
                bossDefeated: gameState.bossDefeated,
                abilitiesMaxCooldown: gameState.abilitiesMaxCooldown,
                manaRegenRate: CONFIG.MANA_REGEN_RATE,
                // Adicione outros estados importantes que precisam ser salvos
                gameStarted: gameState.gameStarted,
                introCutscenesCompleted: gameState.introCutscenesCompleted
            };
            
            setCookie('tupary_save', JSON.stringify(saveData));
            showCheckpointNotification('Progresso Salvo', 'Seu progresso foi salvo com sucesso!');
        }

        /**
         * Carrega o progresso salvo de um cookie.
         * @returns {object|null} O objeto de dados salvos ou null se não houver.
         */
        function loadProgress() {
            const saveData = getCookie('tupary_save');
            if (saveData) {
                try {
                    const data = JSON.parse(saveData);
                    return data;
                } catch (e) {
                    console.error('Erro ao carregar save:', e);
                }
            }
            return null;
        }

        // =========================================================
        //  5. INICIALIZAÇÃO DO JOGO E MENU PRINCIPAL
        // =========================================================

        /**
         * Ponto de entrada principal para a inicialização do jogo.
         */
        async function init() {
            detectDevice(); // Detecta tipo de dispositivo
            
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas(); // Ajusta o tamanho do canvas
            window.addEventListener('resize', resizeCanvas);
            
            await loadAllAssets(); // Carrega todos os assets (imagens, GIFs, áudios)
            
            initGlobalColors(); /* Pré-calcula as cores CSS para uso no canvas */
            setupCharacter('chosenOne'); // Inicializa o personagem (sempre Escolhido)
            initEventListeners(); // Configura os ouvintes de eventos
            initMobileControls(); // Configura os controles móveis
            
            const savedData = loadProgress();
            if (savedData) {
                // Se houver dados salvos, pré-preenche o menu e tenta carregar o estado salvo
                populateMainMenuWithSavedData(savedData);
            } else {
                // Se não houver save, toca a música do menu
                playMusic('music_menu', true);
            }
            
            gameLoop(0); // Inicia o loop principal do jogo (ainda no menu)
        }

        /**
         * Pré-calcula os valores de cor CSS para uso direto no canvas, otimizando performance.
         */
        function initGlobalColors() {
            const rootStyle = getComputedStyle(document.documentElement);
            COLOR_HEALTH = rootStyle.getPropertyValue('--health-color');
            COLOR_MANA = rootStyle.getPropertyValue('--mana-color');
            COLOR_XP = rootStyle.getPropertyValue('--xp-color');
            COLOR_ACCENT_FIRE = rootStyle.getPropertyValue('--accent-fire');
            COLOR_ACCENT_GOLD = rootStyle.getPropertyValue('--accent-gold');
            COLOR_ACCENT_BLUE = rootStyle.getPropertyValue('--accent-blue');
            COLOR_ACCENT_ICE = rootStyle.getPropertyValue('--accent-ice');
            COLOR_TEXT_LIGHT = rootStyle.getPropertyValue('--text-light');
            COLOR_ARCHER = rootStyle.getPropertyValue('--archer-color');
            COLOR_WARRIOR = rootStyle.getPropertyValue('--warrior-color');
            COLOR_PLAYER = rootStyle.getPropertyValue('--player-color');
        }

        /**
         * Preenche o menu principal com dados do save, se existirem, e ajusta o estado inicial do jogo.
         * @param {object} data - Dados carregados do save.
         */
        function populateMainMenuWithSavedData(data) {
            document.getElementById('player-name').value = data.playerName || '';
            validateMenuInputs(); // Valida o campo de nome

            // Restaura o estado do jogo a partir dos dados salvos
            Object.assign(gameState, {
                playerHealth: data.playerHealth,
                playerMaxHealth: data.playerMaxHealth,
                playerMana: data.playerMana,
                playerMaxMana: data.playerMaxMana,
                playerLevel: data.playerLevel,
                playerXP: data.playerXP,
                playerDamage: data.playerDamage,
                playerSpeed: data.playerSpeed,
                abilitiesMaxCooldown: data.abilitiesMaxCooldown,
                manaRegenRate: data.manaRegenRate,
                currentPhase: data.currentPhase,
                currentCheckpoint: data.currentCheckpoint,
                bossDefeated: data.bossDefeated,
                gameStarted: data.gameStarted || false, // Garante que gameStarted esteja definido
                introCutscenesCompleted: data.introCutscenesCompleted || false // Garante que introCutscenesCompleted esteja definido
            });
            
            // Se o jogo já estava iniciado e as cutscenes introdutórias foram completas
            if (gameState.gameStarted && !gameState.inMenu && gameState.introCutscenesCompleted) {
                document.getElementById('main-menu').style.display = 'none'; // Esconde o menu
                loadPhase(gameState.currentPhase); // Carrega a fase salva
                updateAllUI(); // Atualiza a UI com os dados salvos
                playMusic('music_platforming', true); // Toca a música de gameplay
            } else {
                // Se não, volta para o menu principal padrão
                gameState.gameStarted = false;
                gameState.inMenu = true;
                document.getElementById('main-menu').style.display = 'flex';
                playMusic('music_menu', true);
            }
        }

        /**
         * Valida o input de nome no menu principal e habilita/desabilita o botão "Iniciar Jornada".
         */
        function validateMenuInputs() {
            const name = document.getElementById('player-name').value.trim();
            const startBtn = document.getElementById('start-game-btn');
            
            if (name.length >= 2) {
                startBtn.disabled = false;
            } else {
                startBtn.disabled = true;
            }
        }

        /**
         * Inicia o jogo a partir do menu principal.
         */
        function startGame() {
            const name = document.getElementById('player-name').value.trim();
            if (name.length < 2) return; // Garante que o nome tenha pelo menos 2 caracteres
            
            gameState.playerName = name;
            gameState.inMenu = false;
            gameState.gameStarted = true;
            gameState.playerClass = 'chosenOne'; // Garante que a classe seja definida
            
            document.getElementById('main-menu').style.display = 'none'; // Esconde o menu principal
            
            if (isMobile) {
                updateMobileControlsVisibility(); // Ajusta visibilidade dos controles móveis
            }
            
            stopMusic(); // Para a música do menu
            showIntroCutscene(); // Inicia as cutscenes de introdução
        }

        /**
         * Sai do jogo e retorna ao menu principal, salvando o progresso.
         */
        function exitToMenu() {
            saveProgress(); // Salva o progresso antes de sair
            
            // Reinicia o estado do jogo para o menu principal
            Object.assign(gameState, {
                playerName: '',
                playerClass: 'chosenOne',
                playerHealth: 100, playerMaxHealth: 100,
                playerMana: 100, playerMaxMana: 100,
                playerPosition: { x: 100, y: 300 },
                playerVelocity: { x: 0, y: 0 },
                playerLevel: 1, playerXP: 0, playerNextLevelXP: 100,
                playerDamage: 15, playerSpeed: CONFIG.PLAYER_BASE_SPEED,
                isGrounded: false, isCrouching: false, isInvincible: false, facing: 'right', currentAnimation: 'player_idle',
                animationFrameTimer: 0, animationDuration: 300,
                isUmbraFurious: false, umbraFuryTimer: 0,
                abilitiesCooldown: { U: 0, I: 0, O: 0, P: 0 },
                abilitiesMaxCooldown: { U: 0.5, I: 1.5, O: 3, P: 15 },
                gamePaused: false, inDialog: false, inCutscene: false,
                cutsceneCurrentStep: 0,
                introCutscenesCompleted: false,
                inMenu: true,
                gameStarted: false,
                cameraOffset: { x: 0, y: 0 }, targetCameraOffset: { x: 0, y: 0 },
                currentPhase: 0, currentCheckpoint: 'start',
                inBossFight: false, bossDefeated: false,
                inTarekEncounter: false, tarekDialogStep: 0, tarekDialogCompleted: false,
                fixedCamera: false, fixedCameraTarget: { x: 0, y: 0 }
            });

            // Limpa todas as entidades do mundo
            platforms = []; enemies = []; abilityEffects = []; particles = []; damageNumbers = []; checkpoints = []; fallingSpikes = [];
            
            // Exibe o menu principal e esconde outros overlays
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'none';
            document.getElementById('abilities-container').style.display = 'flex';
            document.getElementById('player-name').value = '';
            document.getElementById('start-game-btn').disabled = true;

            updateAllUI(); // Atualiza a UI (limpando valores antigos)
            
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpa o canvas

            stopMusic();
            playMusic('music_menu', true); // Toca a música do menu
        }

        // =========================================================
        //  6. CLASSES DE PERSONAGEM (APENAS "ESCOLHIDO" POR ENQUANTO)
        // =========================================================

        /**
         * Configura as propriedades do personagem Escolhido.
         * Os parâmetros permitem sobrescrever os valores base com dados de um save.
         */
        function setupCharacter(playerClass, health = null, mana = null, damage = null, speed = null, abilitiesMaxCooldown = null, manaRegenRate = null) {
            // Definições base para a classe Escolhido
            const chosenOneClass = {
                id: 'chosenOne',
                name: 'Escolhido',
                type: 'hybrid', // Equilibrado, não extremamente poderoso
                baseHealth: 100,
                baseMana: 100,
                baseSpeed: CONFIG.PLAYER_BASE_SPEED,
                baseDamage: 15,
                abilitiesMaxCooldown: { U: 0.5, I: 1.5, O: 3, P: 15 }, // Cooldowns em segundos
                manaRegenRate: 1.5, // Mana por segundo
                abilities: [
                    {
                        key: 'U',
                        name: 'Soco',
                        description: 'Ataque corpo a corpo rápido.',
                        damage: (base) => base * 1.0,
                        manaCost: 0,
                        cooldown: 0.5,
                        animation: 'player_attack_u',
                        execute: function() {
                            playSound('sfx_attack_u');
                            addAbilityEffect({
                                type: 'meleeAttack',
                                x: gameState.playerPosition.x + (gameState.facing === 'right' ? CONFIG.PLAYER_SPRITE_WIDTH * 0.8 : -CONFIG.PLAYER_SPRITE_WIDTH * 0.3),
                                y: gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT * 0.5,
                                width: CONFIG.PLAYER_SPRITE_WIDTH * 0.5,
                                height: CONFIG.PLAYER_SPRITE_HEIGHT * 0.3,
                                duration: 200, // Duração do efeito de hitbox
                                damage: this.damage(gameState.playerDamage),
                                origin: 'player'
                            });
                        }
                    },
                    {
                        key: 'I',
                        name: 'Disparo',
                        description: 'Lança um projétil negro de energia.',
                        damage: (base) => base * 1.2,
                        manaCost: 10,
                        cooldown: 1.5,
                        animation: 'player_attack_i',
                        execute: function() {
                            playSound('sfx_ability_i');
                            addAbilityEffect({
                                type: 'energyProjectile',
                                x: gameState.playerPosition.x + (gameState.facing === 'right' ? CONFIG.PLAYER_SPRITE_WIDTH : -CONFIG.PLAYER_SPRITE_WIDTH * 0.2),
                                y: gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT * 0.5,
                                width: 25,
                                height: 15,
                                duration: 1500, // Duração do projétil na tela
                                damage: this.damage(gameState.playerDamage),
                                direction: gameState.facing === 'right' ? 1 : -1,
                                speed: 8,
                                origin: 'player',
                                piercing: false, // Não atravessa inimigos
                                asset: 'projectile_player_i'
                            });
                        }
                    },
                    {
                        key: 'O',
                        name: 'Investida',
                        description: 'Dash rápido que causa dano e concede invulnerabilidade temporária.',
                        damage: (base) => base * 0.8, // Dano base menor, mas com invulnerabilidade
                        manaCost: 25,
                        cooldown: 3,
                        animation: 'player_attack_o',
                        execute: function() {
                            playSound('sfx_ability_o');
                            gameState.playerVelocity.x = (gameState.facing === 'right' ? 12 : -12); // Impulso horizontal
                            gameState.isInvincible = true;
                            gameState.invincibilityTimer = 300; // Duração da invulnerabilidade durante o dash
                            addParticles('dashEffect', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2, 20);
                            
                            // Aplica dano em área durante o dash
                            addAbilityEffect({
                                type: 'chargeAttack', // Reutiliza a lógica de chargeAttack para dano em área
                                x: gameState.playerPosition.x,
                                y: gameState.playerPosition.y,
                                width: CONFIG.PLAYER_SPRITE_WIDTH,
                                height: CONFIG.PLAYER_SPRITE_HEIGHT,
                                duration: 300,
                                damage: this.damage(gameState.playerDamage),
                                origin: 'player',
                                knockback: 0,
                                areaEffect: true // Afeta todos na área
                            });
                        }
                    },
                    {
                        key: 'P',
                        name: 'Fúria de Umbra',
                        description: 'Canaliza a energia de Umbra para ficar mais rápido, resistente e poderoso.',
                        damage: (base) => base, // O dano base é aumentado pelos bônus na Ultimate
                        manaCost: 50,
                        cooldown: 15,
                        animation: 'player_ultimate',
                        execute: function() {
                            playSound('sfx_ability_p');
                            gameState.isUmbraFurious = true;
                            gameState.umbraFuryTimer = CONFIG.UMBRA_FURY_DURATION;
                            addParticles('umbraFuria', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2, 40);
                            // Aplica um filtro temporário ao canvas para efeito visual da ultimate
                            canvas.style.filter = 'brightness(1.5) saturate(1.5) hue-rotate(90deg)';
                            setTimeout(() => {
                                canvas.style.filter = 'none'; // Remove o filtro após a duração
                            }, CONFIG.UMBRA_FURY_DURATION);
                        }
                    }
                ]
            };

            // Aplica os valores base ou os carregados do save
            gameState.playerMaxHealth = health !== null ? health : chosenOneClass.baseHealth;
            gameState.playerHealth = gameState.playerMaxHealth; // Recarrega vida no setup (apenas ao iniciar ou carregar)
            gameState.playerMaxMana = mana !== null ? mana : chosenOneClass.baseMana;
            gameState.playerMana = gameState.playerMaxMana; // Recarrega mana
            gameState.playerSpeed = speed !== null ? speed : chosenOneClass.baseSpeed;
            gameState.playerDamage = damage !== null ? damage : chosenOneClass.baseDamage;

            // Sobrescreve os cooldowns e taxa de regeneração com os da classe ou salvos
            Object.assign(gameState.abilitiesMaxCooldown, abilitiesMaxCooldown !== null ? abilitiesMaxCooldown : chosenOneClass.abilitiesMaxCooldown);
            CONFIG.MANA_REGEN_RATE = manaRegenRate !== null ? manaRegenRate : chosenOneClass.manaRegenRate;
            
            // Adiciona as habilidades do Escolhido no objeto global para acesso
            gameState.chosenOneAbilities = chosenOneClass.abilities;
            updateAbilityTooltips(); // Atualiza os tooltips de habilidades na UI
            updateAllUI(); // Atualiza todas as barras e stats na UI
        }

        /**
         * Atualiza os textos dos tooltips de habilidades na UI com os nomes e descrições.
         */
        function updateAbilityTooltips() {
            if (!gameState.chosenOneAbilities) return;
            
            gameState.chosenOneAbilities.forEach(ability => {
                const key = ability.key.toLowerCase();
                const nameEl = document.getElementById(`tooltip-${key}-name`);
                const descEl = document.getElementById(`tooltip-${key}-desc`);
                const costEl = document.getElementById(`tooltip-${key}-cost`);
                
                if (nameEl) nameEl.textContent = ability.name;
                if (descEl) descEl.textContent = ability.description;
                if (costEl) costEl.textContent = `Custo: ${ability.manaCost} Mana`;
            });
        }

        // =========================================================
        //  7. EVENT LISTENERS GERAIS E CONTROLES
        // =========================================================

        /**
         * Inicializa todos os ouvintes de eventos para o jogo.
         */
        function initEventListeners() {
            /* Menu Principal */
            document.getElementById('player-name').addEventListener('input', validateMenuInputs);
            document.getElementById('start-game-btn').addEventListener('click', startGame);
            
            /* Controles de teclado */
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            /* Botões da UI */
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('restart-btn').addEventListener('click', restartFromCheckpoint);
            document.getElementById('save-btn').addEventListener('click', saveProgress);
            document.getElementById('exit-btn').addEventListener('click', exitToMenu);
            document.getElementById('next-btn').addEventListener('click', advanceCutscene); // Botão "Próximo" para cutscenes
            
            /* Habilidades desktop */
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.key;
                    if (key) useAbility(key);
                });
            });
            
            /* Level up (com escolhas) */
            document.querySelectorAll('.upgrade-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const upgrade = e.currentTarget.dataset.upgrade;
                    applyUpgrade(upgrade);
                });
            });
        }

        /**
         * Manipula eventos de tecla pressionada.
         * @param {KeyboardEvent} e - Evento de teclado.
         */
        function handleKeyDown(e) {
            // Previne o comportamento padrão do navegador para teclas de movimento e espaço
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            keys[e.key.toLowerCase()] = true; // Registra a tecla como pressionada

            // Pausa/despausa o jogo com Escape
            if (e.key === 'Escape' && gameState.gameStarted && !gameState.inMenu && !gameState.inCutscene && !gameState.inDialog) {
                togglePause();
            }
            
            // Ativa habilidades com as teclas U, I, O, P
            if (['u', 'i', 'o', 'p'].includes(e.key.toLowerCase()) && 
                !gameState.gamePaused && !gameState.inDialog && !gameState.inCutscene && !gameState.inMenu) {
                useAbility(e.key.toUpperCase());
            }
        }

        /**
         * Manipula eventos de tecla solta.
         * @param {KeyboardEvent} e - Evento de teclado.
         */
        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false; // Desregistra a tecla
        }

        /**
         * Inicializa os ouvintes de eventos para os controles móveis (touch).
         */
        function initMobileControls() {
            /* D-pad */
            document.getElementById('mobile-up').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.up = true; });
            document.getElementById('mobile-up').addEventListener('touchend', () => mobileControls.up = false);
            document.getElementById('mobile-down').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.down = true; });
            document.getElementById('mobile-down').addEventListener('touchend', () => mobileControls.down = false);
            document.getElementById('mobile-left').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.left = true; });
            document.getElementById('mobile-left').addEventListener('touchend', () => mobileControls.left = false);
            document.getElementById('mobile-right').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.right = true; });
            document.getElementById('mobile-right').addEventListener('touchend', () => mobileControls.right = false);

            /* Botões de Habilidade */
            document.getElementById('mobile-ability-u').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('U'); });
            document.getElementById('mobile-ability-i').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('I'); });
            document.getElementById('mobile-ability-o').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('O'); });
            document.getElementById('mobile-ability-p').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('P'); });
            
            updateMobileControlsVisibility(); // Garante que os controles sejam visíveis/ocultos corretamente no início
        }

        /**
         * Atualiza a visibilidade dos controles móveis com base na detecção de dispositivo e orientação.
         */
        function updateMobileControlsVisibility() {
            const mobileControlsDiv = document.getElementById('mobile-controls');
            if (isMobile && isLandscape) {
                mobileControlsDiv.style.display = 'grid';
            } else {
                mobileControlsDiv.style.display = 'none';
            }
        }

        // =========================================================
        //  8. SISTEMA DE FASES E NARRATIVA
        // =========================================================

        /**
         * Carrega uma fase específica do jogo, reiniciando entidades e posição do jogador.
         * @param {number} phaseNumber - O número da fase a ser carregada.
         */
        function loadPhase(phaseNumber) {
            gameState.currentPhase = phaseNumber;
            
            // Reinicia a posição e velocidade do jogador
            gameState.playerPosition = { x: 100, y: 300 };
            gameState.playerVelocity = { x: 0, y: 0 };
            gameState.isGrounded = false;
            gameState.isCrouching = false;
            
            // Limpa todas as entidades da fase anterior
            enemies = [];
            abilityEffects = [];
            particles = [];
            damageNumbers = [];
            fallingSpikes = [];
            
            // Configura a fase específica
            switch(phaseNumber) {
                case 1:
                    setupPhase1_MuralhasAurora();
                    stopMusic();
                    playMusic('music_platforming', true);
                    break;
                case 2:
                    setupPhase1_TarekEncounter();
                    break;
                case 3:
                    setupPhase1_TarekBossFight();
                    break;
                default:
                    // Fallback para a primeira fase se o número for inválido
                    setupPhase1_MuralhasAurora();
            }
            
            // Reinicia a câmera para a nova fase
            gameState.cameraOffset = { x: 0, y: 0 };
            gameState.targetCameraOffset = { x: 0, y: 0 };
        }

        /**
         * Configura a primeira fase do jogo: "Muralhas Aurora".
         */
        function setupPhase1_MuralhasAurora() {
            // Definição das plataformas
            platforms = [
                { x: 0, y: 400, width: 6000, height: 50, type: 'ground', asset: 'platform_ground' }, // Chão principal
                { x: 200, y: 350, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 350, y: 300, width: 80, height: 20, type: 'platform', slippery: true, asset: 'platform_ice' }, // Plataforma escorregadia
                { x: 500, y: 250, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 700, y: 320, width: 120, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 900, y: 380, width: 50, height: 20, type: 'platform', asset: 'platform_ground' },
                
                { x: 1100, y: 400, width: 150, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 1100, y: 350, width: 150, height: 50, type: 'spike', asset: 'platform_spike' }, // Espinhos
                { x: 1300, y: 400, width: 100, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 1500, y: 300, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 1700, y: 250, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 2000, y: 350, width: 120, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 2300, y: 400, width: 200, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 2300, y: 350, width: 200, height: 50, type: 'spike', asset: 'platform_spike' },
                { x: 2600, y: 300, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 2800, y: 250, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 3100, y: 400, width: 150, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 3400, y: 350, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 3600, y: 300, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 3900, y: 400, width: 200, height: 50, type: 'ground', asset: 'platform_ground' },
                { x: 4200, y: 350, width: 80, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 4400, y: 300, width: 100, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 4700, y: 250, width: 120, height: 20, type: 'platform', asset: 'platform_ground' },
                { x: 5000, y: 400, width: 1000, height: 50, type: 'ground', asset: 'platform_ground' },
            ];

            // Espinhos que caem
            fallingSpikes = [
                { x: 800, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 1200, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 1800, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 2400, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 3000, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 3800, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
                { x: 4500, y: -50, width: 30, height: 30, speed: 2, active: false, asset: 'platform_spike' },
            ];

            // Inimigos (Sentinelas)
            enemies = [
                { type: 'sentinel', position: { x: 600, y: 300 }, health: 50, maxHealth: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 20, direction: 1, attackCooldown: 0, currentAnimation: 'sentinel_idle', animationTimer: 0, animationDuration: 500, facing: 'right' },
                { type: 'sentinel', position: { x: 1600, y: 250 }, health: 50, maxHealth: 50, damage: 10, speed: 1, patrolRange: 120, xpValue: 20, direction: 1, attackCooldown: 0, currentAnimation: 'sentinel_idle', animationTimer: 0, animationDuration: 500, facing: 'right' },
                { type: 'sentinel', position: { x: 2700, y: 250 }, health: 50, maxHealth: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 20, direction: -1, attackCooldown: 0, currentAnimation: 'sentinel_idle', animationTimer: 0, animationDuration: 500, facing: 'left' },
                { type: 'sentinel', position: { x: 3700, y: 300 }, health: 50, maxHealth: 50, damage: 10, speed: 1, patrolRange: 150, xpValue: 20, direction: 1, attackCooldown: 0, currentAnimation: 'sentinel_idle', animationTimer: 0, animationDuration: 500, facing: 'right' },
                { type: 'sentinel', position: { x: 4600, y: 250 }, health: 50, maxHealth: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 20, direction: -1, attackCooldown: 0, currentAnimation: 'sentinel_idle', animationTimer: 0, animationDuration: 500, facing: 'left' }
            ];

            // Checkpoints
            checkpoints = [
                { x: 1000, y: 350, width: 50, height: 50, name: 'checkpoint1', description: 'Primeiro Checkpoint' },
                { x: 2500, y: 350, width: 50, height: 50, name: 'checkpoint2', description: 'Segundo Checkpoint' },
                { x: 4000, y: 350, width: 50, height: 50, name: 'checkpoint3', description: 'Terceiro Checkpoint' },
            ];
            
            // Camadas de fundo para parallax
            backgroundLayers = [
                { asset: 'bg_sky', speed: 0.1 },
                { asset: 'bg_mountains', speed: 0.3 },
                { asset: 'bg_hills', speed: 0.5 },
                { asset: 'bg_foreground', speed: 0.7 }
            ];

            CONFIG.WORLD_WIDTH = 6000; // Define a largura do mundo para esta fase
            
            // Flags para o encontro com Tarek
            gameState.inTarekEncounter = false;
            gameState.tarekDialogStep = 0;
            gameState.tarekDialogCompleted = false;
            gameState.fixedCamera = false;
        }

        /**
         * Configura a fase do encontro com Tarek (apenas diálogo, antes da luta).
         */
        function setupPhase1_TarekEncounter() {
            // Plataforma única para o encontro
            platforms = [
                { x: 0, y: 400, width: canvas.width, height: 50, type: 'ground', asset: 'platform_ground' }
            ];
            enemies = [];
            checkpoints = [];
            
            // Camadas de fundo específicas para o encontro
            backgroundLayers = [
                { asset: 'bg_sky', speed: 0.1 },
                { asset: 'bg_mountains', speed: 0.3 }
            ];

            gameState.fixedCamera = true; // Câmera fixa para esta cena
            gameState.fixedCameraTarget = { x: 0, y: 0 }; // Posição fixa da câmera
            gameState.playerPosition = { x: 150, y: 300 }; // Posição inicial do jogador
            gameState.playerVelocity = { x: 0, y: 0 };

            // Oponente Tarek (apenas para exibição durante o diálogo)
            const tarek = {
                type: 'boss_dialogue', // Tipo especial para Tarek em diálogo
                name: 'Tarek, o Guerreiro',
                position: { x: canvas.width - 150, y: 300 }, // Posiciona Tarek no canto direito da tela
                facing: 'left', // Tarek olhando para a esquerda (para o jogador)
                health: 1, maxHealth: 1, // Sem vida real neste estado
                damage: 0, // Não causa dano neste estado
                currentAnimation: 'tarek_idle', animationTimer: 0, animationDuration: 500
            };
            enemies.push(tarek);
            
            gameState.inTarekEncounter = true; // Ativa flag de encontro
            startTarekDialogue(); // Inicia o diálogo
        }

        /**
         * Configura a fase da luta contra Tarek.
         */
        function setupPhase1_TarekBossFight() {
            // Plataforma única para a arena do chefe
            platforms = [
                { x: 0, y: 400, width: canvas.width, height: 50, type: 'ground', asset: 'platform_ground' }
            ];
            enemies = [];
            checkpoints = []; // Sem checkpoints durante a luta de boss
            
            // Camadas de fundo para a luta
            backgroundLayers = [
                { asset: 'bg_sky', speed: 0.1 },
                { asset: 'bg_mountains', speed: 0.3 }
            ];

            gameState.fixedCamera = true; // Câmera fixa na arena
            gameState.fixedCameraTarget = { x: 0, y: 0 };
            gameState.playerPosition = { x: 150, y: 300 }; // Posição inicial do jogador
            
            // Restaura vida e mana do jogador no início da luta
            gameState.playerHealth = gameState.playerMaxHealth;
            gameState.playerMana = gameState.playerMaxMana;
            updateHealthBar();
            updateManaBar();
            
            triggerBossFight(); // Inicia a lógica da luta de chefe
            stopMusic();
            playMusic('music_boss_tarek', true); // Toca a música do boss
        }

        // =========================================================
        //  9. CUTSCENES E SISTEMA DE DIÁLOGO
        // =========================================================

        // Definição da sequência de cutscenes introdutórias
        const cinematicSequence = [
            {
                title: "A CONVOCAÇÃO",
                text: `Umbra, a entidade primordial do equilíbrio, convoca você, %PLAYER_NAME%, o Escolhido.`,
                image: 'cutscene_intro_3',
                minTextTime: 4000 // Tempo mínimo para o texto ficar visível antes do botão Próximo
            },
            {
                title: "O DESEQUILÍBRIO",
                text: "O mundo treme sob o peso do desequilíbrio. Ignys, o Reino do Fogo, deseja guerra e já move suas tropas em direção aos reinos vizinhos.",
                image: 'cutscene_intro_1',
                minTextTime: 5000
            },
            {
                title: "O CORAÇÃO DE GELO",
                text: "Em Tupãry, o Reino Congelado, guarda-se a metade maligna de Anhangá, o espírito que traz caos. Se Ignys a obter, será o fim de tudo.",
                image: 'cutscene_intro_2',
                minTextTime: 6000
            },
            {
                title: "O DESTINO",
                text: "Recupere o Coração de Gelo e impeça que Ignys domine todos os reinos. Cada passo, cada luta, cada escolha será decisiva para a sobrevivência de todos.",
                image: 'cutscene_intro_4',
                minTextTime: 7000
            }
        ];

        /**
         * Mostra o overlay de cutscene e inicia a sequência.
         */
        function showIntroCutscene() {
            gameState.inCutscene = true;
            gameState.cutsceneCurrentStep = 0;
            const cinematicOverlay = document.getElementById('cinematic-overlay');
            cinematicOverlay.style.display = 'flex';
            cinematicOverlay.querySelector('.next-btn').style.display = 'none'; // Esconde o botão Próximo inicialmente
            
            advanceCutscene(); // Inicia a primeira etapa da cutscene
        }

        /**
         * Avança para o próximo passo da cutscene atual.
         * Gerencia a exibição de texto, imagem e o botão "Próximo".
         */
        function advanceCutscene() {
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            const imageElement = document.getElementById('cinematic-image');
            const nextBtn = document.getElementById('next-btn');

            // Verifica se ainda há passos na cutscene
            if (gameState.cutsceneCurrentStep < cinematicSequence.length) {
                const step = cinematicSequence[gameState.cutsceneCurrentStep];

                titleElement.textContent = step.title;
                // Substitui %PLAYER_NAME% pelo nome real do jogador
                textElement.textContent = step.text.replace('%PLAYER_NAME%', gameState.playerName);

                // Gerencia a exibição da imagem de fundo da cutscene
                if (step.image && assetCache[step.image]) {
                    imageElement.src = assetCache[step.image].src;
                    imageElement.style.opacity = '0.3'; // Transparência para o texto ser legível
                    overlay.classList.add('with-image');
                } else {
                    imageElement.src = '';
                    imageElement.style.opacity = '0';
                    overlay.classList.remove('with-image');
                }
                
                // Reinicia as animações de texto para que reapareçam
                titleElement.style.animation = 'none';
                textElement.style.animation = 'none';
                void titleElement.offsetWidth; // Força reflow para reiniciar a animação
                void textElement.offsetWidth;
                
                titleElement.style.animation = 'fadeInText 2s forwards';
                textElement.style.animation = 'fadeInText 3s forwards 0.5s';

                nextBtn.style.display = 'none'; // Esconde o botão "Próximo"
                // Mostra o botão "Próximo" após um tempo mínimo de leitura do texto
                setTimeout(() => {
                    nextBtn.style.display = 'block';
                }, step.minTextTime || 3000); // Usa minTextTime do step ou um padrão
                
                gameState.cutsceneCurrentStep++; // Incrementa para o próximo passo
            } else {
                // Se todas as cutscenes foram exibidas, encerra
                endIntroCutscenes();
            }
        }
            
        /**
         * Finaliza a sequência de cutscenes introdutórias e inicia o jogo.
         */
        function endIntroCutscenes() {
            document.getElementById('cinematic-overlay').style.display = 'none';
            gameState.inCutscene = false;
            gameState.introCutscenesCompleted = true; // Marca que as cutscenes foram completas
            loadPhase(1); // Inicia o jogo na primeira fase de gameplay
        }

        /**
         * Exibe um container de diálogo com um orador, texto e opções.
         * @param {string} speaker - Nome do personagem falando.
         * @param {string} text - Texto do diálogo.
         * @param {Array<object>|null} options - Array de objetos { text: string, action: function }.
         */
        function showDialog(speaker, text, options = null) {
            gameState.inDialog = true;
            gameState.gamePaused = true; // Pausa o jogo durante o diálogo
            const dialogContainer = document.getElementById('dialog-container');
            const speakerElement = document.getElementById('dialog-speaker');
            const textElement = document.getElementById('dialog-text');
            const optionsElement = document.getElementById('dialog-options');
            
            dialogContainer.style.display = 'block';
            speakerElement.textContent = speaker;
            textElement.textContent = text;
            
            optionsElement.innerHTML = ''; // Limpa opções anteriores
            
            if (options && options.length > 0) {
                // Se houver opções de escolha
                options.forEach((option) => {
                    const button = document.createElement('div');
                    button.className = 'dialog-option';
                    button.textContent = option.text;
                    button.addEventListener('click', () => {
                        dialogContainer.style.display = 'none'; // Esconde o diálogo
                        gameState.inDialog = false;
                        gameState.gamePaused = false; // Despausa o jogo
                        if (option.action) option.action(); // Executa a ação da opção
                    });
                    optionsElement.appendChild(button);
                });
            } else {
                // Se não houver opções, adiciona um botão "Continuar" padrão
                const button = document.createElement('div');
                button.className = 'dialog-option';
                button.textContent = 'Continuar';
                button.addEventListener('click', () => {
                    dialogContainer.style.display = 'none';
                    gameState.inDialog = false;
                    gameState.gamePaused = false;
                });
                optionsElement.appendChild(button);
            }
        }

        /**
         * Inicia a sequência de diálogo com Tarek antes da luta.
         */
        function startTarekDialogue() {
            gameState.tarekDialogStep = 0;
            const tarekDialogs = [
                { speaker: "TAREK, O GUERREIRO", text: `Então você é ${gameState.playerName}, o tal Escolhido?` },
                { speaker: "TAREK, O GUERREIRO", text: "Estas muralhas não são lugar para forasteiros fracos." },
                { speaker: "TAREK, O GUERREIRO", text: "Prove que merece passar por aqui, ou volte de onde veio!" }
            ];

            /**
             * Mostra a próxima linha de diálogo de Tarek.
             */
            function showTarekLine() {
                if (gameState.tarekDialogStep < tarekDialogs.length) {
                    const line = tarekDialogs[gameState.tarekDialogStep];
                    showDialog(line.speaker, line.text, [{ text: "Continuar", action: () => {
                        gameState.tarekDialogStep++;
                        showTarekLine(); // Chama recursivamente para a próxima linha
                    }}]);
                } else {
                    gameState.tarekDialogCompleted = true; // Marca o diálogo como completo
                    gameState.inTarekEncounter = false; // Sai do estado de encontro
                    loadPhase(3); // Inicia a luta contra Tarek
                }
            }
            showTarekLine(); // Começa a exibir a primeira linha
        }

        // =========================================================
        //  10. SISTEMA DE CHECKPOINTS
        // =========================================================

        /**
         * Salva o estado atual do jogo em um checkpoint.
         * @param {string} checkpointName - Nome único do checkpoint.
         */
        function saveCheckpoint(checkpointName) {
            gameState.currentCheckpoint = checkpointName;
            
            const checkpointData = {
                name: checkpointName,
                phase: gameState.currentPhase,
                position: { ...gameState.playerPosition }, // Copia a posição atual
                health: gameState.playerHealth,
                mana: gameState.playerMana,
                xp: gameState.playerXP,
                level: gameState.playerLevel,
                playerClass: gameState.playerClass,
                playerMaxHealth: gameState.playerMaxHealth,
                playerMaxMana: gameState.playerMaxMana,
                playerDamage: gameState.playerDamage,
                playerSpeed: gameState.playerSpeed,
                abilitiesMaxCooldown: gameState.abilitiesMaxCooldown,
                manaRegenRate: CONFIG.MANA_REGEN_RATE
            };
            
            setCookie('tupary_checkpoint', JSON.stringify(checkpointData));
            showCheckpointNotification('Checkpoint Salvo', `Progresso salvo em: ${getCheckpointDescription(checkpointName)}`);
        }

        /**
         * Carrega o último checkpoint salvo.
         * @returns {boolean} True se o checkpoint foi carregado, false caso contrário.
         */
        function loadCheckpoint() {
            const checkpointData = getCookie('tupary_checkpoint');
            if (checkpointData) {
                try {
                    const data = JSON.parse(checkpointData);
                    
                    // Restaura o estado do jogo do checkpoint
                    gameState.currentPhase = data.phase;
                    gameState.currentCheckpoint = data.name;
                    gameState.playerPosition = { ...data.position };
                    gameState.playerHealth = data.health;
                    gameState.playerMana = data.mana;
                    gameState.playerXP = data.xp;
                    gameState.playerLevel = data.level;
                    gameState.playerClass = data.playerClass;

                    // Reconfigura o personagem com os stats do checkpoint
                    setupCharacter(data.playerClass, data.playerMaxHealth, data.playerMaxMana, data.playerDamage, data.playerSpeed, data.abilitiesMaxCooldown, data.manaRegenRate);
                    
                    loadPhase(data.phase); // Carrega a fase correspondente ao checkpoint
                    updateAllUI(); // Atualiza a UI
                    return true;
                } catch (e) {
                    console.error('Erro ao carregar checkpoint:', e);
                }
            }
            return false;
        }

        /**
         * Retorna uma descrição textual de um checkpoint.
         * @param {string} checkpointName - Nome do checkpoint.
         * @returns {string} Descrição do checkpoint.
         */
        function getCheckpointDescription(checkpointName) {
            const checkpoint = checkpoints.find(cp => cp.name === checkpointName);
            return checkpoint ? checkpoint.description : 'Localização Desconhecida';
        }

        /**
         * Exibe uma notificação temporária de checkpoint salvo/carregado.
         * @param {string} title - Título da notificação.
         * @param {string} description - Descrição da notificação.
         */
        function showCheckpointNotification(title, description) {
            const notification = document.getElementById('checkpoint-notification');
            const titleEl = notification.querySelector('.checkpoint-text');
            const descEl = notification.querySelector('.checkpoint-description');
            
            titleEl.textContent = title;
            descEl.textContent = description;
            
            notification.style.display = 'block';
            notification.style.animation = 'checkpointPulse 2s ease-in-out'; // Ativa animação
            
            setTimeout(() => {
                notification.style.display = 'none'; // Esconde após 2 segundos
            }, 2000);
        }

        /**
         * Reinicia o jogo a partir do último checkpoint salvo ou do início da fase.
         */
        function restartFromCheckpoint() {
            togglePause(); // Despausa o jogo
            
            if (loadCheckpoint()) {
                showCheckpointNotification('Checkpoint Carregado', 'Retornando ao último checkpoint salvo...');
            } else {
                // Se não há checkpoint, reinicia a fase atual com vida e mana cheias
                loadPhase(gameState.currentPhase);
                gameState.playerHealth = gameState.playerMaxHealth;
                gameState.playerMana = gameState.playerMaxMana;
                updateAllUI();
                showCheckpointNotification('Sem Checkpoint', 'Início da fase restaurado.');
            }
        }

        // =========================================================
        //  11. LOOP PRINCIPAL DO JOGO E UPDATE
        // =========================================================

        /**
         * O loop principal do jogo, chamado em cada frame.
         * @param {DOMHighResTimeStamp} timestamp - Tempo atual fornecido por requestAnimationFrame.
         */
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime; // Tempo desde o último frame
            lastTime = timestamp;
            
            // Limita o deltaTime para evitar comportamentos erráticos em caso de lags
            const cappedDeltaTime = Math.min(deltaTime, CONFIG.DELTA_TIME_CAP);
            
            if (!gameState.gamePaused && gameState.gameStarted) {
                // Somente atualiza a lógica do jogo se não estiver pausado e o jogo tiver começado
                if (!gameState.inCutscene && !gameState.inDialog) {
                    update(cappedDeltaTime);
                }
                render(); // Renderiza a cena
            } else if (gameState.inMenu) {
                renderMenu(); // Renderiza o menu principal
            } else { 
                // Se o jogo está pausado (mas não no menu), continua renderizando a cena atual (pausada)
                render(); 
            }
            
            animationFrameId = requestAnimationFrame(gameLoop); // Solicita o próximo frame
        }

        /**
         * Atualiza o estado de todos os elementos do jogo.
         * @param {number} deltaTime - Tempo decorrido desde o último update em ms.
         */
        function update(deltaTime) {
            updatePlayer(deltaTime);
            updateEnemies(deltaTime);
            updateAbilityEffects(deltaTime);
            updateParticles(deltaTime);
            updateDamageNumbers(deltaTime);
            updateCooldowns(deltaTime);
            updateRegeneration(deltaTime);
            updateCamera(deltaTime);
            updateFallingSpikes(deltaTime);
            
            // Verifica checkpoints apenas na fase de plataforma
            if (gameState.currentPhase === 1) {
                checkCheckpoints();
            }
            
            checkGameConditions(); // Verifica condições de fim de jogo
        }

        /**
         * Atualiza o estado do jogador.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updatePlayer(deltaTime) {
            let moveX = 0;
            // Verifica inputs de movimento (teclado e mobile controls)
            if (keys['a'] || keys['arrowleft'] || mobileControls.left) moveX = -1;
            if (keys['d'] || keys['arrowright'] || mobileControls.right) moveX = 1;
            
            let currentSpeed = gameState.playerSpeed;
            // Aplica buffs da Fúria de Umbra
            if (gameState.isUmbraFurious) {
                currentSpeed *= CONFIG.UMBRA_FURY_SPEED_BOOST;
                gameState.umbraFuryTimer -= deltaTime;
                if (gameState.umbraFuryTimer <= 0) {
                    gameState.isUmbraFurious = false; // Desativa Fúria
                    canvas.style.filter = 'none'; // Remove filtro visual
                }
            }

            gameState.playerVelocity.x = moveX * currentSpeed;
            
            // Lógica de salto
            if ((keys['w'] || keys['arrowup'] || keys[' '] || mobileControls.up) && gameState.isGrounded && !gameState.isCrouching) {
                gameState.playerVelocity.y = -CONFIG.JUMP_FORCE;
                gameState.isGrounded = false; // Não está mais no chão
                playSound('sfx_jump');
                addParticles('jumpDust', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT, 8);
                
                // Reseta as flags de input para evitar múltiplos saltos com uma única pressão
                keys['w'] = false; keys['arrowup'] = false; keys[' '] = false; mobileControls.up = false;
            }
            
            // Lógica de agachamento
            if (keys['s'] || keys['arrowdown'] || mobileControls.down) {
                if (!gameState.isCrouching && gameState.isGrounded) {
                    gameState.isCrouching = true;
                    // Ajusta a posição Y para o sprite agachado não "pular"
                    gameState.playerPosition.y += CONFIG.NORMAL_HEIGHT - CONFIG.CROUCH_HEIGHT;
                }
            } else {
                if (gameState.isCrouching) {
                    // Tenta levantar se não houver obstáculos acima
                    const newY = gameState.playerPosition.y - (CONFIG.NORMAL_HEIGHT - CONFIG.CROUCH_HEIGHT);
                    if (canStandUp(gameState.playerPosition.x, newY)) {
                        gameState.isCrouching = false;
                        gameState.playerPosition.y = newY;
                    }
                }
            }
            
            // Aplica gravidade
            gameState.playerVelocity.y += CONFIG.GRAVITY;
            
            // Limita velocidade de queda
            if (gameState.playerVelocity.y > 15) { 
                gameState.playerVelocity.y = 15;
            }
            
            // Atualiza a posição do jogador
            gameState.playerPosition.x += gameState.playerVelocity.x;
            gameState.playerPosition.y += gameState.playerVelocity.y;
            
            // Verifica colisões
            checkPlatformCollisions();
            checkEnemyCollisions();
            checkEffectCollisions();
            checkFallingSpikeCollisions();
            
            // Gerencia o timer de animação de ataque (se estiver atacando, não muda animação)
            if (gameState.animationFrameTimer > 0) {
                gameState.animationFrameTimer -= deltaTime;
                if (gameState.animationFrameTimer <= 0) {
                    gameState.animationFrameTimer = 0;
                    gameState.currentAnimation = 'player_idle'; // Volta para idle após ataque
                }
            } else {
                updatePlayerAnimation(); // Atualiza animação normal (idle, walk, jump, crouch, ultimate)
            }
            
            // Atualiza a direção do jogador
            if (moveX > 0) gameState.facing = 'right';
            if (moveX < 0) gameState.facing = 'left';
            
            // Limites do mundo para o jogador (se a câmera não for fixa)
            if (!gameState.fixedCamera) {
                if (gameState.playerPosition.x < 0) {
                    gameState.playerPosition.x = 0;
                    gameState.playerVelocity.x = 0;
                }
                if (gameState.playerPosition.x > CONFIG.WORLD_WIDTH - CONFIG.PLAYER_SPRITE_WIDTH) {
                    gameState.playerPosition.x = CONFIG.WORLD_WIDTH - CONFIG.PLAYER_SPRITE_WIDTH;
                    gameState.playerVelocity.x = 0;
                    
                    // Transição para encontro com Tarek ao chegar ao fim da fase 1
                    if (gameState.currentPhase === 1) {
                        loadPhase(2);
                    }
                }
            } else { // Limites para câmera fixa (ex: boss fight)
                if (gameState.playerPosition.x < 0) gameState.playerPosition.x = 0;
                if (gameState.playerPosition.x > canvas.width - CONFIG.PLAYER_SPRITE_WIDTH) gameState.playerPosition.x = canvas.width - CONFIG.PLAYER_SPRITE_WIDTH;
            }

            // Queda fatal (abaixo do mundo)
            if (gameState.playerPosition.y > CONFIG.WORLD_HEIGHT + 100) {
                takeDamage(gameState.playerMaxHealth); // Dano letal
            }
            
            // Gerencia o timer de invencibilidade
            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= deltaTime;
                if (gameState.invincibilityTimer <= 0) {
                    gameState.isInvincible = false;
                }
            }
        }

        /**
         * Retorna a hitbox do jogador com base em sua posição e estado (agachado/normal).
         * Considera a proporção real do sprite e a escala da hitbox.
         * @returns {{x: number, y: number, width: number, height: number}} Objeto da hitbox.
         */
        function getPlayerHitbox() {
            const playerVisualWidth = CONFIG.PLAYER_SPRITE_WIDTH;
            // A altura da hitbox depende se o jogador está agachado ou não
            const playerHitboxBaseHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
            
            const hitboxWidth = playerVisualWidth * CONFIG.PLAYER_HITBOX_SCALE_X;
            const hitboxHeight = playerHitboxBaseHeight * CONFIG.PLAYER_HITBOX_SCALE_Y;
            
            // Calcula a posição da hitbox centralizada horizontalmente no sprite visual
            const hitboxX = gameState.playerPosition.x + (playerVisualWidth - hitboxWidth) / 2;
            // Ajusta a posição Y da hitbox para que sua base coincida com a base do sprite visual
            // (considerando que o y do playerPosition é a origem do sprite visual)
            const hitboxY = gameState.playerPosition.y + (playerHitboxBaseHeight - hitboxHeight); 
            
            return { x: hitboxX, y: hitboxY, width: hitboxWidth, height: hitboxHeight };
        }

        /**
         * Verifica se o jogador pode levantar (sair do agachamento) sem colidir com algo acima.
         * @param {number} x - Posição X proposta para o jogador.
         * @param {number} y - Posição Y proposta para o jogador (se levantar).
         * @returns {boolean} True se pode levantar, false caso contrário.
         */
        function canStandUp(x, y) {
            const tempPlayerVisualHeight = CONFIG.PLAYER_SPRITE_HEIGHT; // Altura visual se o jogador levantar
            const tempPlayerHitboxBaseHeight = CONFIG.NORMAL_HEIGHT; // Altura da hitbox se o jogador levantar
            
            const tempHitboxWidth = CONFIG.PLAYER_SPRITE_WIDTH * CONFIG.PLAYER_HITBOX_SCALE_X;
            const tempHitboxHeight = tempPlayerHitboxBaseHeight * CONFIG.PLAYER_HITBOX_SCALE_Y;
            
            const tempHitboxX = x + (CONFIG.PLAYER_SPRITE_WIDTH - tempHitboxWidth) / 2;
            const tempHitboxY = y + (tempPlayerHitboxBaseHeight - tempHitboxHeight);
            
            for (const platform of platforms) {
                if (platform.type === 'spike') continue; // Espinhos não bloqueiam o levantar

                // Verifica colisão entre a hitbox proposta e a plataforma
                if (tempHitboxX < platform.x + platform.width &&
                    tempHitboxX + tempHitboxWidth > platform.x &&
                    tempHitboxY < platform.y + platform.height &&
                    tempHitboxY + tempHitboxHeight > platform.y) {
                    return false; // Há uma colisão se ele levantar
                }
            }
            return true; // Não há colisão, pode levantar
        }

        /**
         * Verifica e resolve colisões do jogador com as plataformas.
         */
        function checkPlatformCollisions() {
            gameState.isGrounded = false;
            const playerHitbox = getPlayerHitbox();
            
            for (const platform of platforms) {
                // Verifica se as hitboxes se sobrepõem
                if (playerHitbox.x < platform.x + platform.width &&
                    playerHitbox.x + playerHitbox.width > platform.x &&
                    playerHitbox.y < platform.y + platform.height &&
                    playerHitbox.y + playerHitbox.height > platform.y) {
                    
                    if (platform.type === 'spike') {
                        takeDamage(10); // Sofre dano ao tocar espinhos
                        continue; // Continua verificando outras colisões, não para
                    }

                    // Colisão pelo topo (pouso em plataforma)
                    // Verifica se o jogador estava acima da plataforma no frame anterior e está caindo
                    if (gameState.playerVelocity.y >= 0 && 
                        (playerHitbox.y + playerHitbox.height - gameState.playerVelocity.y) <= platform.y) {
                        
                        // Ajusta a posição do jogador para cima da plataforma
                        gameState.playerPosition.y = platform.y - playerHitbox.height - (CONFIG.PLAYER_SPRITE_HEIGHT - playerHitbox.height); 
                        gameState.playerVelocity.y = 0; // Zera velocidade vertical
                        gameState.isGrounded = true; // Marca como no chão
                        
                        // Efeitos visuais e sonoros de pouso
                        if (gameState.playerVelocity.y > 8) { // Partículas de poeira se cair rápido
                            addParticles('landDust', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT, 12);
                            screenShake(3, 150);
                        }
                        
                        if (platform.slippery) { // Efeito de plataforma escorregadia
                            gameState.playerVelocity.x *= 1.2; 
                        }
                    }
                    // Colisão por baixo (cabeça batendo em plataforma)
                    else if (gameState.playerVelocity.y < 0 &&
                             (playerHitbox.y - gameState.playerVelocity.y) >= platform.y + platform.height) {
                        gameState.playerPosition.y = platform.y + platform.height - (CONFIG.PLAYER_SPRITE_HEIGHT - playerHitbox.height);
                        gameState.playerVelocity.y = 0; // Zera velocidade vertical
                    }
                    // Colisão lateral
                    else if (gameState.playerVelocity.x !== 0) {
                        if (playerHitbox.x < platform.x) { // Colisão pela esquerda da plataforma
                            gameState.playerPosition.x = platform.x - playerHitbox.width - (CONFIG.PLAYER_SPRITE_WIDTH - playerHitbox.width);
                        } else { // Colisão pela direita da plataforma
                            gameState.playerPosition.x = platform.x + platform.width - (CONFIG.PLAYER_SPRITE_WIDTH - playerHitbox.width);
                        }
                        gameState.playerVelocity.x = 0; // Zera velocidade horizontal
                    }
                }
            }
        }

        /**
         * Verifica e resolve colisões do jogador com inimigos.
         */
        function checkEnemyCollisions() {
            if (gameState.isInvincible) return; // Jogador invencível não sofre dano de contato

            const playerHitbox = getPlayerHitbox();

            for (const enemy of enemies) {
                if (enemy.type === 'boss_dialogue') continue; // Inimigo de diálogo não causa dano

                // Define hitbox do inimigo (usando proporção de sprite)
                const enemySpriteWidth = enemy.type === 'boss' ? 70 : 50;
                const enemySpriteHeight = enemy.type === 'boss' ? 70 : 50;
                const enemyHitboxWidth = enemySpriteWidth * 0.8;
                const enemyHitboxHeight = enemySpriteHeight * 0.9;
                const enemyHitboxX = enemy.position.x + (enemySpriteWidth - enemyHitboxWidth) / 2;
                const enemyHitboxY = enemy.position.y + (enemySpriteHeight - enemyHitboxHeight);

                // Colisão entre hitboxes do jogador e inimigo
                if (playerHitbox.x < enemyHitboxX + enemyHitboxWidth &&
                    playerHitbox.x + playerHitbox.width > enemyHitboxX &&
                    playerHitbox.y < enemyHitboxY + enemyHitboxHeight &&
                    playerHitbox.y + playerHitbox.height > enemyHitboxY) {
                    
                    takeDamage(enemy.damage); // Jogador sofre dano
                    
                    // Aplica knockback ao jogador
                    const knockbackForce = 8;
                    const knockDirection = (playerHitbox.x + playerHitbox.width / 2) > (enemyHitboxX + enemyHitboxWidth / 2) ? 1 : -1;
                    gameState.playerVelocity.x = knockDirection * knockbackForce;
                    gameState.playerVelocity.y = -5; // Pequeno pulo para cima
                    
                    break; // Sai do loop, pois o jogador só pode colidir com um inimigo por vez
                }
            }
        }

        /**
         * Verifica e resolve colisões de efeitos de habilidade com entidades.
         */
        function checkEffectCollisions() {
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                
                // Colisão de efeito do jogador com inimigos
                if (effect.damage && effect.origin === 'player' && effect.active !== false) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        if (enemy.type === 'boss_dialogue') continue; // Efeito não interage com Tarek em diálogo

                        // Se o efeito já atingiu este inimigo (para efeitos piercing ou área que só acertam uma vez por inimigo)
                        if (effect.hitTargets && effect.hitTargets.includes(enemy)) {
                            continue;
                        }
                        
                        // Hitbox do inimigo
                        const enemySpriteWidth = enemy.type === 'boss' ? 70 : 50;
                        const enemySpriteHeight = enemy.type === 'boss' ? 70 : 50;
                        const enemyHitboxWidth = enemySpriteWidth * 0.8;
                        const enemyHitboxHeight = enemySpriteHeight * 0.9;
                        const enemyHitboxX = enemy.position.x + (enemySpriteWidth - enemyHitboxWidth) / 2;
                        const enemyHitboxY = enemy.position.y + (enemySpriteHeight - enemyHitboxHeight);

                        // Hitbox do efeito
                        const effectHitboxX = effect.x; 
                        const effectHitboxY = effect.y;
                        const effectHitboxWidth = effect.width;
                        const effectHitboxHeight = effect.height;

                        // Verifica colisão entre hitboxes
                        if (effectHitboxX < enemyHitboxX + enemyHitboxWidth &&
                            effectHitboxX + effectHitboxWidth > enemyHitboxX &&
                            effectHitboxY < enemyHitboxY + enemyHitboxHeight &&
                            effectHitboxY + effectHitboxHeight > enemyHitboxY) {
                            
                            enemy.health -= effect.damage; // Inimigo sofre dano
                            playSound('sfx_damage_enemy'); // SFX de dano

                            // Adiciona inimigo aos alvos atingidos para evitar múltiplos hits do mesmo efeito (se não for piercing)
                            if (effect.hitTargets) {
                                effect.hitTargets.push(enemy); 
                            }
                            
                            showDamageNumber(effect.damage, enemy.position.x + enemySpriteWidth / 2, enemy.position.y);
                            addParticles('hitSpark', enemy.position.x + enemySpriteWidth / 2, enemy.position.y + enemySpriteHeight / 2, 8);
                            screenShake(2, 100); // Pequeno screen shake

                            // Aplica knockback se definido no efeito
                            if (effect.knockback) {
                                const knockDirection = (enemy.position.x + enemySpriteWidth / 2) - (effect.x + effectHitboxWidth / 2) > 0 ? 1 : -1;
                                enemy.position.x += knockDirection * effect.knockback;
                            }

                            // Aplica status de congelamento se definido
                            if (effect.freezeChance && Math.random() < effect.freezeChance) {
                                enemy.frozen = true;
                                enemy.frozenTimer = 2000;
                            }
                            
                            // Verifica se o inimigo foi derrotado
                            if (enemy.health <= 0) {
                                gainXP(enemy.xpValue); // Jogador ganha XP
                                addParticles('deathExplosion', enemy.position.x + enemySpriteWidth / 2, enemy.position.y + enemySpriteHeight / 2, 20);
                                screenShake(4, 200);
                                enemies.splice(j, 1); // Remove inimigo do array
                                
                                if (enemy.type === 'boss') {
                                    defeatBoss(enemy); // Lógica de derrota de chefe
                                }
                            }
                            
                            // Desativa o efeito se não for piercing ou área (acertou e acabou)
                            if (!effect.piercing && !effect.areaEffect) {
                                effect.active = false; 
                            }
                        }
                    }
                }
                
                // Colisão de efeito do inimigo com o jogador
                if (effect.damage && effect.origin === 'enemy' && !gameState.isInvincible && effect.active !== false) {
                    const playerHitbox = getPlayerHitbox();

                    const effectHitboxX = effect.x;
                    const effectHitboxY = effect.y;
                    const effectHitboxWidth = effect.width;
                    const effectHitboxHeight = effect.height;

                    if (playerHitbox.x < effectHitboxX + effectHitboxWidth &&
                        playerHitbox.x + playerHitbox.width > effectHitboxX &&
                        playerHitbox.y < effectHitboxY + effectHitboxHeight &&
                        playerHitbox.y + playerHitbox.height > effectHitboxY) {
                        
                        takeDamage(effect.damage); // Jogador sofre dano
                        effect.active = false; // Efeito inimigo geralmente desaparece ao acertar
                    }
                }
            }
        }

        /**
         * Atualiza a animação do jogador com base em seu estado atual.
         */
        function updatePlayerAnimation() {
            if (gameState.animationFrameTimer > 0) {
                // Animação de ataque/habilidade está ativa, não mudar para outra animação
                return; 
            }
            if (gameState.isUmbraFurious) {
                gameState.currentAnimation = 'player_ultimate';
            } else if (!gameState.isGrounded) {
                gameState.currentAnimation = 'player_jump';
            } else if (gameState.isCrouching) {
                // Usa animação de agachamento se existir, senão mantém a anterior
                const crouchAsset = assetCache[`player_crouch_${gameState.facing}`];
                gameState.currentAnimation = crouchAsset ? 'player_crouch' : 'player_idle'; 
            } else if (Math.abs(gameState.playerVelocity.x) > 0.1) { // Se movendo horizontalmente
                gameState.currentAnimation = 'player_walk';
            } else {
                gameState.currentAnimation = 'player_idle'; // Parado
            }
        }

        /**
         * Atualiza o estado de todos os inimigos.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Inimigos de diálogo (ex: Tarek antes da luta)
                if (enemy.type === 'boss_dialogue') {
                     // Move Tarek na tela de diálogo para a posição correta
                     if (enemy.name === 'Tarek, o Guerreiro' && gameState.inTarekEncounter) {
                         const targetX = canvas.width - 150;
                         const currentX = enemy.position.x;
                         if (Math.abs(currentX - targetX) > 5) {
                             enemy.position.x += (targetX - currentX) * 0.05 * (deltaTime / 16);
                         } else {
                             enemy.position.x = targetX;
                         }
                     }
                     continue; // Inimigo de diálogo não precisa de física ou IA de combate
                }

                // Inimigos congelados não se movem nem atacam
                if (enemy.frozen) {
                    enemy.frozenTimer -= deltaTime;
                    if (enemy.frozenTimer <= 0) {
                        enemy.frozen = false; // Descongela
                    }
                    // Mantém animação de idle enquanto congelado
                    enemy.currentAnimation = enemy.type === 'sentinel' ? 'sentinel_idle' : 'tarek_idle';
                    continue;
                }
                
                // Gerenciamento do timer de animação do inimigo (se ele estiver em um ataque específico)
                if (enemy.animationTimer > 0) {
                    enemy.animationTimer -= deltaTime;
                    if (enemy.animationTimer <= 0) {
                        enemy.animationTimer = 0;
                        // Volta para idle quando a animação de ataque/habilidade termina
                        enemy.currentAnimation = enemy.type === 'sentinel' ? 'sentinel_idle' : 'tarek_idle';
                    }
                }

                // Lógica específica para cada tipo de inimigo
                if (enemy.type === 'sentinel') {
                    updateEnemyPatrol(enemy, deltaTime);
                    updateEnemyAI(enemy, deltaTime);
                } else if (enemy.type === 'boss') {
                    updateBossAI(enemy, deltaTime);
                }
                
                // Aplica gravidade e move o inimigo
                enemy.velocity = enemy.velocity || { x: 0, y: 0 }; // Inicializa velocity se não existir
                enemy.velocity.y += CONFIG.GRAVITY;
                
                enemy.position.x += enemy.velocity.x;
                enemy.position.y += enemy.velocity.y;
                
                checkEnemyPlatformCollisions(enemy); // Verifica colisão do inimigo com plataformas
            }
        }

        /**
         * Lógica de patrulha para inimigos Sentinela.
         * @param {object} enemy - Objeto do inimigo Sentinela.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateEnemyPatrol(enemy, deltaTime) {
            if (!enemy.patrolStartX) {
                enemy.patrolStartX = enemy.position.x; // Define ponto de partida da patrulha
            }
            
            if (enemy.currentAnimation.includes('attack')) return; // Não patrulha enquanto ataca
            
            // Move o inimigo
            enemy.position.x += enemy.speed * enemy.direction * (deltaTime / 16); 
            
            // Verifica se o inimigo atingiu os limites da patrulha e inverte a direção
            if (enemy.direction === 1 && enemy.position.x > enemy.patrolStartX + enemy.patrolRange) {
                enemy.direction = -1;
            } else if (enemy.direction === -1 && enemy.position.x < enemy.patrolStartX - enemy.patrolRange) {
                enemy.direction = 1;
            }
            // Atualiza a direção visual do inimigo (facing)
            enemy.facing = enemy.direction === 1 ? 'right' : 'left';

            // Define animação de andar se estiver patrulhando, senão idle
            // Sentinelas podem usar animação de idle para patrulha se não houver walk
            if (Math.abs(enemy.velocity.x) > 0.1 || enemy.speed > 0) {
                enemy.currentAnimation = 'sentinel_idle'; 
            }
        }

        /**
         * Lógica de inteligência artificial para inimigos Sentinela.
         * @param {object} enemy - Objeto do inimigo Sentinela.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateEnemyAI(enemy, deltaTime) {
            const playerHitbox = getPlayerHitbox();
            // Distância entre o centro do inimigo e o centro do jogador
            const distanceToPlayer = Math.abs((enemy.position.x + 25) - (playerHitbox.x + playerHitbox.width / 2));
            const playerInRange = distanceToPlayer < 200; // Raio de detecção do jogador
            
            if (playerInRange) {
                enemy.attackCooldown = (enemy.attackCooldown || 0) - deltaTime;
                if (enemy.attackCooldown <= 0) {
                    enemyAttack(enemy); // Inimigo ataca
                    enemy.attackCooldown = 2000 + Math.random() * 1000; // Cooldown de ataque
                    enemy.animationTimer = enemy.animationDuration; // Define duração da animação de ataque
                }
                
                // Persegue o jogador se estiver fora do alcance ideal para ataque corpo a corpo
                if (distanceToPlayer > 60) {
                    const directionToPlayer = (playerHitbox.x + playerHitbox.width / 2) > (enemy.position.x + 25) ? 1 : -1;
                    enemy.position.x += directionToPlayer * enemy.speed * 0.5 * (deltaTime / 16); // Movimento de perseguição
                }
                // Ajusta o facing do inimigo para olhar para o jogador
                enemy.facing = (playerHitbox.x + playerHitbox.width / 2) > (enemy.position.x + 25) ? 'right' : 'left';
            }
        }

        /**
         * Executa o ataque de um inimigo.
         * @param {object} enemy - O inimigo que está atacando.
         */
        function enemyAttack(enemy) {
            const direction = enemy.facing === 'right' ? 1 : -1;
            
            switch(enemy.type) {
                case 'sentinel':
                    enemy.currentAnimation = 'sentinel_attack'; // Define animação de ataque do sentinela
                    addAbilityEffect({
                        type: 'enemyIceShot',
                        x: enemy.position.x + (direction > 0 ? 50 : -25),
                        y: enemy.position.y + 15,
                        width: 20,
                        height: 6,
                        duration: 2000,
                        damage: enemy.damage,
                        direction: direction,
                        speed: 5,
                        origin: 'enemy',
                        asset: 'tarek_ice_orb' // Reutiliza asset do orbe de gelo para tiro do sentinela
                    });
                    addParticles('enemyMuzzle', enemy.position.x + 25, enemy.position.y + 15, 6); // Efeito visual de disparo
                    break;
                // Outros tipos de inimigos podem ter seus ataques definidos aqui
            }
        }

        /**
         * Verifica e resolve colisões de inimigos com as plataformas.
         * @param {object} enemy - O inimigo a ser verificado.
         */
        function checkEnemyPlatformCollisions(enemy) {
            enemy.isGrounded = false;
            // Define as dimensões da hitbox do inimigo
            const enemyWidth = enemy.type === 'boss' ? 70 : 50;
            const enemyHeight = enemy.type === 'boss' ? 70 : 50;
            const enemyHitboxWidth = enemyWidth * 0.8;
            const enemyHitboxHeight = enemyHeight * 0.9;
            const enemyHitboxX = enemy.position.x + (enemyWidth - enemyHitboxWidth) / 2;
            const enemyHitboxY = enemy.position.y + (enemyHeight - enemyHitboxHeight);
            
            for (const platform of platforms) {
                if (platform.type === 'spike') continue; // Inimigos não interagem com espinhos da mesma forma que o player

                // Verifica colisão entre hitboxes do inimigo e plataforma
                if (enemyHitboxX < platform.x + platform.width &&
                    enemyHitboxX + enemyHitboxWidth > platform.x &&
                    enemyHitboxY < platform.y + platform.height &&
                    enemyHitboxY + enemyHitboxHeight > platform.y) {
                    
                    // Colisão por baixo (inimigo pousa)
                    if (enemy.velocity.y > 0 && 
                        (enemyHitboxY + enemyHitboxHeight - enemy.velocity.y) <= platform.y) {
                        enemy.position.y = platform.y - enemyHitboxHeight - (enemyHeight - enemyHitboxHeight); // Ajusta posição
                        enemy.velocity.y = 0;
                        enemy.isGrounded = true;
                    }
                    // Colisão por cima (inimigo bate a cabeça)
                    else if (enemy.velocity.y < 0 &&
                             (enemyHitboxY - enemy.velocity.y) >= platform.y + platform.height) {
                        enemy.position.y = platform.y + platform.height - (enemyHeight - enemyHitboxHeight);
                        enemy.velocity.y = 0;
                    }
                    // Colisão lateral (inimigo bate em parede)
                    else if (enemy.velocity.x !== 0) {
                        if (enemyHitboxX < platform.x) {
                            enemy.position.x = platform.x - enemyHitboxWidth - (enemyWidth - enemyHitboxWidth);
                        } else {
                            enemy.position.x = platform.x + platform.width - (enemyWidth - enemyHitboxWidth);
                        }
                        enemy.velocity.x = 0;
                        // Inverte direção se for um sentinela patrulhando e bater na parede
                        if (enemy.type === 'sentinel') enemy.direction *= -1;
                    }
                }
            }
        }

        /**
         * Atualiza o estado dos efeitos de habilidades (projéteis, áreas de efeito).
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateAbilityEffects(deltaTime) {
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                effect.timer -= deltaTime; // Decrementa o tempo de vida do efeito
                
                switch(effect.type) {
                    case 'energyProjectile': // Projéteis do jogador
                    case 'enemyIceShot':     // Tiros de inimigos Sentinelas
                    case 'bossIceOrb':       // Orbes de gelo do Tarek
                        effect.x += effect.speed * effect.direction * (deltaTime / 16); // Move o projétil
                        if (Math.random() < 0.4) { // Gera partículas de trilha
                            let trailColor;
                            if (effect.type === 'bossIceOrb') trailColor = COLOR_ACCENT_ICE;
                            else trailColor = COLOR_ACCENT_BLUE; 
                            addParticles('projectileTrail', effect.x + effect.width/2, effect.y + effect.height/2, 2, trailColor);
                        }
                        break;
                    case 'bossDash': // Investida do Tarek
                        if (effect.followBoss && effect.followBoss.position) {
                            effect.x = effect.followBoss.position.x; // Efeito segue o boss
                            effect.y = effect.followBoss.position.y;
                        }
                        break;
                    case 'bossPrison': // Prisão de Gelo do Tarek
                        if (effect.delay && effect.delay > 0) { // Efeito com delay antes de ativar
                            effect.delay -= deltaTime;
                            if (effect.delay <= 0) {
                                effect.active = true;
                                addParticles('prisonActivate', effect.x + effect.width/2, effect.y + effect.height/2, 20); // Partículas ao ativar
                            }
                        }
                        if (effect.trapping && effect.active) { // Se o efeito está ativo e é uma armadilha
                            const playerHitbox = getPlayerHitbox();
                            // Verifica se o jogador está dentro da prisão
                            const playerInTrap = 
                                playerHitbox.x < effect.x + effect.width && playerHitbox.x + playerHitbox.width > effect.x &&
                                playerHitbox.y < effect.y + effect.height && playerHitbox.y + playerHitbox.height > effect.y;
                            
                            if (playerInTrap) {
                                gameState.playerVelocity.x *= 0.1; // Reduz movimento do jogador
                                gameState.playerVelocity.y *= 0.1;
                                
                                if (Math.random() < 0.05) { // Causa dano periódico
                                    takeDamage(effect.damage * (deltaTime / 1000));
                                }
                            }
                        }
                        break;
                    case 'chargeAttack': // Investida do Escolhido
                        // O dano é aplicado na colisão com checkEffectCollisions. Aqui, apenas gera partículas
                        addParticles('dashEffect', effect.x + effect.width / 2, effect.y + effect.height / 2, 5);
                        break;
                }
                
                // Remove o efeito se o tempo de vida acabou ou se ele foi desativado
                if (effect.timer <= 0 || effect.active === false) {
                    abilityEffects.splice(i, 1);
                }
            }
        }

        /**
         * Atualiza o estado das partículas visuais.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                particle.x += particle.vx * (deltaTime / 16); // Movimento horizontal
                particle.y += particle.vy * (deltaTime / 16); // Movimento vertical
                
                if (particle.gravity) { // Aplica gravidade se a partícula tiver
                    particle.vy += CONFIG.GRAVITY * 0.3;
                }
                
                particle.life -= deltaTime; // Diminui o tempo de vida
                
                // Diminui a opacidade perto do fim da vida
                if (particle.life < particle.maxLife * 0.3) {
                    particle.alpha = particle.life / (particle.maxLife * 0.3);
                }
            }
            /* Remove partículas mortas e limita o número total de partículas */
            particles = particles.filter(p => p.life > 0);
            if (particles.length > CONFIG.MAX_PARTICLES) {
                particles.splice(0, particles.length - CONFIG.MAX_PARTICLES); /* Remove as partículas mais antigas */
            }
            
            // Gera partículas de neve se o jogo não estiver no menu ou pausado
            if (!gameState.inMenu && !gameState.gamePaused) {
                if (Math.random() < CONFIG.SNOW_SPAWN_RATE) {
                    // Adiciona partículas de neve em relação à câmera
                    addParticles('snow', gameState.cameraOffset.x + Math.random() * canvas.width, -10 + gameState.cameraOffset.y, 1);
                }
            }
        }

        /**
         * Atualiza a visibilidade e animação dos números de dano/XP flutuantes.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateDamageNumbers(deltaTime) {
            const damageContainer = document.getElementById('particle-container');
            const existingNumbers = damageContainer.querySelectorAll('.damage-number, .xp-number');
            
            existingNumbers.forEach(number => {
                const timeLeft = parseFloat(number.dataset.timeLeft) - deltaTime;
                number.dataset.timeLeft = timeLeft;
                
                if (timeLeft <= 0) {
                    number.remove(); // Remove o elemento DOM quando o tempo acaba
                }
            });
        }

        /**
         * Atualiza os cooldowns das habilidades do jogador.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateCooldowns(deltaTime) {
            for (const key in gameState.abilitiesCooldown) {
                if (gameState.abilitiesCooldown[key] > 0) {
                    gameState.abilitiesCooldown[key] -= deltaTime / 1000; // Converte ms para segundos
                    updateCooldownVisual(key); // Atualiza a barra visual de cooldown
                }
            }
        }

        /**
         * Atualiza a representação visual do cooldown de uma habilidade.
         * @param {string} key - A chave da habilidade (U, I, O, P).
         */
        function updateCooldownVisual(key) {
            const btn = document.getElementById(`ability-${key.toLowerCase()}`);
            const overlay = btn?.querySelector('.cooldown-overlay');
            
            if (btn && overlay) {
                const cooldownRatio = gameState.abilitiesCooldown[key] / gameState.abilitiesMaxCooldown[key];
                
                if (cooldownRatio > 0) {
                    btn.classList.add('cooldown'); // Adiciona classe para estilo de cooldown
                    // Atualiza a barra de cooldown (efeito cônico)
                    const angle = 360 * (1 - cooldownRatio);
                    overlay.style.background = `conic-gradient(from 0deg, transparent ${angle}deg, rgba(0, 0, 0, 0.8) ${angle}deg)`;
                } else {
                    btn.classList.remove('cooldown'); // Remove estilo de cooldown
                    overlay.style.background = ''; // Reseta o background
                }
            }
        }

        /**
         * Atualiza a regeneração de mana e vida do jogador.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateRegeneration(deltaTime) {
            // Regeneração de mana
            if (gameState.playerMana < gameState.playerMaxMana) {
                gameState.playerMana += CONFIG.MANA_REGEN_RATE * (deltaTime / 1000);
                gameState.playerMana = Math.min(gameState.playerMana, gameState.playerMaxMana); // Limita ao máximo
                updateManaBar();
            }
            
            // Regeneração de vida (fora de invencibilidade)
            if (gameState.playerHealth < gameState.playerMaxHealth && !gameState.isInvincible) {
                gameState.playerHealth += CONFIG.HEALTH_REGEN_RATE * (deltaTime / 1000);
                gameState.playerHealth = Math.min(gameState.playerHealth, gameState.playerMaxHealth);
                updateHealthBar();
            }
        }

        /**
         * Atualiza a posição da câmera do jogo.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateCamera(deltaTime) {
            if (gameState.fixedCamera) { // Câmera fixa (ex: boss fight)
                gameState.cameraOffset.x = gameState.fixedCameraTarget.x;
                gameState.cameraOffset.y = gameState.fixedCameraTarget.y;
                return;
            }

            // Calcula o alvo da câmera centralizando no jogador
            gameState.targetCameraOffset.x = gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2 - canvas.width / 2;
            gameState.targetCameraOffset.y = gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2 - canvas.height / 2;
            
            // Limita a câmera aos limites do mundo
            gameState.targetCameraOffset.x = Math.max(0, Math.min(gameState.targetCameraOffset.x, CONFIG.WORLD_WIDTH - canvas.width));
            // A câmera não deve ir abaixo do chão (y=WORLD_HEIGHT)
            gameState.targetCameraOffset.y = Math.max(0, Math.min(gameState.targetCameraOffset.y, CONFIG.WORLD_HEIGHT - canvas.height)); 

            // Suavização da câmera (movimento gradual)
            gameState.cameraOffset.x += (gameState.targetCameraOffset.x - gameState.cameraOffset.x) * CONFIG.CAMERA_SMOOTHING;
            gameState.cameraOffset.y += (gameState.targetCameraOffset.y - gameState.cameraOffset.y) * CONFIG.CAMERA_SMOOTHING;
        }

        /**
         * Atualiza o estado dos espinhos que caem.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateFallingSpikes(deltaTime) {
            for (let i = fallingSpikes.length - 1; i >= 0; i--) {
                const spike = fallingSpikes[i];
                
                // Ativa o espinho quando o jogador se aproxima (abaixo dele)
                if (!spike.active &&
                    gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH > spike.x - 100 && 
                    gameState.playerPosition.x < spike.x + spike.width + 100 &&
                    gameState.playerPosition.y < spike.y + 100) { // Ativa quando o jogador está abaixo do espinho, mas não muito longe
                    spike.active = true;
                }
                
                if (spike.active) {
                    spike.y += spike.speed * (deltaTime / 16); // Move o espinho para baixo
                    
                    if (spike.y > CONFIG.WORLD_HEIGHT + 100) { // Remove o espinho se ele cair muito
                        fallingSpikes.splice(i, 1);
                    }
                }
            }
        }

        /**
         * Verifica colisões do jogador com espinhos que caem.
         */
        function checkFallingSpikeCollisions() {
            if (gameState.isInvincible) return; // Jogador invencível não sofre dano
            
            const playerHitbox = getPlayerHitbox();
            
            for (const spike of fallingSpikes) {
                if (!spike.active) continue; // Só verifica espinhos ativos
                
                // Colisão entre hitbox do jogador e espinho
                if (playerHitbox.x < spike.x + spike.width &&
                    playerHitbox.x + playerHitbox.width > spike.x &&
                    playerHitbox.y < spike.y + spike.height &&
                    playerHitbox.y + playerHitbox.height > spike.y) {
                    
                    takeDamage(15); // Jogador sofre dano
                    addParticles('hitSpark', spike.x + spike.width/2, spike.y + spike.height/2, 10);
                    // Remove o espinho após o hit para evitar hits múltiplos e para simular quebrou
                    const index = fallingSpikes.indexOf(spike);
                    if (index > -1) {
                        fallingSpikes.splice(index, 1);
                    }
                    break; 
                }
            }
        }

        /**
         * Verifica se o jogador atingiu um checkpoint e salva o progresso.
         */
        function checkCheckpoints() {
            const playerHitbox = getPlayerHitbox();
            
            for (const checkpoint of checkpoints) {
                // Verifica colisão com o checkpoint
                if (playerHitbox.x < checkpoint.x + checkpoint.width &&
                    playerHitbox.x + playerHitbox.width > checkpoint.x &&
                    playerHitbox.y < checkpoint.y + checkpoint.height &&
                    playerHitbox.y + playerHitbox.height > checkpoint.y) {
                    
                    // Salva o checkpoint apenas se for um novo
                    if (gameState.currentCheckpoint !== checkpoint.name) {
                        saveCheckpoint(checkpoint.name);
                    }
                    break;
                }
            }
        }

        /**
         * Verifica condições de fim de jogo (e.g., vida do jogador <= 0).
         */
        function checkGameConditions() {
            if (gameState.playerHealth <= 0) {
                gameOver();
            }
        }

        // =========================================================
        //  12. SISTEMA DE HABILIDADES
        // =========================================================

        /**
         * Ativa uma habilidade do jogador.
         * @param {string} key - A chave da habilidade (U, I, O, P).
         */
        function useAbility(key) {
            const ability = gameState.chosenOneAbilities.find(a => a.key === key);
            // Verifica se a habilidade existe e não está em cooldown
            if (!ability || gameState.abilitiesCooldown[key] > 0) return;
            
            // Verifica custo de mana
            if (gameState.playerMana < ability.manaCost) {
                flashScreen(COLOR_MANA, 200); // Feedback visual de mana insuficiente
                return;
            }
            
            gameState.playerMana -= ability.manaCost; // Consome mana
            gameState.abilitiesCooldown[key] = ability.cooldown; // Inicia cooldown

            // Ativa a animação de ataque do jogador
            gameState.currentAnimation = ability.animation;
            gameState.animationFrameTimer = gameState.animationDuration; // Define a duração da animação no timer global

            // Se for Ultimate, ajusta a duração da animação para um tempo mais longo (duração do buff)
            if (key === 'P') {
                gameState.animationFrameTimer = CONFIG.UMBRA_FURY_DURATION;
            }

            ability.execute(); // Executa a lógica específica da habilidade
            updateManaBar(); // Atualiza a barra de mana
        }

        /**
         * Adiciona um efeito de habilidade (projétil, área de efeito, etc.) ao jogo.
         * @param {object} effect - Objeto que descreve o efeito.
         */
        function addAbilityEffect(effect) {
            effect.timer = effect.duration || 1000; // Tempo de vida do efeito
            effect.origin = effect.origin || 'player'; // Quem criou o efeito (player/enemy)
            effect.active = effect.active !== false; // Se o efeito está ativo
            effect.hitTargets = effect.hitTargets || []; // Lista de alvos já atingidos pelo efeito (para piercing/área)
            
            abilityEffects.push(effect);
        }

        // =========================================================
        //  13. SISTEMA DE PARTÍCULAS
        // =========================================================

        /**
         * Adiciona múltiplas partículas de um tipo específico.
         * @param {string} type - Tipo de partícula (ex: 'snow', 'hitSpark').
         * @param {number} x - Posição X de origem.
         * @param {number} y - Posição Y de origem.
         * @param {number} count - Número de partículas a gerar.
         * @param {string} [color=null] - Cor personalizada para as partículas.
         */
        function addParticles(type, x, y, count, color = null) {
            for (let i = 0; i < count; i++) {
                const particle = createParticle(type, x, y, color);
                particles.push(particle);
            }
        }

        /**
         * Cria um objeto de partícula individual com propriedades específicas para seu tipo.
         * @param {string} type - Tipo de partícula.
         * @param {number} x - Posição X de origem.
         * @param {number} y - Posição Y de origem.
         * @param {string} [customColor=null] - Cor personalizada.
         * @returns {object} Objeto da partícula.
         */
        function createParticle(type, x, y, customColor = null) {
            const baseParticle = {
                x: x + (Math.random() - 0.5) * 20, // Posição aleatória levemente dispersa
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 4, // Velocidade X aleatória
                vy: (Math.random() - 0.5) * 4, // Velocidade Y aleatória
                size: 2 + Math.random() * 3, // Tamanho aleatório
                alpha: 1, // Opacidade inicial
                gravity: false, // Se a partícula é afetada pela gravidade
                type: type, // Tipo da partícula
                asset: null // Asset de imagem se houver
            };
            
            switch(type) {
                case 'snow':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: 1 + Math.random() * 2,
                        size: 2 + Math.random() * 4,
                        color: customColor || '#ffffff',
                        life: 8000 + Math.random() * 4000, // Vida longa para neve
                        maxLife: 12000
                    };
                case 'jumpDust': // Poeira ao pular
                case 'landDust': // Poeira ao pousar
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -1 - Math.random() * 2,
                        color: customColor || '#aaaaaa',
                        life: 400 + Math.random() * 200,
                        maxLife: 600,
                        gravity: true // Afetada pela gravidade
                    };
                case 'hitSpark': // Faíscas ao atingir
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        color: customColor || '#ffff00',
                        life: 300 + Math.random() * 200,
                        maxLife: 500
                    };
                case 'deathExplosion': // Explosão ao morrer (inimigo)
                case 'explosion': // Explosão genérica
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: customColor || (Math.random() > 0.5 ? COLOR_ACCENT_FIRE : COLOR_ACCENT_GOLD),
                        life: 800 + Math.random() * 400,
                        maxLife: 1200,
                        size: 3 + Math.random() * 5,
                        asset: 'explosion_general' // Usa um GIF para a explosão
                    };
                case 'projectileTrail': // Trilha de projéteis
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        color: customColor || COLOR_ACCENT_BLUE,
                        life: 300 + Math.random() * 200,
                        maxLife: 500,
                        size: 1 + Math.random() * 2
                    };
                case 'umbraFuria': // Partículas da Ultimate
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        color: customColor || COLOR_ACCENT_GOLD,
                        life: 500 + Math.random() * 300,
                        maxLife: 800,
                        size: 3 + Math.random() * 4,
                        gravity: false
                    };
                case 'bossIntro': // Partículas na intro do boss
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        color: customColor || COLOR_ACCENT_FIRE,
                        life: 1000 + Math.random() * 500,
                        maxLife: 1500,
                        size: 4 + Math.random() * 6
                    };
                case 'dashEffect': // Partículas para a Investida do Escolhido
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 4,
                        color: customColor || COLOR_ACCENT_ICE,
                        life: 400 + Math.random() * 300,
                        maxLife: 700
                    };
                case 'prisonActivate': // Partículas ao ativar Prisão de Gelo
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 3,
                        vy: (Math.random() - 0.5) * 3,
                        color: customColor || COLOR_ACCENT_ICE,
                        life: 200 + Math.random() * 100,
                        maxLife: 300,
                        size: 5 + Math.random() * 5
                    };
                case 'xpGain': // Partículas ao ganhar XP
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -2 - Math.random() * 2,
                        color: customColor || COLOR_XP,
                        life: 800 + Math.random() * 400,
                        maxLife: 1200,
                        size: 3 + Math.random() * 3,
                        gravity: true
                    };
                case 'enemyMuzzle': // Efeito de disparo de inimigo
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        color: customColor || COLOR_ACCENT_FIRE,
                        life: 100 + Math.random() * 50,
                        maxLife: 150,
                        size: 2 + Math.random() * 2,
                        gravity: false
                    };
                default:
                    return { ...baseParticle, color: customColor || '#ffffff', life: 500, maxLife: 500 };
            }
        }

        // =========================================================
        //  14. SISTEMA DE DANO, COMBATE E PROGRESSÃO (XP, LEVEL UP)
        // =========================================================

        /**
         * Aplica dano ao jogador.
         * @param {number} amount - Quantidade de dano a ser aplicado.
         */
        function takeDamage(amount) {
            if (gameState.isInvincible) return; // Jogador invencível não sofre dano
            
            let finalDamage = amount;
            // Aplica redução de dano se estiver na Fúria de Umbra
            if (gameState.isUmbraFurious) { 
                finalDamage *= CONFIG.UMBRA_FURY_DAMAGE_REDUCTION;
            }

            gameState.playerHealth -= finalDamage;
            gameState.playerHealth = Math.max(0, gameState.playerHealth); // Vida não pode ser negativa
            
            playSound('sfx_damage_player');
            
            gameState.isInvincible = true; // Inicia invencibilidade temporária
            gameState.invincibilityTimer = CONFIG.INVINCIBILITY_DURATION;
            
            flashScreen(COLOR_HEALTH, CONFIG.DAMAGE_FLASH_DURATION); // Efeito de tela vermelha
            screenShake(5, 300); // Screen shake
            showDamageNumber(finalDamage, gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y, true); // Número de dano
            
            updateHealthBar(); // Atualiza barra de vida na UI
            
            if (gameState.playerHealth <= 0) {
                gameOver(); // Game Over se a vida chegar a zero
            }
        }

        /**
         * Exibe um número flutuante de dano ou XP.
         * @param {number} value - Valor do dano/XP.
         * @param {number} x - Posição X onde o número deve aparecer.
         * @param {number} y - Posição Y onde o número deve aparecer.
         * @param {boolean} [isPlayerDamage=false] - True se for dano ao jogador, muda a cor.
         */
        function showDamageNumber(value, x, y, isPlayerDamage = false) {
            const container = document.getElementById('particle-container');
            const element = document.createElement('div');
            
            element.className = isPlayerDamage ? 'damage-number' : 'xp-number'; // Usa classes diferentes para CSS
            element.textContent = isPlayerDamage ? Math.round(value) : `+${Math.round(value)} XP`;
            // Posiciona o elemento HTML em relação ao canvas e offset da câmera
            element.style.left = (x - gameState.cameraOffset.x) + 'px';
            element.style.top = (y - gameState.cameraOffset.y) + 'px';
            element.style.color = isPlayerDamage ? COLOR_HEALTH : COLOR_TEXT_LIGHT; // Cor do dano/XP
            element.dataset.timeLeft = '1000'; // Duração em ms para ser removido (controlado por updateDamageNumbers)
            
            container.appendChild(element);
        }

        /**
         * Concede XP ao jogador.
         * @param {number} amount - Quantidade de XP a ser concedida.
         */
        function gainXP(amount) {
            gameState.playerXP += amount;
            
            showDamageNumber(amount, gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y - 20, false); // Mostra XP flutuante
            addParticles('xpGain', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2, 8, COLOR_XP); // Partículas de XP
            
            if (gameState.playerXP >= gameState.playerNextLevelXP) {
                levelUp(); // Chama level up se XP suficiente
            }
            
            updateXPBar(); // Atualiza barra de XP na UI
            updatePlayerStats(); // Atualiza stats na UI
        }

        /**
         * Aumenta o nível do jogador e exibe o menu de melhorias.
         */
        function levelUp() {
            playSound('sfx_level_up');
            gameState.playerLevel++;
            gameState.playerXP -= gameState.playerNextLevelXP; // Remove XP excedente
            gameState.playerNextLevelXP = Math.floor(gameState.playerNextLevelXP * 1.5); // Aumenta XP necessário para o próximo nível
            
            flashScreen(COLOR_XP, 500); // Efeito visual de level up
            addParticles('umbraFuria', gameState.playerPosition.x + CONFIG.PLAYER_SPRITE_WIDTH / 2, gameState.playerPosition.y + CONFIG.PLAYER_SPRITE_HEIGHT / 2, 30); // Partículas especiais
            
            showLevelUpMenu(); // Mostra o menu de escolhas de melhoria
        }

        /**
         * Mostra o menu de level up.
         */
        function showLevelUpMenu() {
            const levelUpMenu = document.getElementById('level-up');
            levelUpMenu.style.display = 'block';
            levelUpMenu.style.animation = 'levelUpAnimation 0.8s forwards'; // Animação de aparição
            gameState.gamePaused = true; // Pausa o jogo durante a escolha
        }

        /**
         * Aplica a melhoria escolhida pelo jogador.
         * @param {string} upgradeType - Tipo de melhoria ('health', 'mana', 'damage', 'speed').
         */
        function applyUpgrade(upgradeType) {
            switch(upgradeType) {
                case 'health':
                    gameState.playerMaxHealth += 25;
                    gameState.playerHealth = gameState.playerMaxHealth; // Cura completa
                    break;
                case 'mana':
                    gameState.playerMaxMana += 35;
                    gameState.playerMana = gameState.playerMaxMana; // Mana completa
                    CONFIG.MANA_REGEN_RATE *= 1.5; // Aumenta regeneração
                    break;
                case 'damage':
                    gameState.playerDamage += 8;
                    break;
                case 'speed':
                    gameState.playerSpeed += 0.8;
                    // Reduz cooldowns em 15% para todas as habilidades
                    for (const key in gameState.abilitiesMaxCooldown) {
                        gameState.abilitiesMaxCooldown[key] *= 0.85;
                    }
                    break;
            }
            
            document.getElementById('level-up').style.display = 'none'; // Esconde o menu
            gameState.gamePaused = false; // Despausa o jogo
            
            updateAllUI(); // Atualiza todas as UIs para refletir as melhorias
            saveProgress(); // Salva o progresso após a melhoria
        }

        // =========================================================
        //  15. BOSS FIGHT - TAREK
        // =========================================================

        /**
         * Inicia a luta contra o chefe Tarek.
         */
        function triggerBossFight() {
            gameState.inBossFight = true; // Ativa flag de boss fight
            gameState.fixedCamera = true; // Câmera fixa na arena
            
            playSound('sfx_boss_roar'); // SFX de rugido do boss

            // Objeto Tarek (chefe)
            const tarek = {
                type: 'boss',
                name: 'Tarek, o Guerreiro',
                position: { x: canvas.width - 150, y: 300 }, // Posição inicial
                facing: 'left',
                health: 500, // Vida do boss
                maxHealth: 500,
                damage: 25, // Dano de contato
                speed: 1.5, // Velocidade de movimento
                velocity: { x: 0, y: 0 },
                isGrounded: false,
                xpValue: 500, // XP ao derrotar
                currentAnimation: 'tarek_idle', 
                animationTimer: 0,
                animationDuration: 500, // Duração padrão para animações de Tarek
                
                aiState: 'combat', // Estado inicial da IA
                aiTimer: 0,
                attackCooldown: 0, // Cooldown geral para ataques
                lastAttack: 0, // Timestamp do último ataque
                enraged: false, // Se Tarek está enfurecido
                
                abilities: [
                    { name: 'Golpe Devastador', cooldown: 3000, range: 80, damage: 35, animation: 'tarek_ability1', lastUsed: 0 },
                    { name: 'Investida Gélida', cooldown: 6000, range: 300, damage: 45, animation: 'tarek_ability2', lastUsed: 0 },
                    { name: 'Orbe Congelante', cooldown: 5000, range: 400, damage: 30, animation: 'tarek_ability3', lastUsed: 0 },
                    { name: 'Prisão de Gelo', cooldown: 10000, range: 200, damage: 20, animation: 'tarek_ability4', lastUsed: 0 }
                ]
            };
            
            enemies.push(tarek); // Adiciona Tarek ao array de inimigos
            
            document.getElementById('boss-name').style.display = 'block'; // Mostra nome do boss
            document.getElementById('boss-health-bar').style.display = 'block'; // Mostra barra de vida do boss
            updateBossHealthBar(tarek); // Atualiza a barra de vida

            saveCheckpoint('tarek_fight_start'); // Salva um checkpoint no início da luta
            
            screenShake(8, 500); // Screen shake forte
            flashScreen(COLOR_ACCENT_FIRE, 300); // Flash vermelho
            addParticles('bossIntro', tarek.position.x + 35, tarek.position.y + 35, 40); // Partículas de introdução
        }

        /**
         * Atualiza a inteligência artificial do chefe Tarek.
         * @param {object} boss - Objeto do chefe Tarek.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function updateBossAI(boss, deltaTime) {
            const playerHitbox = getPlayerHitbox();
            const distanceToPlayer = Math.abs((boss.position.x + 35) - (playerHitbox.x + playerHitbox.width / 2));
            const currentTime = Date.now();
            
            // Limites de movimento do boss na arena
            const arenaLeft = 50;
            const arenaRight = canvas.width - 120;
            if (boss.position.x < arenaLeft) {
                boss.position.x = arenaLeft;
                boss.velocity.x = 0;
            }
            if (boss.position.x > arenaRight) {
                boss.position.x = arenaRight;
                boss.velocity.x = 0;
            }
            
            // Estado de enfurecimento (enrage) de Tarek
            if (boss.health < boss.maxHealth * 0.4 && !boss.enraged) {
                boss.enraged = true;
                boss.speed *= 1.3; // Aumenta velocidade
                boss.damage *= 1.1; // Aumenta dano
                boss.abilities.forEach(ab => ab.cooldown *= 0.8); // Reduz cooldowns

                flashScreen(COLOR_ACCENT_FIRE, 500);
                addParticles('bossIntro', boss.position.x + 35, boss.position.y + 35, 50);

                showDialog("TAREK", "Você... é mais forte do que pensei! Mas não vou cair facilmente!", []);
            }
            
            // Verifica se as habilidades de Tarek estão prontas (fora de cooldown)
            boss.abilities.forEach(ability => {
                ability.ready = (currentTime - (ability.lastUsed || 0)) >= ability.cooldown;
            });
            
            boss.aiTimer += deltaTime;
            
            switch(boss.aiState) {
                case 'combat':
                    let chosenAbility = null;
                    // Lógica para escolher a habilidade de Tarek com base na distância e disponibilidade
                    if (distanceToPlayer < boss.abilities[0].range && boss.abilities[0].ready) {
                        chosenAbility = boss.abilities[0]; // Golpe Devastador (curto alcance)
                    } else if (distanceToPlayer > 100 && distanceToPlayer < boss.abilities[1].range && boss.abilities[1].ready) {
                        chosenAbility = boss.abilities[1]; // Investida Gélida (médio alcance)
                    } else if (distanceToPlayer > 150 && boss.abilities[2].ready) {
                        chosenAbility = boss.abilities[2]; // Orbe Congelante (longo alcance)
                    } else if (boss.abilities[3].ready && Math.random() < 0.3) { // Prisão de Gelo (chance menor)
                        chosenAbility = boss.abilities[3];
                    }
                    
                    if (chosenAbility && boss.aiTimer > 500) { // Se escolheu uma habilidade e passou um tempo mínimo entre ações
                        executeBossAbility(boss, chosenAbility); // Executa a habilidade
                        boss.currentAnimation = chosenAbility.animation; // Ativa animação de ataque do Tarek
                        boss.animationTimer = boss.animationDuration; // Define duração da animação
                        boss.aiState = 'attacking'; // Muda estado para atacando
                        boss.aiTimer = 0;
                    } else {
                        moveBossTowardsPlayer(boss, distanceToPlayer, deltaTime); // Move Tarek em direção ao jogador
                        // Animação de idle/walk enquanto se move
                        if (Math.abs(boss.velocity.x) > 0.1) {
                            boss.currentAnimation = 'tarek_walk';
                        } else {
                            boss.currentAnimation = 'tarek_idle';
                        }
                    }
                    break;
                    
                case 'attacking':
                    // Permite que a animação de ataque termine antes de voltar ao combate
                    if (boss.aiTimer > boss.animationDuration) { 
                        boss.aiState = 'combat';
                        boss.aiTimer = 0;
                        boss.currentAnimation = 'tarek_idle'; 
                    }
                    break;
            }
            updateBossHealthBar(boss); // Atualiza a barra de vida do boss na UI
        }

        /**
         * Move o chefe Tarek em direção ao jogador, incluindo lógica de salto se necessário.
         * @param {object} boss - Objeto do chefe Tarek.
         * @param {number} distance - Distância entre Tarek e o jogador.
         * @param {number} deltaTime - Tempo decorrido.
         */
        function moveBossTowardsPlayer(boss, distance, deltaTime) {
            const playerHitbox = getPlayerHitbox();
            if (distance > 50) { // Se o jogador não estiver muito perto
                const direction = (playerHitbox.x + playerHitbox.width / 2) > (boss.position.x + 35) ? 1 : -1;
                boss.position.x += direction * boss.speed * (deltaTime / 16);
                boss.facing = direction === 1 ? 'right' : 'left'; // Tarek olha para o jogador

                // Lógica de salto para Tarek (se o jogador estiver muito acima e Tarek estiver no chão)
                if (boss.isGrounded && playerHitbox.y < boss.position.y - 50 && boss.isGrounded) {
                    boss.velocity.y = -CONFIG.JUMP_FORCE * 0.8; // Salto
                    boss.isGrounded = false;
                    boss.currentAnimation = 'tarek_jump'; // Animação de salto
                    boss.animationTimer = boss.animationDuration;
                }
            } else { // Se o jogador estiver perto, Tarek para de se mover
                boss.velocity.x = 0;
            }
        }

        /**
         * Executa uma habilidade específica do chefe Tarek.
         * @param {object} boss - Objeto do chefe Tarek.
         * @param {object} ability - Objeto da habilidade a ser executada.
         */
        function executeBossAbility(boss, ability) {
            const direction = boss.facing === 'right' ? 1 : -1;
            ability.lastUsed = Date.now(); // Registra o uso para o cooldown
            
            switch(ability.name) {
                case 'Golpe Devastador':
                    addAbilityEffect({
                        type: 'bossSlash',
                        x: boss.position.x + (direction > 0 ? 70 : -50),
                        y: boss.position.y + 10,
                        width: 70,
                        height: 30,
                        duration: 300,
                        damage: ability.damage,
                        origin: 'enemy',
                        knockback: 20
                    });
                    screenShake(6, 300);
                    break;
                case 'Investida Gélida':
                    boss.velocity.x = direction * 10; // Impulso para a investida
                    addAbilityEffect({
                        type: 'bossDash',
                        x: boss.position.x,
                        y: boss.position.y,
                        width: 70,
                        height: 50,
                        duration: 800,
                        damage: ability.damage,
                        origin: 'enemy',
                        followBoss: boss // Efeito segue o boss
                    });
                    addParticles('dashEffect', boss.position.x + 35, boss.position.y + 35, 30);
                    screenShake(8, 400);
                    break;
                case 'Orbe Congelante':
                    addAbilityEffect({
                        type: 'bossIceOrb',
                        x: boss.position.x + (direction > 0 ? 80 : -30),
                        y: boss.position.y + 20,
                        width: 40,
                        height: 40,
                        duration: 3000,
                        damage: ability.damage,
                        direction: direction,
                        speed: 4,
                        origin: 'enemy',
                        asset: 'tarek_ice_orb'
                    });
                    break;
                case 'Prisão de Gelo':
                    // Cria 3 paredes de gelo em torno do jogador
                    for (let i = 0; i < 3; i++) {
                        const offsetX = (i - 1) * 80; // Posição relativa ao jogador
                        addAbilityEffect({
                            type: 'bossPrison',
                            x: gameState.playerPosition.x + offsetX - 15,
                            y: gameState.playerPosition.y - 60, // Aparece acima do jogador
                            width: 30,
                            height: 120,
                            duration: 5000,
                            damage: ability.damage,
                            origin: 'enemy',
                            trapping: true, // Indica que é uma armadilha
                            delay: i * 200, // Pequeno atraso entre as paredes
                            active: false, // Começa inativo, ativa após o delay
                            asset: 'tarek_prison_wall'
                        });
                    }
                    screenShake(5, 600);
                    break;
            }
        }

        /**
         * Atualiza a barra de vida do chefe Tarek na UI.
         * @param {object} boss - Objeto do chefe Tarek.
         */
        function updateBossHealthBar(boss) {
            const healthFill = document.getElementById('boss-health-fill');
            const healthPercentage = (boss.health / boss.maxHealth) * 100;
            healthFill.style.width = healthPercentage + '%';
            
            // Muda a cor da barra de vida conforme a porcentagem
            if (healthPercentage > 60) {
                healthFill.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
            } else if (healthPercentage > 30) {
                healthFill.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, #f44336, #e53935)';
            }
        }

        /**
         * Lógica para quando o chefe Tarek é derrotado.
         * @param {object} boss - Objeto do chefe Tarek.
         */
        function defeatBoss(boss) {
            gameState.bossDefeated = true; // Marca boss como derrotado
            gameState.inBossFight = false; // Sai do estado de boss fight
            
            stopMusic(); // Para a música do boss
            
            document.getElementById('boss-name').style.display = 'none'; // Esconde nome do boss
            document.getElementById('boss-health-bar').style.display = 'none'; // Esconde barra de vida do boss
            
            flashScreen(COLOR_ACCENT_GOLD, 800); // Flash dourado
            screenShake(10, 1000); // Screen shake intenso
            addParticles('deathExplosion', boss.position.x + 35, boss.position.y + 35, 60); // Grande explosão
            
            gainXP(boss.xpValue); // Ganha XP ao derrotar o boss
            
            // Remove Tarek do array de inimigos
            const bossIndex = enemies.indexOf(boss);
            if (bossIndex > -1) {
                enemies.splice(bossIndex, 1);
            }
            
            // Sequência de diálogo pós-luta e tela de vitória
            setTimeout(() => {
                showDialog(
                    "TAREK",
                    `Impressionante, ${gameState.playerName}... Você realmente tem a força de um Escolhido. Pode passar, mas saiba que desafios ainda maiores o aguardam adiante.`,
                    [
                        {
                            text: "Obrigado pela luta honrosa, Tarek.",
                            action: () => {
                                showDialog(
                                    "TAREK",
                                    "Que os ventos gelados guiem seus passos, Escolhido. E que você encontre o que procura antes que seja tarde demais.",
                                    [
                                        {
                                            text: "Continuar jornada",
                                            action: () => {
                                                saveCheckpoint('boss_defeated'); // Salva progresso
                                                showDialog(
                                                    "NARRAÇÃO",
                                                    "Com Tarek derrotado, o caminho para o interior de Tupãry está aberto. Mas esta é apenas a primeira de muitas provações que aguardam o Escolhido...",
                                                    [
                                                        {
                                                            text: "Fim da Demo (Avance para a Missão 2 em breve)",
                                                            action: () => showVictoryScreen() // Exibe tela de vitória
                                                        }
                                                    ]
                                                );
                                            }
                                        }
                                    ]
                                );
                            }
                        }
                    ]
                );
            }, 2000); // Pequeno atraso para a explosão do boss
        }

        // =========================================================
        //  16. EFEITOS VISUAIS
        // =========================================================

        /**
         * Aplica um efeito de screen shake (tremor de tela).
         * @param {number} intensity - Intensidade do tremor.
         * @param {number} duration - Duração do tremor em ms.
         */
        function screenShake(intensity, duration) {
            if (!gameSettings.screenShake) return; // Se screen shake desabilitado
            const gameContainer = document.getElementById('game-container');
            const originalTransform = gameContainer.style.transform; // Salva o estado original
            
            const startTime = Date.now();
            
            function shake() {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    const currentIntensity = intensity * (1 - progress); // Reduz intensidade com o tempo
                    
                    // Deslocamento aleatório
                    const offsetX = (Math.random() - 0.5) * currentIntensity;
                    const offsetY = (Math.random() - 0.5) * currentIntensity;
                    
                    gameContainer.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                    requestAnimationFrame(shake); // Continua tremendo
                } else {
                    gameContainer.style.transform = originalTransform; // Reseta a transformação
                }
            }
            
            shake();
        }

        /**
         * Aplica um flash temporário na tela.
         * @param {string} color - Cor do flash (ex: 'red', 'rgba(255,0,0,0.5)').
         * @param {number} duration - Duração do flash em ms.
         */
        function flashScreen(color, duration) {
            const flash = document.getElementById('screen-flash');
            flash.style.background = color;
            flash.classList.add('active'); // Ativa a animação CSS
            
            setTimeout(() => {
                flash.classList.remove('active'); // Desativa após a duração
            }, duration);
        }

        // =========================================================
        //  17. RENDERIZAÇÃO NO CANVAS
        // =========================================================

        /**
         * Função principal de renderização, limpa o canvas e desenha todos os elementos.
         */
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpa o canvas
            
            renderBackground();
            renderPlatforms();
            renderFallingSpikes();
            renderAbilityEffects();
            renderEnemies(); // Inimigos antes do player para sobreposição correta
            renderPlayer();
            renderParticles();
            
            if (window.DEBUG_MODE) {
                renderDebugInfo(); // Informações de debug
            }
        }

        /**
         * Renderiza o menu principal (usado quando gameState.inMenu é true).
         * Simplesmente desenha um gradiente de fundo.
         */
        function renderMenu() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--primary-dark'));
            gradient.addColorStop(0.3, getComputedStyle(document.documentElement).getPropertyValue('--primary-medium'));
            gradient.addColorStop(0.7, getComputedStyle(document.documentElement).getPropertyValue('--primary-light'));
            gradient.addColorStop(1, '#2c3e50'); // Cor do fundo final
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        /**
         * Renderiza as camadas de fundo com efeito de parallax.
         */
        function renderBackground() {
            // Desenha um gradiente de fundo base para o céu/ambiente
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--primary-dark'));
            gradient.addColorStop(0.3, getComputedStyle(document.documentElement).getPropertyValue('--primary-medium'));
            gradient.addColorStop(0.7, getComputedStyle(document.documentElement).getPropertyValue('--primary-light'));
            gradient.addColorStop(1, '#2c3e50');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Renderiza as camadas de parallax com imagens
            backgroundLayers.forEach((layer) => {
                const asset = assetCache[layer.asset];
                if (!asset) return; // Pula se o asset não carregou

                // Calcula o offset para o efeito parallax
                const parallaxOffset = (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x) * layer.speed;
                const assetWidth = asset.width; // Largura original da imagem do asset
                const assetHeight = asset.height; // Altura original da imagem do asset

                // Ajusta a escala da imagem de fundo para preencher o canvas sem distorcer (mantém aspecto)
                const scale = Math.max(canvas.width / assetWidth, canvas.height / assetHeight);
                const scaledWidth = assetWidth * scale;
                const scaledHeight = assetHeight * scale;

                // Desenha a imagem para cobrir a tela, repetindo se necessário para o parallax horizontal
                ctx.globalAlpha = 1; 
                // Loop para desenhar várias cópias e garantir rolagem infinita
                // Desenha a primeira cópia
                ctx.drawImage(asset, (-parallaxOffset % scaledWidth), 0, scaledWidth, scaledHeight);
                // Desenha a segunda cópia (para criar a impressão de rolagem infinita)
                ctx.drawImage(asset, (-parallaxOffset % scaledWidth) + scaledWidth, 0, scaledWidth, scaledHeight);

                ctx.globalAlpha = 1; // Reseta o alpha
            });
        }

        /**
         * Renderiza as plataformas do jogo.
         */
        function renderPlatforms() {
            for (const platform of platforms) {
                // Calcula a posição da plataforma em relação à câmera
                const x = platform.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = platform.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                // Otimização: Não renderiza plataformas fora da tela
                if (x + platform.width < -50 || x > canvas.width + 50 || 
                    y + platform.height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                const asset = assetCache[platform.asset];
                if (asset) {
                    ctx.drawImage(asset, x, y, platform.width, platform.height); // Desenha imagem da plataforma
                } else {
                    // Fallback para cores se o asset não carregar
                    if (platform.type === 'ground' || platform.type === 'platform') {
                        ctx.fillStyle = platform.slippery ? COLOR_ACCENT_ICE : '#3a3a3a';
                        ctx.fillRect(x, y, platform.width, platform.height);
                    } else if (platform.type === 'spike') {
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--spike-color');
                        ctx.beginPath();
                        // Desenha triângulos para espinhos
                        for (let i = 0; i < platform.width; i += 10) {
                            ctx.moveTo(x + i, y + platform.height);
                            ctx.lineTo(x + i + 5, y);
                            ctx.lineTo(x + i + 10, y + platform.height);
                            ctx.fill();
                        }
                        ctx.closePath();
                    }
                }
            }
        }

        /**
         * Renderiza os espinhos que caem.
         */
        function renderFallingSpikes() {
            for (const spike of fallingSpikes) {
                if (!spike.active) continue; // Só renderiza espinhos ativos
                
                const x = spike.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = spike.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                // Otimização: Não renderiza espinhos fora da tela
                if (x + spike.width < -50 || x > canvas.width + 50 || 
                    y + spike.height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                const asset = assetCache[spike.asset];
                if (asset) {
                    ctx.drawImage(asset, x, y, spike.width, spike.height); // Desenha imagem do espinho
                } else {
                    // Fallback para cor
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--spike-color');
                    ctx.beginPath();
                    ctx.moveTo(x, y + spike.height);
                    ctx.lineTo(x + spike.width/2, y);
                    ctx.lineTo(x + spike.width, y + spike.height);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        /**
         * Renderiza o jogador no canvas.
         */
        function renderPlayer() {
            const x = gameState.playerPosition.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
            const y = gameState.playerPosition.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
            const width = CONFIG.PLAYER_SPRITE_WIDTH;
            const height = CONFIG.PLAYER_SPRITE_HEIGHT; 

            // Ajusta a posição Y do sprite para que a base do sprite esteja na posição Y da hitbox
            const adjustedY = y - CONFIG.PLAYER_SPRITE_OFFSET_Y;
            
            // Otimização: Não renderiza jogador fora da tela
            if (x + width < -50 || x > canvas.width + 50 || adjustedY + height < -50 || adjustedY > canvas.height + 50) {
                return;
            }
            
            // Efeito de piscar durante invencibilidade
            if (gameState.isInvincible && Math.floor(Date.now() / 100) % 2) {
                ctx.globalAlpha = 0.5; 
            }
            
            // Seleciona o asset do GIF com base na animação e direção
            let assetKey = `${gameState.currentAnimation}_${gameState.facing}`;
            let playerAsset = assetCache[assetKey];

            // Fallback: Se não há asset para a direção, tenta usar a versão sem direção (e espelha)
            if (!playerAsset) {
                assetKey = `${gameState.currentAnimation}_right`; // Tenta a versão "right"
                playerAsset = assetCache[assetKey];
                if (playerAsset && gameState.facing === 'left') {
                    // Se só tem a versão "right" e o player está "left", espelha
                    ctx.save();
                    ctx.translate(x + width / 2, adjustedY + height / 2); // Move origem para o centro do sprite
                    ctx.scale(-1, 1); // Espelha horizontalmente
                    ctx.drawImage(playerAsset, -width / 2, -height / 2, width, height); // Desenha no centro
                    ctx.restore(); // Restaura o contexto do canvas
                    ctx.globalAlpha = 1;
                    // DEBUG: Desenha a hitbox do jogador
                    if (window.DEBUG_MODE) {
                        const hitbox = getPlayerHitbox();
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(hitbox.x - gameState.cameraOffset.x, hitbox.y - gameState.cameraOffset.y, hitbox.width, hitbox.height);
                    }
                    return; // Já desenhou, sai da função
                }
            }

            if (playerAsset) {
                ctx.drawImage(playerAsset, x, adjustedY, width, height);
            } else {
                // Fallback: Desenha um retângulo branco se o asset não carregar
                ctx.fillStyle = COLOR_PLAYER;
                ctx.fillRect(x, adjustedY, width, height);
            }

            // Efeito visual para a fúria de Umbra (além do filtro no canvas)
            if (gameState.isUmbraFurious) {
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = COLOR_ACCENT_GOLD;
                ctx.fillRect(x, adjustedY, width, height);
            }
            
            ctx.globalAlpha = 1; // Reseta o alpha

            // DEBUG: Desenha a hitbox do jogador
            if (window.DEBUG_MODE) {
                const hitbox = getPlayerHitbox();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                ctx.strokeRect(hitbox.x - gameState.cameraOffset.x, hitbox.y - gameState.cameraOffset.y, hitbox.width, hitbox.height);
            }
        }

        /**
         * Renderiza os inimigos no canvas.
         */
        function renderEnemies() {
            for (const enemy of enemies) {
                // Define as dimensões visuais do sprite do inimigo
                const enemyWidth = enemy.type === 'boss' || enemy.type === 'boss_dialogue' ? 70 : 50;
                const enemyHeight = enemy.type === 'boss' || enemy.type === 'boss_dialogue' ? 70 : 50;
                
                // Calcula a posição do inimigo em relação à câmera
                const x = enemy.position.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = enemy.position.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                // Otimização: Não renderiza inimigos fora da tela
                if (x + enemyWidth < -50 || x > canvas.width + 50 || y + enemyHeight < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                // Efeito visual para inimigos congelados
                if (enemy.frozen) {
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = COLOR_ACCENT_ICE;
                    ctx.fillRect(x - 5, y - 5, enemyWidth + 10, enemyHeight + 10); 
                    ctx.globalAlpha = 1;
                }
                
                let assetKey = `${enemy.currentAnimation}_${enemy.facing}`;
                let enemyAsset = assetCache[assetKey];

                // Fallback para idle se animação específica não existir, ou se não há versão para a direção atual
                if (!enemyAsset) {
                    assetKey = `${enemy.currentAnimation}_right`; // Tenta a versão "right"
                    enemyAsset = assetCache[assetKey];
                    if (enemyAsset && enemy.facing === 'left') {
                        // Se só tem a versão "right" e o inimigo está "left", espelha
                        ctx.save();
                        ctx.translate(x + enemyWidth / 2, y + enemyHeight / 2);
                        ctx.scale(-1, 1);
                        ctx.drawImage(enemyAsset, -enemyWidth / 2, -enemyHeight / 2, enemyWidth, enemyHeight);
                        ctx.restore();
                    } else if (enemyAsset) {
                        // Se tem a versão "right" e o inimigo está "right" (ou não tem mirrored), usa a original
                        ctx.drawImage(enemyAsset, x, y, enemyWidth, enemyHeight);
                    } else {
                        // Fallback para cores se nenhum asset (nem o principal, nem o espelhado) carregar
                        if (enemy.type === 'sentinel') {
                            renderSentinelFallback(enemy, x, y, enemyWidth, enemyHeight);
                        } else if (enemy.type === 'boss' || enemy.type === 'boss_dialogue') {
                            renderBossFallback(enemy, x, y, enemyWidth, enemyHeight);
                        }
                    }
                } else {
                    // Se o asset específico da direção foi encontrado, desenha-o diretamente
                    ctx.drawImage(enemyAsset, x, y, enemyWidth, enemyHeight);
                }
                
                // Renderiza barra de vida do inimigo (exceto Tarek em diálogo)
                if (enemy.health < enemy.maxHealth && enemy.health > 0 && enemy.type !== 'boss_dialogue') {
                    const barWidth = enemyWidth + 10;
                    const barHeight = 6;
                    const barX = x - 5;
                    const barY = y - 15;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = healthPercent > 0.5 ? '#4caf50' : healthPercent > 0.25 ? '#ff9800' : '#f44336';
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
                
                // Renderiza nome do boss
                if ((enemy.type === 'boss' || enemy.type === 'boss_dialogue') && enemy.name) {
                    ctx.fillStyle = COLOR_TEXT_LIGHT;
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(enemy.name, x + enemyWidth/2, y - 25);
                    ctx.textAlign = 'left'; // Reseta o alinhamento para outros textos
                }

                // DEBUG: Desenha hitbox do inimigo
                if (window.DEBUG_MODE) {
                    const enemyHitboxWidth = enemyWidth * 0.8;
                    const enemyHitboxHeight = enemyHeight * 0.9;
                    const enemyHitboxX = enemy.position.x + (enemyWidth - enemyHitboxWidth) / 2;
                    const enemyHitboxY = enemy.position.y + (enemyHeight - enemyHitboxHeight);
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(enemyHitboxX - gameState.cameraOffset.x, enemyHitboxY - gameState.cameraOffset.y, enemyHitboxWidth, enemyHitboxHeight);
                }
            }
        }

        /**
         * Fallback para renderizar Sentinela se o GIF não carregar.
         * @param {object} enemy - Objeto do inimigo.
         * @param {number} x - Posição X.
         * @param {number} y - Posição Y.
         * @param {number} width - Largura.
         * @param {number} height - Altura.
         */
        function renderSentinelFallback(enemy, x, y, width, height) {
            ctx.fillStyle = '#78909c';
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#cfd8dc';
            ctx.fillRect(x + 10, y + 10, width - 20, height - 20);
            ctx.fillStyle = '#00e5ff';
            ctx.fillRect(x + 15, y + 5, 4, 4);
            ctx.fillRect(x + 31, y + 5, 4, 4);
        }

        /**
         * Fallback para renderizar Boss (Tarek) se o GIF não carregar.
         * @param {object} enemy - Objeto do inimigo.
         * @param {number} x - Posição X.
         * @param {number} y - Posição Y.
         * @param {number} width - Largura.
         * @param {number} height - Altura.
         */
        function renderBossFallback(enemy, x, y, width, height) {
            if (enemy.enraged) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(x - 5, y - 5, width + 10, height + 10);
            }
            const bossGradient = ctx.createLinearGradient(x, y, x, y + height);
            bossGradient.addColorStop(0, '#a0522d');
            bossGradient.addColorStop(0.5, '#8b4513');
            bossGradient.addColorStop(1, '#692e0e');
            ctx.fillStyle = bossGradient;
            ctx.fillRect(x, y, width, height);
            ctx.fillStyle = '#4a2d1d';
            ctx.fillRect(x + 10, y + 15, width - 20, 20);
            ctx.fillStyle = COLOR_ACCENT_FIRE;
            ctx.fillRect(x + 20, y + 8, 6, 6);
            ctx.fillRect(x + width - 26, y + 8, 6, 6);
        }

        /**
         * Renderiza os efeitos de habilidades no canvas.
         */
        function renderAbilityEffects() {
            for (const effect of abilityEffects) {
                // Calcula a posição do efeito em relação à câmera
                const x = effect.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = effect.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                // Otimização: Não renderiza efeitos fora da tela ou inativos
                if (x + effect.width < -50 || x > canvas.width + 50 || 
                    y + effect.height < -50 || y > canvas.height + 50 || !effect.active) {
                    continue;
                }
                
                const effectAsset = assetCache[effect.asset];

                if (effectAsset) {
                    ctx.drawImage(effectAsset, x, y, effect.width, effect.height);
                } else {
                    // Fallback para renderização de cor/forma se o asset não carregar
                    switch(effect.type) {
                        case 'meleeAttack': renderMeleeAttackFallback(effect, x, y); break;
                        case 'energyProjectile': renderEnergyProjectileFallback(effect, x, y); break;
                        case 'arcaneExplosion': renderArcaneExplosionFallback(effect, x, y); break;
                        case 'bossSlash': renderBossSlashFallback(effect, x, y); break;
                        case 'bossIceOrb': renderBossIceOrbFallback(effect, x, y); break;
                        case 'bossPrison': renderBossPrisonFallback(effect, x, y); break;
                        case 'enemyIceShot': renderEnemyIceShotFallback(effect, x, y); break;
                        case 'chargeAttack': renderChargeAttackFallback(effect, x, y); break;
                    }
                }
            }
        }

        // Fallbacks para renderização de efeitos se os assets não carregarem
        function renderMeleeAttackFallback(effect, x, y) {
            const alpha = 1 - (effect.duration - effect.timer) / effect.duration;
            ctx.globalAlpha = alpha * 0.8;
            ctx.fillStyle = COLOR_TEXT_LIGHT;
            ctx.fillRect(x, y, effect.width, effect.height);
            ctx.globalAlpha = 1;
        }

        function renderEnergyProjectileFallback(effect, x, y) {
            ctx.fillStyle = COLOR_ACCENT_BLUE;
            ctx.fillRect(x, y, effect.width, effect.height);
        }

        function renderArcaneExplosionFallback(effect, x, y) {
            const progress = 1 - (effect.timer / effect.duration);            
            const maxRadius = effect.width / 2;
            const currentRadius = maxRadius * progress;
            ctx.globalAlpha = (1 - progress) * 0.7;
            const gradient = ctx.createRadialGradient(
                x + effect.width/2, y + effect.height/2, 0,
                x + effect.width/2, y + effect.height/2, currentRadius
            );
            gradient.addColorStop(0, COLOR_ACCENT_GOLD);
            gradient.addColorStop(0.5, COLOR_ACCENT_GOLD);
            gradient.addColorStop(1, 'rgba(255, 107, 107, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, currentRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        function renderBossSlashFallback(effect, x, y) {
            const alpha = 1 - (effect.duration - effect.timer) / effect.duration;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = COLOR_ACCENT_FIRE;
            ctx.fillRect(x, y, effect.width, effect.height);
            ctx.globalAlpha = 1;
        }

        function renderBossIceOrbFallback(effect, x, y) {
            ctx.fillStyle = COLOR_ACCENT_ICE;
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, effect.width/2, 0, Math.PI * 2);
            ctx.fill();
        }

        function renderBossPrisonFallback(effect, x, y) {
            ctx.fillStyle = 'rgba(168, 208, 230, 0.7)';
            ctx.fillRect(x, y, effect.width, effect.height);
            ctx.strokeStyle = COLOR_ACCENT_ICE;
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, effect.width, effect.height);
        }

        function renderEnemyIceShotFallback(effect, x, y) {
            ctx.fillStyle = COLOR_ACCENT_ICE;
            ctx.fillRect(x, y, effect.width, effect.height);
        }

        function renderChargeAttackFallback(effect, x, y) {
            const alpha = 1 - (effect.duration - effect.timer) / effect.duration;
            ctx.globalAlpha = alpha * 0.7;
            ctx.fillStyle = COLOR_WARRIOR; 
            ctx.fillRect(x, y, effect.width, effect.height);
            ctx.globalAlpha = 1;
        }

        /**
         * Renderiza as partículas visuais no canvas.
         */
        function renderParticles() {
            for (const particle of particles) {
                // Calcula a posição da partícula em relação à câmera
                const x = particle.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = particle.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                // Otimização: Não renderiza partículas fora da tela
                if (x < -20 || x > canvas.width + 20 || y < -20 || y > canvas.height + 20) {
                    continue;
                }
                
                ctx.globalAlpha = particle.alpha || 1; // Aplica opacidade
                
                const particleAsset = assetCache[particle.asset]; // Tenta usar um asset para a partícula
                if (particleAsset) {
                    ctx.drawImage(particleAsset, x, y, particle.size, particle.size);
                } else {
                    // Fallback para desenho de círculo
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            ctx.globalAlpha = 1; // Reseta o alpha do canvas
        }

        /**
         * Renderiza informações de debug no canto inferior esquerdo do canvas.
         */
        function renderDebugInfo() {
            if (!window.DEBUG_MODE) return;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, canvas.height - 150, 200, 140);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px monospace';
            ctx.fillText(`FPS: ${Math.round(1000 / (Date.now() - lastTime))}`, 15, canvas.height - 130);
            ctx.fillText(`Player: ${Math.round(gameState.playerPosition.x)}, ${Math.round(gameState.playerPosition.y)}`, 15, canvas.height - 115);
            ctx.fillText(`Velocity: ${Math.round(gameState.playerVelocity.x)}, ${Math.round(gameState.playerVelocity.y)}`, 15, canvas.height - 100);
            ctx.fillText(`Camera: ${Math.round(gameState.cameraOffset.x)}, ${Math.round(gameState.cameraOffset.y)}`, 15, canvas.height - 85);
            ctx.fillText(`Enemies: ${enemies.length}`, 15, canvas.height - 70);
            ctx.fillText(`Particles: ${particles.length}`, 15, canvas.height - 55);
            ctx.fillText(`Effects: ${abilityEffects.length}`, 15, canvas.height - 40);
            ctx.fillText(`Grounded: ${gameState.isGrounded}`, 15, canvas.height - 25);
            ctx.fillText(`Animation: ${gameState.currentAnimation}`, 15, canvas.height - 10);
        }

        // =========================================================
        //  18. ATUALIZAÇÃO DA UI (OTIMIZADA)
        // =========================================================

        /**
         * Atualiza todas as barras de status e informações do jogador na UI.
         * Chamada após mudanças significativas nos stats do jogador.
         */
        function updateAllUI() {
            updateHealthBar();
            updateManaBar();
            updateXPBar();
            updatePlayerStats();
        }

        /**
         * Atualiza a barra de vida do jogador na UI.
         */
        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            const healthText = document.getElementById('health-text');
            
            const currentHealth = Math.round(gameState.playerHealth);
            const currentMaxHealth = gameState.playerMaxHealth;

            // Otimização: Atualiza apenas se os valores mudaram
            if (currentHealth !== lastPlayerHealth || currentMaxHealth !== healthFill.dataset.maxHealth) {
                const percentage = (currentHealth / currentMaxHealth) * 100;
                healthFill.style.width = percentage + '%';
                healthText.textContent = `${currentHealth}/${currentMaxHealth}`;
                healthFill.dataset.maxHealth = currentMaxHealth; 
                lastPlayerHealth = currentHealth;
            }
        }

        /**
         * Atualiza a barra de mana do jogador na UI.
         */
        function updateManaBar() {
            const manaFill = document.getElementById('mana-fill');
            const manaText = document.getElementById('mana-text');
            
            const currentMana = Math.round(gameState.playerMana);
            const currentMaxMana = gameState.playerMaxMana;

            if (currentMana !== lastPlayerMana || currentMaxMana !== manaFill.dataset.maxMana) {
                const percentage = (currentMana / currentMaxMana) * 100;
                manaFill.style.width = percentage + '%';
                manaText.textContent = `${currentMana}/${currentMaxMana}`;
                manaFill.dataset.maxMana = currentMaxMana;
                lastPlayerMana = currentMana;
            }
        }

        /**
         * Atualiza a barra de XP do jogador na UI.
         */
        function updateXPBar() {
            const xpFill = document.getElementById('xp-fill');
            const xpText = document.getElementById('xp-text');
            
            const currentXP = gameState.playerXP;
            const currentNextLevelXP = gameState.playerNextLevelXP;

            if (currentXP !== lastPlayerXP || currentNextLevelXP !== xpFill.dataset.nextLevelXP) {
                const percentage = (currentXP / currentNextLevelXP) * 100;
                xpFill.style.width = percentage + '%';
                xpText.textContent = `${currentXP}/${currentNextLevelXP}`;
                xpFill.dataset.nextLevelXP = currentNextLevelXP;
                lastPlayerXP = currentXP;
            }
        }

        /**
         * Atualiza os atributos do jogador (nível, classe, dano) na UI.
         */
        function updatePlayerStats() {
            const levelEl = document.getElementById('player-level');
            const classEl = document.getElementById('player-class');
            const damageEl = document.getElementById('player-damage');
            
            if (levelEl && gameState.playerLevel !== lastPlayerLevel) {
                levelEl.textContent = gameState.playerLevel;
                lastPlayerLevel = gameState.playerLevel;
            }
            if (classEl && gameState.playerClass !== lastPlayerClass) {
                classEl.textContent = gameState.playerClass === 'chosenOne' ? 'Escolhido' : gameState.playerClass;
                lastPlayerClass = gameState.playerClass;
            }
            if (damageEl && Math.round(gameState.playerDamage) !== lastPlayerDamage) {
                damageEl.textContent = Math.round(gameState.playerDamage);
                lastPlayerDamage = Math.round(gameState.playerDamage);
            }
        }

        // =========================================================
        //  19. CONTROLE DE JOGO (PAUSA, GAME OVER, VITÓRIA)
        // =========================================================

        /**
         * Alterna o estado de pausa do jogo.
         */
        function togglePause() {
            // Não pausa se estiver no menu, cutscene ou diálogo
            if (gameState.inMenu || gameState.inCutscene || gameState.inDialog) return;
            
            gameState.gamePaused = !gameState.gamePaused; // Inverte o estado de pausa
            const pauseMenu = document.getElementById('pause-menu');
            
            if (gameState.gamePaused) {
                pauseMenu.style.display = 'flex'; // Mostra o menu de pausa
                stopMusic(); // Para a música
            } else {
                pauseMenu.style.display = 'none'; // Esconde o menu
                // Continua a música apropriada
                if (gameState.inBossFight) {
                    playMusic('music_boss_tarek', true);
                } else {
                    playMusic('music_platforming', true);
                }
            }
        }

        /**
         * Lógica de Game Over quando o jogador é derrotado.
         */
        function gameOver() {
            gameState.gamePaused = true; // Pausa o jogo
            stopMusic(); // Para a música
            
            flashScreen('rgba(0, 0, 0, 0.8)', 1000); // Tela preta com fade
            
            // Exibe diálogo de Game Over após um pequeno atraso
            setTimeout(() => {
                showDialog(
                    "SISTEMA",
                    `${gameState.playerName} foi derrotado... Mas a jornada não termina aqui. O destino de todos os reinos ainda depende de suas escolhas.`,
                    [
                        {
                            text: "Voltar ao último checkpoint",
                            action: () => { restartFromCheckpoint(); }
                        },
                        {
                            text: "Reiniciar fase atual",
                            action: () => {
                                loadPhase(gameState.currentPhase);
                                gameState.gamePaused = false; // Despausa
                                // Recarrega vida e mana
                                gameState.playerHealth = gameState.playerMaxHealth;
                                gameState.playerMana = gameState.playerMaxMana;
                                updateAllUI();
                                // Se for luta de boss, reinicia a música
                                if (gameState.inBossFight) playMusic('music_boss_tarek', true);
                                else playMusic('music_platforming', true);
                            }
                        },
                        {
                            text: "Voltar ao menu principal",
                            action: () => { exitToMenu(); }
                        }
                    ]
                );
            }, 1500);
        }

        /**
         * Exibe a tela de vitória após derrotar o chefe final.
         */
        function showVictoryScreen() {
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            const imageElement = document.getElementById('cinematic-image');
            
            overlay.style.display = 'flex';
            imageElement.src = ''; // Remove imagem da cutscene
            imageElement.style.opacity = '0';
            overlay.classList.remove('with-image');
            
            titleElement.textContent = "VITÓRIA!";
            textElement.innerHTML = `
                <p>Parabéns, ${gameState.playerName}!</p>
                <br>
                <p>Você completou a primeira parte da jornada em Tupãry. Tarek foi derrotado e o caminho para o interior do reino gelado está aberto.</p>
                <br>
                <p>Mas esta é apenas a primeira de muitas provações. O Coração de Gelo ainda aguarda, e Ignys se aproxima...</p>
                <br>
                <p><strong>Estatísticas Finais:</strong></p>
                <p>Nível Alcançado: ${gameState.playerLevel}</p>
                <p>Classe: Escolhido</p>
                <p>XP Total: ${gameState.playerXP}</p>
                <br>
                <p><em>Obrigado por jogar Tupãry: O Reino Congelado!</em></p>
                <p><em>Mais capítulos em breve...</em></p>
            `;
            
            titleElement.style.animation = 'none';
            textElement.style.animation = 'none';
            void titleElement.offsetWidth;
            void textElement.offsetWidth;
            titleElement.style.animation = 'fadeInText 2s forwards';
            textElement.style.animation = 'fadeInText 3s forwards 1s';
            
            const nextBtn = document.getElementById('next-btn');
            nextBtn.textContent = 'Voltar ao Menu'; // Muda texto do botão
            nextBtn.onclick = () => { // Muda ação do botão
                // Limpa saves e checkpoints para reiniciar o jogo
                setCookie('tupary_save', '', -1);
                setCookie('tupary_checkpoint', '', -1);
                exitToMenu(); // Volta ao menu principal
            };
        }

        // =========================================================
        //  20. SISTEMA DE CONFIGURAÇÕES DO JOGO
        // =========================================================

        /**
         * Objeto que armazena e gerencia as configurações do jogo (volume, qualidade, etc.).
         */
        const gameSettings = {
            volume: 0.7, // Volume master (não usado diretamente, mas pode ser para UI)
            sfxVolume: 0.8, // Volume dos efeitos sonoros
            musicVolume: 0.6, // Volume da música
            showFPS: false, // Mostrar FPS (ativado por #debug na URL)
            particleQuality: 'high', // Qualidade das partículas (pode ser 'low', 'medium', 'high')
            screenShake: true, // Habilitar/desabilitar screen shake
            
            /**
             * Carrega as configurações salvas de um cookie.
             */
            load: function() {
                const saved = getCookie('tupary_settings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        // Copia as propriedades salvas para o objeto gameSettings
                        Object.assign(this, settings); 
                    } catch (e) {
                        console.error('Erro ao carregar configurações:', e);
                    }
                }
            },
            
            /**
             * Salva as configurações atuais em um cookie.
             */
            save: function() {
                setCookie('tupary_settings', JSON.stringify(this));
            }
        };

        // =========================================================
        //  21. OTIMIZAÇÕES DE PERFORMANCE
        // =========================================================

        /**
         * Otimiza a performance do jogo ajustando o número de partículas e taxa de spawn.
         * Esta função é chamada periodicamente.
         */
        function optimizePerformance() {
            const fps = 1000 / (Date.now() - lastTime); // Calcula FPS atual
            
            if (fps < 30) { // Se o FPS estiver baixo
                CONFIG.MAX_PARTICLES = Math.max(50, CONFIG.MAX_PARTICLES - 10); // Reduz partículas
                CONFIG.SNOW_SPAWN_RATE *= 0.8; // Reduz neve
            } else if (fps > 55) { // Se o FPS estiver alto
                CONFIG.MAX_PARTICLES = Math.min(200, CONFIG.MAX_PARTICLES + 5); // Aumenta partículas
                CONFIG.SNOW_SPAWN_RATE = Math.min(0.15, CONFIG.SNOW_SPAWN_RATE * 1.1); // Aumenta neve
            }
        }

        // =========================================================
        //  22. INICIALIZAÇÃO E EVENTOS DE JANELA
        // =========================================================

        /**
         * Função final de inicialização, chamada após o DOM carregar.
         */
        function finalizeInitialization() {
            gameSettings.load(); // Carrega configurações do jogo
            
            // Ativa o modo debug se a URL contém '#debug'
            if (window.location.hash === '#debug') {
                window.DEBUG_MODE = true;
            }
            
            // Chama a função de otimização a cada 5 segundos
            setInterval(optimizePerformance, 5000);
            
            console.log('Tupãry: O Reino Congelado - Inicializado com sucesso!');
        }

        /**
         * Salva o progresso do jogo antes da janela ser fechada ou recarregada.
         */
        window.addEventListener('beforeunload', (e) => {
            if (gameState.gameStarted && !gameState.inMenu) {
                saveProgress();
            }
        });

        /**
         * Pausa o jogo automaticamente se a janela perder o foco (aba oculta).
         */
        window.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.gameStarted && !gameState.inMenu && !gameState.gamePaused) {
                togglePause();
            }
        });

        /**
         * Inicia o jogo quando o conteúdo do DOM estiver completamente carregado.
         */
        window.addEventListener('DOMContentLoaded', () => {
            init(); // Chama a função de inicialização principal
            finalizeInitialization(); // Chama a função de finalização (settings, debug)
        });

        // =========================================================
        //  23. EXPOSIÇÃO GLOBAL PARA DEBUG (apenas em modo DEBUG)
        // =========================================================
        if (window.DEBUG_MODE) {
            window.gameState = gameState;
            window.CONFIG = CONFIG;
            window.enemies = enemies;
            window.particles = particles;
            window.abilityEffects = abilityEffects;
            window.platforms = platforms;
            
            window.debugCommands = {
                godMode: () => {
                    gameState.playerMaxHealth = 9999;
                    gameState.playerHealth = 9999;
                    gameState.playerMaxMana = 9999;
                    gameState.playerMana = 9999;
                    updateAllUI();
                    console.log("Modo Deus ativado!");
                },
                
                levelUp: () => {
                    gainXP(gameState.playerNextLevelXP);
                    console.log("Level up forçado!");
                },
                
                teleport: (x = 4800, y = 300) => {
                    gameState.playerPosition.x = x;
                    gameState.playerPosition.y = y;
                    console.log(`Teleportado para X:${x}, Y:${y}`);
                },
                
                spawnBoss: () => {
                    loadPhase(3); // Carrega a fase do boss
                    console.log("Boss Tarek spawned!");
                },
                
                clearEnemies: () => {
                    enemies.length = 0;
                    console.log("Todos os inimigos removidos!");
                },
                
                addParticles: (type = 'snow', count = 50) => {
                    for (let i = 0; i < count; i++) {
                        if (type === 'snow') {
                            spawnSnowParticle();
                        } else if (type === 'spark') {
                            spawnSparkParticle(gameState.playerPosition.x + 25, gameState.playerPosition.y + 25);
                        }
                    }
                    console.log(`${count} partículas do tipo '${type}' adicionadas!`);
                }            window.debugCommands = {
                godMode: () => {
                    gameState.playerMaxHealth = 9999;
                    gameState.playerHealth = 9999;
                    gameState.playerMaxMana = 9999;
                    gameState.playerMana = 9999;
                    updateAllUI();
                    console.log("Modo Deus ativado!");
                },
                
                levelUp: () => {
                    gainXP(gameState.playerNextLevelXP);
                    console.log("Level up forçado!");
                },
                
                teleport: (x = 4800, y = 300) => {
                    gameState.playerPosition.x = x;
                    gameState.playerPosition.y = y;
                    console.log(`Teleportado para X:${x}, Y:${y}`);
                },
                
                spawnBoss: () => {
                    loadPhase(3); // Carrega a fase do boss
                    console.log("Boss Tarek spawned!");
                },
                
                clearEnemies: () => {
                    enemies.length = 0;
                    console.log("Todos os inimigos removidos!");
                },
                
                addParticles: (type = 'snow', count = 50) => { // Completei aqui
                    addParticles(type, gameState.playerPosition.x, gameState.playerPosition.y, count);
                    console.log(`Adicionadas ${count} partículas do tipo '${type}'.`);
                },
                
                // Exemplo de como adicionar mais comandos de debug:
                // resetGame: () => {
                //     exitToMenu(); // Volta ao menu e reseta o estado
                //     console.log("Jogo resetado para o menu inicial.");
                // },
                // toggleInvincibility: () => {
                //     gameState.isInvincible = !gameState.isInvincible;
                //     console.log(`Invencibilidade: ${gameState.isInvincible ? 'ativada' : 'desativada'}`);
                // }
            };
        }
    </script>
</body>
</html>