<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tup√£ry: O Reino Congelado</title>
    <style>
        /* ===== VARI√ÅVEIS CSS ===== */
        :root {
            --accent-gold: #ffb300;
            --accent-ice: #88d8f7;
            --accent-fire: #ff5a00;
            --accent-dark: #1a1a2e;
            --text-light: #f0f0f0;
            --health-color: #ff3333;
            --mana-color: #3366ff;
            --xp-color: #9c27b0;
            --shadow-dark: rgba(0, 0, 0, 0.8);
            --ice-blue: #a8d0e6;
            --crystal-blue: #79b5d1;
            --snow-white: #ffffff;
        }

        /* ===== RESET E BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #0a0a2a 0%, #1a1a2e 50%, #16213e 100%);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* ===== CONTAINER PRINCIPAL ===== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 800px;
            max-height: 450px;
            overflow: hidden;
            border: 3px solid var(--accent-gold);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(255, 179, 0, 0.4);
            background: linear-gradient(to bottom, #0f1419, #1a1a2e);
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: transparent;
        }

        /* ===== ORIENTA√á√ÉO MOBILE ===== */
        .orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--accent-dark);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }

        .orientation-warning h2 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            font-size: 24px;
        }

        .orientation-warning p {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
        }

        .rotate-icon {
            font-size: 48px;
            margin: 20px 0;
            animation: rotatePhone 2s infinite;
        }

        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        /* ===== MENU INICIAL ===== */
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(10, 10, 42, 0.95) 0%, rgba(26, 26, 46, 0.95) 100%);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-title {
            font-size: 36px;
            font-weight: bold;
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .game-subtitle {
            font-size: 18px;
            color: var(--accent-ice);
            text-align: center;
            margin-bottom: 40px;
            font-style: italic;
        }

        .character-selection {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 500px;
        }

        .character-selection h3 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            text-align: center;
            font-size: 20px;
        }

        .name-input-group {
            margin-bottom: 25px;
        }

        .name-input-group label {
            display: block;
            color: var(--text-light);
            margin-bottom: 8px;
            font-weight: bold;
        }

        .name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--accent-ice);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s;
        }

        .name-input:focus {
            border-color: var(--accent-gold);
        }

        .class-selection {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .class-option {
            flex: 1;
            min-width: 200px;
            background: rgba(255, 179, 0, 0.1);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .class-option:hover {
            background: rgba(255, 179, 0, 0.2);
            transform: translateY(-2px);
        }

        .class-option.selected {
            background: rgba(255, 179, 0, 0.3);
            border-color: var(--accent-fire);
            box-shadow: 0 0 15px rgba(255, 179, 0, 0.5);
        }

        .class-name {
            font-size: 18px;
            font-weight: bold;
            color: var(--accent-gold);
            margin-bottom: 10px;
        }

        .class-description {
            font-size: 14px;
            color: var(--text-light);
            line-height: 1.4;
            margin-bottom: 15px;
        }

        .class-abilities {
            font-size: 12px;
            color: var(--accent-ice);
            font-style: italic;
        }

        .start-game-btn {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--accent-dark);
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(255, 179, 0, 0.3);
        }

        .start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 179, 0, 0.5);
        }

        .start-game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* ===== UI LAYER ===== */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        /* ===== BARRAS DE STATUS ===== */
        .status-bars {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
        }

        .bar-container {
            width: 200px;
            height: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
        }

        .mana-fill {
            background: linear-gradient(90deg, #4dabf7, #3366ff);
        }

        .xp-fill {
            background: linear-gradient(90deg, #da77f2, #9c27b0);
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        /* ===== STATS DO JOGADOR ===== */
        .player-stats {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 14px;
            text-align: right;
            min-width: 150px;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-line:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: var(--accent-ice);
            font-weight: bold;
        }

        .stat-value {
            color: var(--accent-gold);
            font-weight: bold;
        }

        /* ===== SISTEMA DE HABILIDADES ===== */
        .abilities-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }

        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
            border: 3px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .ability-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(255, 179, 0, 0.4);
        }

        .ability-btn:active {
            transform: scale(0.95);
        }

        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .ability-btn.cooldown:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(0, 0, 0, 0.8) 0deg);
            transition: background 0.1s linear;
        }

        .ability-tooltip {
            position: absolute;
            bottom: 70px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--accent-ice);
            border-radius: 8px;
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            width: 200px;
            text-align: center;
            z-index: 10;
        }

        .ability-btn:hover .ability-tooltip {
            opacity: 1;
        }

        .tooltip-name {
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip-description {
            color: var(--text-light);
            font-size: 12px;
            line-height: 1.3;
            margin-bottom: 5px;
        }

        .tooltip-cost {
            color: var(--mana-color);
            font-size: 11px;
            font-style: italic;
        }

        /* ===== CONTROLES MOBILE ===== */
        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            display: none;
            pointer-events: auto;
            z-index: 5;
        }

        .mobile-joystick {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
        }

        .joystick-base {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: 3px solid var(--accent-ice);
            position: relative;
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-fire));
            border: 2px solid white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .mobile-action-buttons {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .mobile-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .mobile-btn:active {
            transform: scale(0.9);
            background: rgba(255, 179, 0, 0.3);
        }

        .jump-btn {
            grid-column: span 2;
            width: 110px;
            border-radius: 25px;
            justify-self: center;
        }

        .crouch-btn {
            grid-column: span 2;
            width: 110px;
            border-radius: 25px;
            justify-self: center;
        }

        /* ===== SISTEMA DE DI√ÅLOGO ===== */
        .dialog-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(26, 26, 46, 0.9));
            border: 3px solid var(--accent-ice);
            border-radius: 15px;
            padding: 20px;
            display: none;
            pointer-events: auto;
            z-index: 20;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .dialog-speaker {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dialog-text {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .dialog-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dialog-option {
            background: linear-gradient(135deg, rgba(255, 179, 0, 0.2), rgba(255, 90, 0, 0.2));
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-light);
            font-weight: bold;
        }

        .dialog-option:hover {
            background: linear-gradient(135deg, rgba(255, 179, 0, 0.4), rgba(255, 90, 0, 0.4));
            transform: translateX(5px);
        }

        .dialog-option:active {
            transform: translateX(5px) scale(0.98);
        }

        /* ===== CUTSCENES ===== */
        .cinematic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 46, 0.95));
            z-index: 30;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .cinematic-text {
            font-size: 20px;
            text-align: center;
            max-width: 80%;
            margin-bottom: 30px;
            color: var(--text-light);
            line-height: 1.6;
            opacity: 0;
            animation: fadeInText 3s forwards;
        }

        .cinematic-title {
            font-size: 32px;
            color: var(--accent-gold);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .skip-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-weight: bold;
        }

        .skip-btn:hover {
            background: rgba(255, 179, 0, 0.2);
            transform: translateY(-2px);
        }

        /* ===== PAUSE MENU ===== */
        .pause-btn {
            position: absolute;
            top: 15px;
            right: 180px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-size: 16px;
        }

        .pause-btn:hover {
            background: rgba(255, 179, 0, 0.2);
            transform: scale(1.1);
        }

        .pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 40;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .pause-title {
            font-size: 36px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-option {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--accent-dark);
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 200px;
        }

        .menu-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255, 179, 0, 0.4);
        }

        /* ===== LEVEL UP ===== */
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(26, 26, 46, 0.95));
            border: 3px solid var(--accent-gold);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            z-index: 35;
            display: none;
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .level-up-title {
            font-size: 28px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .level-up-subtitle {
            font-size: 16px;
            color: var(--text-light);
            margin-bottom: 25px;
        }

        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .upgrade-option {
            background: linear-gradient(135deg, rgba(255, 179, 0, 0.2), rgba(255, 90, 0, 0.2));
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
        }

        .upgrade-option:hover {
            background: linear-gradient(135deg, rgba(255, 179, 0, 0.4), rgba(255, 90, 0, 0.4));
            transform: translateX(5px);
        }

        .upgrade-name {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .upgrade-description {
            color: var(--text-light);
            font-size: 14px;
            line-height: 1.3;
        }

        /* ===== CHECKPOINT SYSTEM ===== */
        .checkpoint-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-ice);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 25;
            display: none;
            animation: checkpointPulse 2s ease-in-out;
        }

        @keyframes checkpointPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }

        .checkpoint-text {
            color: var(--accent-ice);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .checkpoint-description {
            color: var(--text-light);
            font-size: 14px;
        }

        /* ===== ANIMA√á√ïES ===== */
        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes levelUpAnimation {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        @keyframes iceOrb {
            0% { transform: scale(0.8) rotate(0deg); opacity: 0.7; }
            50% { transform: scale(1.2) rotate(180deg); opacity: 1; }
            100% { transform: scale(1) rotate(360deg); opacity: 0.9; }
        }

        @keyframes crystalPrison {
            0% { height: 0; opacity: 0; transform: scaleY(0); }
            100% { height: 120px; opacity: 1; transform: scaleY(1); }
        }

        @keyframes dashEffect {
            0% { transform: scaleX(0); opacity: 1; }
            100% { transform: scaleX(1); opacity: 0; }
        }

        @keyframes damageFlash {
            0%, 100% { background: rgba(255, 0, 0, 0); }
            50% { background: rgba(255, 0, 0, 0.3); }
        }

        /* ===== RESPONSIVIDADE ===== */
        @media (max-width: 800px) {
            #game-container {
                width: 100vw;
                height: 100vh;
                max-width: none;
                max-height: none;
                border: none;
                border-radius: 0;
            }

            .mobile-controls {
                display: block;
            }

            .abilities-container {
                display: none;
            }

            .status-bars {
                top: 10px;
                left: 10px;
            }

            .bar-container {
                width: 150px;
                height: 12px;
            }

            .player-stats {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 12px;
                min-width: 120px;
            }

            .pause-btn {
                top: 10px;
                right: 140px;
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .dialog-container {
                width: 95%;
                padding: 15px;
                bottom: 15px;
            }

            .dialog-text {
                font-size: 14px;
                min-height: 50px;
            }

            .cinematic-text {
                font-size: 16px;
                max-width: 90%;
            }

            .cinematic-title {
                font-size: 24px;
            }

            .skip-btn {
                bottom: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 14px;
            }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            .status-bars {
                top: 5px;
                left: 5px;
            }

            .bar-container {
                width: 120px;
                height: 10px;
            }

            .player-stats {
                top: 5px;
                right: 5px;
                padding: 5px 8px;
                font-size: 10px;
                min-width: 100px;
            }

            .mobile-joystick {
                bottom: 10px;
                left: 10px;
                width: 100px;
                height: 100px;
            }

            .mobile-action-buttons {
                bottom: 10px;
                right: 10px;
            }

            .mobile-btn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }

            .jump-btn, .crouch-btn {
                width: 95px;
            }
        }

        /* ===== EFEITOS ESPECIAIS ===== */
        .screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 15;
            opacity: 0;
            pointer-events: none;
        }

        .screen-flash.active {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .boss-health-bar {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-fire);
            border-radius: 10px;
            display: none;
            overflow: hidden;
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
            transition: width 0.5s ease;
            position: relative;
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.4) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        .boss-name {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--accent-fire);
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none;
        }

        /* ===== PART√çCULAS E EFEITOS ===== */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .damage-number {
            position: absolute;
            color: #ff3333;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
            animation: damageNumber 1s ease-out forwards;
        }

        @keyframes damageNumber {
            0% { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
            100% { 
                opacity: 0; 
                transform: translateY(-50px) scale(1.2); 
            }
        }

        .xp-number {
            position: absolute;
            color: var(--xp-color);
            font-weight: bold;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
            animation: xpNumber 1.5s ease-out forwards;
        }

        @keyframes xpNumber {
            0% { 
                opacity: 1; 
                transform: translateY(0) scale(0.8); 
            }
            100% { 
                opacity: 0; 
                transform: translateY(-30px) scale(1.2); 
            }
        }
    </style>
</head>
<body>
    <!-- Aviso de Orienta√ß√£o Mobile -->
    <div class="orientation-warning" id="orientation-warning">
        <div class="rotate-icon">üì±</div>
        <h2>Vire o Dispositivo</h2>
        <p>Para uma melhor experi√™ncia de jogo, por favor vire seu dispositivo para o modo paisagem (horizontal).</p>
    </div>

    <!-- Container Principal do Jogo -->
    <div id="game-container">
        <!-- Menu Principal -->
        <div class="main-menu" id="main-menu">
            <h1 class="game-title">TUP√ÉRY</h1>
            <p class="game-subtitle">O Reino Congelado</p>
            
            <div class="character-selection">
                <h3>Escolha seu Destino</h3>
                
                <div class="name-input-group">
                    <label for="player-name">Nome do Escolhido:</label>
                    <input type="text" id="player-name" class="name-input" placeholder="Digite seu nome..." maxlength="20">
                </div>
                
                <div class="class-selection">
                    <div class="class-option" data-class="atirador">
                        <div class="class-name">Atirador G√©lido</div>
                        <div class="class-description">Especialista em ataques √† dist√¢ncia e mobilidade. Domina o gelo para criar proj√©teis devastadores e controlar o campo de batalha.</div>
                        <div class="class-abilities">Habilidades: Tiro G√©lido ‚Ä¢ Orbe Perfurante ‚Ä¢ Investida R√°pida ‚Ä¢ Barreira de Cristal</div>
                    </div>
                    
                    <div class="class-option" data-class="guerreiro">
                        <div class="class-name">Guerreiro do Gelo</div>
                        <div class="class-description">Combatente corpo a corpo resiliente. Usa a for√ßa do gelo para amplificar seus golpes e resistir aos ataques inimigos.</div>
                        <div class="class-abilities">Habilidades: Golpe Glacial ‚Ä¢ Investida Brutal ‚Ä¢ Orbe Pr√≥ximo ‚Ä¢ Pris√£o Defensiva</div>
                    </div>
                </div>
            </div>
            
            <button class="start-game-btn" id="start-game-btn" disabled>Iniciar Jornada</button>
        </div>

        <!-- Canvas do Jogo -->
        <canvas id="game-canvas"></canvas>
        
        <!-- Flash de Tela -->
        <div class="screen-flash" id="screen-flash"></div>
        
        <!-- Container de Part√≠culas -->
        <div class="particle-container" id="particle-container"></div>

        <!-- UI Layer -->
        <div class="ui-layer">
            <!-- Barras de Status -->
            <div class="status-bars">
                <div class="status-bar">
                    <div class="status-icon">‚ù§Ô∏è</div>
                    <div class="bar-container">
                        <div class="bar-fill health-fill" id="health-fill"></div>
                        <div class="bar-text" id="health-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">üíô</div>
                    <div class="bar-container">
                        <div class="bar-fill mana-fill" id="mana-fill"></div>
                        <div class="bar-text" id="mana-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">‚≠ê</div>
                    <div class="bar-container">
                        <div class="bar-fill xp-fill" id="xp-fill"></div>
                        <div class="bar-text" id="xp-text">0/100</div>
                    </div>
                </div>
            </div>
            
            <!-- Stats do Jogador -->
            <div class="player-stats" id="player-stats">
                <div class="stat-line">
                    <span class="stat-label">N√≠vel:</span>
                    <span class="stat-value" id="player-level">1</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Classe:</span>
                    <span class="stat-value" id="player-class">-</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Dano:</span>
                    <span class="stat-value" id="player-damage">15</span>
                </div>
            </div>
            
            <!-- Barra de Vida do Boss -->
            <div class="boss-name" id="boss-name">TAREK, O GUERREIRO</div>
            <div class="boss-health-bar" id="boss-health-bar">
                <div class="boss-health-fill" id="boss-health-fill"></div>
            </div>
            
            <!-- Habilidades (Desktop) -->
            <div class="abilities-container" id="abilities-container">
                <div class="ability-btn" id="ability-u" data-key="U">
                    U
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-u-name">Ataque B√°sico</div>
                        <div class="tooltip-description" id="tooltip-u-desc">Ataque corpo a corpo b√°sico</div>
                        <div class="tooltip-cost" id="tooltip-u-cost">Custo: 0 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-i" data-key="I">
                    I
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-i-name">Investida</div>
                        <div class="tooltip-description" id="tooltip-i-desc">Investida poderosa com dano aumentado</div>
                        <div class="tooltip-cost" id="tooltip-i-cost">Custo: 20 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-o" data-key="O">
                    O
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-o-name">Orbe de Gelo</div>
                        <div class="tooltip-description" id="tooltip-o-desc">Proj√©til de gelo que atravessa inimigos</div>
                        <div class="tooltip-cost" id="tooltip-o-cost">Custo: 30 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-p" data-key="P">
                    P
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-p-name">Pris√£o de Cristal</div>
                        <div class="tooltip-description" id="tooltip-p-desc">Cria uma barreira que paralisa inimigos</div>
                        <div class="tooltip-cost" id="tooltip-p-cost">Custo: 40 Mana</div>
                    </div>
                </div>
            </div>
            
            <!-- Bot√£o de Pausa -->
            <div class="pause-btn" id="pause-btn">‚è∏Ô∏è</div>
            
            <!-- Controles Mobile -->
            <div class="mobile-controls" id="mobile-controls">
                <div class="mobile-joystick" id="mobile-joystick">
                    <div class="joystick-base">
                        <div class="joystick-knob" id="joystick-knob"></div>
                    </div>
                </div>
                
                <div class="mobile-action-buttons">
                    <div class="mobile-btn jump-btn" id="mobile-jump">PULAR</div>
                    <div class="mobile-btn crouch-btn" id="mobile-crouch">ABAIXAR</div>
                    <div class="mobile-btn" id="mobile-ability-u">U</div>
                    <div class="mobile-btn" id="mobile-ability-i">I</div>
                    <div class="mobile-btn" id="mobile-ability-o">O</div>
                    <div class="mobile-btn" id="mobile-ability-p">P</div>
                </div>
            </div>
            
            <!-- Sistema de Di√°logo -->
            <div class="dialog-container" id="dialog-container">
                                <div class="dialog-speaker" id="dialog-speaker"></div>
                <div class="dialog-text" id="dialog-text"></div>
                <div class="dialog-options" id="dialog-options"></div>
            </div>
            
            <!-- Overlay de Cutscene -->
            <div class="cinematic-overlay" id="cinematic-overlay">
                <div class="cinematic-title" id="cinematic-title"></div>
                <div class="cinematic-text" id="cinematic-text"></div>
                <button class="skip-btn" id="skip-btn">Pular (Espa√ßo)</button>
            </div>
            
            <!-- Menu de Pausa -->
            <div class="pause-menu" id="pause-menu">
                <h2 class="pause-title">JOGO PAUSADO</h2>
                <button class="menu-option" id="resume-btn">Continuar</button>
                <button class="menu-option" id="restart-btn">Reiniciar Checkpoint</button>
                <button class="menu-option" id="save-btn">Salvar Progresso</button>
                <button class="menu-option" id="exit-btn">Voltar ao Menu</button>
            </div>
            
            <!-- Sistema de Level Up -->
            <div class="level-up" id="level-up">
                <h2 class="level-up-title">N√çVEL AUMENTADO!</h2>
                <p class="level-up-subtitle">Escolha uma melhoria para fortalecer seu poder:</p>
                <div class="upgrade-options">
                    <div class="upgrade-option" data-upgrade="health">
                        <div class="upgrade-name">+ Vitalidade Aprimorada</div>
                        <div class="upgrade-description">Aumenta sua vida m√°xima em 25 pontos e restaura completamente sua sa√∫de.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="mana">
                        <div class="upgrade-name">+ Reserva M√≠stica</div>
                        <div class="upgrade-description">Aumenta sua mana m√°xima em 35 pontos e acelera a regenera√ß√£o em 50%.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="damage">
                        <div class="upgrade-name">+ Poder Destrutivo</div>
                        <div class="upgrade-description">Aumenta o dano de todas suas habilidades em 8 pontos permanentemente.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="speed">
                        <div class="upgrade-name">+ Agilidade G√©lida</div>
                        <div class="upgrade-description">Aumenta velocidade de movimento em 20% e reduz cooldowns em 15%.</div>
                    </div>
                </div>
            </div>
            
            <!-- Notifica√ß√£o de Checkpoint -->
            <div class="checkpoint-notification" id="checkpoint-notification">
                <div class="checkpoint-text">CHECKPOINT SALVO</div>
                <div class="checkpoint-description">Seu progresso foi salvo automaticamente</div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURA√á√ïES GLOBAIS =====
        const CONFIG = {
            // F√≠sica do jogo
            GRAVITY: 0.6,
            PLAYER_SPEED: 4,
            JUMP_FORCE: 14,
            CROUCH_HEIGHT: 30,
            NORMAL_HEIGHT: 50,
            
            // Mundo
            WORLD_WIDTH: 5000,
            WORLD_HEIGHT: 450,
            CAMERA_SMOOTHING: 0.08,
            
            // Combate
            DAMAGE_FLASH_DURATION: 200,
            INVINCIBILITY_DURATION: 1000,
            
            // Regenera√ß√£o
            MANA_REGEN_RATE: 0.3,
            HEALTH_REGEN_RATE: 0.05,
            
            // Part√≠culas
            MAX_PARTICLES: 200,
            SNOW_SPAWN_RATE: 0.15,
            
            // Performance
            TARGET_FPS: 60,
            DELTA_TIME_CAP: 32
        };

        // ===== VARI√ÅVEIS GLOBAIS =====
        let canvas, ctx;
        let isMobile = false;
        let isLandscape = true;
        
        // Estado do jogo
        let gameState = {
            // Jogador
            playerName: '',
            playerClass: '',
            playerHealth: 100,
            playerMaxHealth: 100,
            playerMana: 100,
            playerMaxMana: 100,
            playerPosition: { x: 100, y: 300 },
            playerVelocity: { x: 0, y: 0 },
            playerLevel: 1,
            playerXP: 0,
            playerNextLevelXP: 100,
            playerDamage: 15,
            playerSpeed: CONFIG.PLAYER_SPEED,
            
            // Estados
            isGrounded: false,
            isCrouching: false,
            isInvincible: false,
            facing: 'right',
            currentAnimation: 'idle',
            
            // Habilidades
            abilitiesCooldown: { U: 0, I: 0, O: 0, P: 0 },
            abilitiesMaxCooldown: { U: 0.8, I: 6, O: 4, P: 10 },
            
            // Controle de jogo
            gamePaused: false,
            inDialog: false,
            inCutscene: false,
            inMenu: true,
            gameStarted: false,
            
            // C√¢mera
            cameraOffset: { x: 0, y: 0 },
            targetCameraOffset: { x: 0, y: 0 },
            
            // Fase atual
            currentPhase: 0,
            currentCheckpoint: 'start',
            
            // Boss fight
            inBossFight: false,
            bossDefeated: false
        };

        // Arrays de entidades
        let platforms = [];
        let particles = [];
        let backgroundLayers = [];
        let enemies = [];
        let abilityEffects = [];
        let damageNumbers = [];
        let checkpoints = [];
        
        // Controles
        let keys = {};
        let lastTime = 0;
        let animationFrameId = null;
        
        // Mobile controls
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickInput = { x: 0, y: 0 };
        
        // Classes de personagem
        let championClasses = {};
        let currentChampion = null;

        // ===== DETEC√á√ÉO DE DISPOSITIVO =====
        function detectDevice() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      window.innerWidth <= 800 || 
                      'ontouchstart' in window;
            
            if (isMobile) {
                checkOrientation();
                window.addEventListener('orientationchange', () => {
                    setTimeout(checkOrientation, 100);
                });
                window.addEventListener('resize', checkOrientation);
            }
        }

        function checkOrientation() {
            if (!isMobile) return;
            
            isLandscape = window.innerWidth > window.innerHeight;
            const orientationWarning = document.getElementById('orientation-warning');
            
            if (!isLandscape) {
                orientationWarning.style.display = 'flex';
                if (gameState.gameStarted) {
                    gameState.gamePaused = true;
                }
            } else {
                orientationWarning.style.display = 'none';
                if (gameState.gameStarted && gameState.gamePaused && !gameState.inMenu) {
                    gameState.gamePaused = false;
                }
            }
        }

        // ===== SISTEMA DE COOKIES =====
        function setCookie(name, value, days = 30) {
            const expires = new Date();
            expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function saveProgress() {
            const saveData = {
                playerName: gameState.playerName,
                playerClass: gameState.playerClass,
                playerLevel: gameState.playerLevel,
                playerXP: gameState.playerXP,
                playerMaxHealth: gameState.playerMaxHealth,
                playerMaxMana: gameState.playerMaxMana,
                playerDamage: gameState.playerDamage,
                playerSpeed: gameState.playerSpeed,
                currentPhase: gameState.currentPhase,
                currentCheckpoint: gameState.currentCheckpoint,
                bossDefeated: gameState.bossDefeated
            };
            
            setCookie('tupary_save', JSON.stringify(saveData));
            showCheckpointNotification('Progresso Salvo', 'Seu progresso foi salvo com sucesso!');
        }

        function loadProgress() {
            const saveData = getCookie('tupary_save');
            if (saveData) {
                try {
                    const data = JSON.parse(saveData);
                    return data;
                } catch (e) {
                    console.error('Erro ao carregar save:', e);
                }
            }
            return null;
        }

        // ===== INICIALIZA√á√ÉO =====
        function init() {
            detectDevice();
            
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Configurar canvas
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Inicializar sistemas
            initChampionClasses();
            initEventListeners();
            initMobileControls();
            
            // Carregar progresso salvo
            const savedData = loadProgress();
            if (savedData) {
                populateMenuWithSavedData(savedData);
            }
            
            // Iniciar loop do jogo
            gameLoop(0);
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Ajustar controles mobile
            if (isMobile) {
                updateMobileControlsPosition();
            }
        }

        function populateMenuWithSavedData(data) {
            document.getElementById('player-name').value = data.playerName || '';
            
            // Selecionar classe salva
            if (data.playerClass) {
                const classOption = document.querySelector(`[data-class="${data.playerClass}"]`);
                if (classOption) {
                    selectClass(data.playerClass);
                }
            }
        }

        // ===== CLASSES DE PERSONAGEM =====
        function initChampionClasses() {
            championClasses = {
                atirador: {
                    id: 'atirador',
                    name: 'Atirador G√©lido',
                    type: 'ranged',
                    baseHealth: 100,
                    baseMana: 120,
                    baseSpeed: 4.5,
                    baseDamage: 12,
                    abilities: [
                        {
                            key: 'U',
                            name: 'Tiro G√©lido',
                            description: 'Dispara um proj√©til de gelo √† dist√¢ncia',
                            damage: (base) => base * 1.2,
                            manaCost: 0,
                            cooldown: 0.6,
                            range: 300,
                            execute: function() {
                                // Criar proj√©til
                                addAbilityEffect({
                                    type: 'iceShot',
                                    x: gameState.playerPosition.x + (gameState.facing === 'right' ? 55 : -25),
                                    y: gameState.playerPosition.y + 20,
                                    width: 25,
                                    height: 8,
                                    duration: 2000,
                                    damage: this.damage(gameState.playerDamage),
                                    direction: gameState.facing === 'right' ? 1 : -1,
                                    speed: 8,
                                    origin: 'player',
                                    piercing: false
                                });
                                
                                // Efeito sonoro e visual
                                createMuzzleFlash();
                                addParticles('iceShard', gameState.playerPosition.x + 25, gameState.playerPosition.y + 20, 8);
                            }
                        },
                        {
                            key: 'I',
                            name: 'Investida R√°pida',
                            description: 'Dash r√°pido que atravessa inimigos',
                            damage: (base) => base * 1.8,
                            manaCost: 25,
                            cooldown: 5,
                            execute: function() {
                                if (gameState.playerMana >= this.manaCost) {
                                    gameState.playerMana -= this.manaCost;
                                    
                                    // Impulso r√°pido
                                    gameState.playerVelocity.x = (gameState.facing === 'right' ? 12 : -12);
                                    gameState.isInvincible = true;
                                    
                                    setTimeout(() => {
                                        gameState.isInvincible = false;
                                    }, 300);
                                    
                                    // Efeito visual
                                    addAbilityEffect({
                                        type: 'dashTrail',
                                        x: gameState.playerPosition.x,
                                        y: gameState.playerPosition.y,
                                        width: 60,
                                        height: 50,
                                        duration: 400,
                                        damage: this.damage(gameState.playerDamage),
                                        origin: 'player'
                                    });
                                    
                                    addParticles('dashIce', gameState.playerPosition.x + 25, gameState.playerPosition.y + 25, 20);
                                }
                            }
                        },
                        {
                            key: 'O',
                            name: 'Orbe Perfurante',
                            description: 'Orbe de gelo que atravessa m√∫ltiplos inimigos',
                            damage: (base) => base * 2.2,
                            manaCost: 35,
                            cooldown: 4,
                            execute: function() {
                                if (gameState.playerMana >= this.manaCost) {
                                    gameState.playerMana -= this.manaCost;
                                    
                                    addAbilityEffect({
                                        type: 'piercingOrb',
                                        x: gameState.playerPosition.x + (gameState.facing === 'right' ? 50 : -50),
                                        y: gameState.playerPosition.y + 15,
                                        width: 35,
                                        height: 35,
                                        duration: 3000,
                                        damage: this.damage(gameState.playerDamage),
                                        direction: gameState.facing === 'right' ? 1 : -1,
                                        speed: 6,
                                        origin: 'player',
                                        piercing: true,
                                        hitTargets: []
                                    });
                                    
                                    addParticles('orbTrail', gameState.playerPosition.x + 25, gameState.playerPosition.y + 25, 15);
                                }
                            }
                        },
                        {
                            key: 'P',
                            name: 'Barreira de Cristal',
                            description: 'Cria uma barreira defensiva que reflete proj√©teis',
                            damage: (base) => base * 0.8,
                            manaCost: 45,
                            cooldown: 8,
                            execute: function() {
                                if (gameState.playerMana >= this.manaCost) {
                                    gameState.playerMana -= this.manaCost;
                                    
                                    addAbilityEffect({
                                        type: 'crystalBarrier',
                                        x: gameState.playerPosition.x + (gameState.facing === 'right' ? 60 : -80),
                                        y: gameState.playerPosition.y - 20,
                                        width: 25,
                                        height: 90,
                                        duration: 5000,
                                        damage: this.damage(gameState.playerDamage),
                                        origin: 'player',
                                        blocking: true,
                                        reflecting: true
                                    });
                                    
                                    addParticles('crystalForm', gameState.playerPosition.x + 25, gameState.playerPosition.y, 25);
                                }
                            }
                        }
                    ]
                },
                
                guerreiro: {
                    id: 'guerreiro',
                    name: 'Guerreiro do Gelo',
                    type: 'melee',
                    baseHealth: 130,
                    baseMana: 100,
                    baseSpeed: 3.5,
                    baseDamage: 18,
                    abilities: [
                        {
                            key: 'U',
                            name: 'Golpe Glacial',
                            description: 'Ataque corpo a corpo poderoso com chance de congelar',
                            damage: (base) => base * 1.5,
                            manaCost: 0,
                            cooldown: 0.8,
                            execute: function() {
                                addAbilityEffect({
                                    type: 'meleeAttack',
                                    x: gameState.playerPosition.x + (gameState.facing === 'right' ? 50 : -40),
                                    y: gameState.playerPosition.y + 15,
                                    width: 40,
                                    height: 20,
                                    duration: 300,
                                    damage: this.damage(gameState.playerDamage),
                                    origin: 'player',
                                    freezeChance: 0.3
                                });
                                
                                // Efeito de impacto
                                addParticles('iceImpact', gameState.playerPosition.x + (gameState.facing === 'right' ? 70 : -20), gameState.playerPosition.y + 25, 12);
                                screenShake(5, 200);
                            }
                        },
                        {
                            key: 'I',
                            name: 'Investida Brutal',
                            description: 'Carga devastadora que empurra inimigos',
                            damage: (base) => base * 2.5,
                            manaCost: 30,
                            cooldown: 6,
                            execute: function() {
                                if (gameState.playerMana >= this.manaCost) {
                                    gameState.playerMana -= this.manaCost;
                                    
                                    // Impulso poderoso
                                    gameState.playerVelocity.x = (gameState.facing === 'right' ? 10 : -10);
                                    
                                    addAbilityEffect({
                                        type: 'chargeAttack',
                                        x: gameState.playerPosition.x,
                                        y: gameState.playerPosition.y,
                                        width: 70,
                                        height: 50,
                                        duration: 500,
                                        damage: this.damage(gameState.playerDamage),
                                        origin: 'player',
                                        knockback: 15
                                    });
                                    
                                    addParticles('chargeIce', gameState.playerPosition.x + 25, gameState.playerPosition.y + 40, 25);
                                    screenShake(8, 300);
                                }
                            }
                        },
                        {
                            key: 'O',
                            name: 'Orbe Pr√≥ximo',
                            description: 'Orbe de gelo de curto alcance com alto dano',
                            damage: (base) => base * 2.8,
                            manaCost: 40,
                            cooldown: 5,
                            execute: function() {
                                if (gameState.playerMana >= this.manaCost) {
                                    gameState.playerMana -= this.manaCost;
                                    
                                    addAbilityEffect({
                                        type: 'closeOrb',
                                        x: gameState.playerPosition.x + (gameState.facing === 'right' ? 40 : -40),
                                        y: gameState.playerPosition.y + 10,
                                        width: 40,
                                        height: 40,
                                        duration: 1500,
                                        damage: this.damage(gameState.playerDamage),
                                        direction: gameState.facing === 'right' ? 1 : -1,
                                        speed: 4,
                                        origin: 'player',
                                        explosive: true
                                    });
                                    
                                    addParticles('orbEnergy', gameState.playerPosition.x + 25, gameState.playerPosition.y + 25, 18);
                                }
                            }
                        },
                        {
                            key: 'P',
                            name: 'Pris√£o Defensiva',
                            description: 'Cria uma pris√£o que protege e ataca inimigos pr√≥ximos',
                            damage: (base) => base * 1.2,
                            manaCost: 50,
                            cooldown: 10,
                            execute: function() {
                                if (gameState.playerMana >= this.manaCost) {
                                    gameState.playerMana -= this.manaCost;
                                    
                                    addAbilityEffect({
                                        type: 'defensivePrison',
                                        x: gameState.playerPosition.x - 20,
                                        y: gameState.playerPosition.y - 30,
                                        width: 90,
                                        height: 110,
                                        duration: 6000,
                                        damage: this.damage(gameState.playerDamage),
                                        origin: 'player',
                                        protective: true,
                                        damageOverTime: true
                                    });
                                    
                                    addParticles('prisonForm', gameState.playerPosition.x + 25, gameState.playerPosition.y, 30);
                                }
                            }
                        }
                    ]
                }
            };
        }

        // ===== EVENT LISTENERS =====
        function initEventListeners() {
            // Menu principal
            document.getElementById('player-name').addEventListener('input', validateMenuInputs);
            document.querySelectorAll('.class-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const className = e.currentTarget.dataset.class;
                    selectClass(className);
                });
            });
            document.getElementById('start-game-btn').addEventListener('click', startGame);
            
            // Controles de teclado
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            // Bot√µes da UI
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('restart-btn').addEventListener('click', restartFromCheckpoint);
            document.getElementById('save-btn').addEventListener('click', saveProgress);
            document.getElementById('exit-btn').addEventListener('click', exitToMenu);
            document.getElementById('skip-btn').addEventListener('click', skipCutscene);
            
            // Habilidades desktop
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.key;
                    if (key) useAbility(key);
                });
            });
            
            // Level up
            document.querySelectorAll('.upgrade-option').forEach(option => {
                option.addEventListener('click', (e) => {
                    const upgrade = e.currentTarget.dataset.upgrade;
                    applyUpgrade(upgrade);
                });
            });
        }

        function handleKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            
            // Prevenir scroll da p√°gina
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            
            // Pausar com ESC
            if (e.key === 'Escape' && gameState.gameStarted && !gameState.inMenu) {
                togglePause();
            }
            
            // Pular cutscene
            if ((e.key === ' ' || e.key === 'Enter') && gameState.inCutscene) {
                skipCutscene();
            }
            
            // Habilidades
            if (['u', 'i', 'o', 'p'].includes(e.key.toLowerCase()) && 
                !gameState.gamePaused && !gameState.inDialog && !gameState.inCutscene && !gameState.inMenu) {
                useAbility(e.key.toUpperCase());
            }
        }

        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }

        // ===== CONTROLES MOBILE =====
        function initMobileControls() {
            if (!isMobile) return;
            
            const joystick = document.getElementById('mobile-joystick');
            const knob = document.getElementById('joystick-knob');
            
            // Joystick touch events
            joystick.addEventListener('touchstart', handleJoystickStart, { passive: false });
            joystick.addEventListener('touchmove', handleJoystickMove, { passive: false });
            joystick.addEventListener('touchend', handleJoystickEnd, { passive: false });
            
            // Bot√µes de a√ß√£o mobile
            document.getElementById('mobile-jump').addEventListener('touchstart', () => mobileButtonPress('jump'), { passive: false });
            document.getElementById('mobile-crouch').addEventListener('touchstart', () => mobileButtonPress('crouch'), { passive: false });
            document.getElementById('mobile-ability-u').addEventListener('touchstart', () => mobileButtonPress('u'), { passive: false });
            document.getElementById('mobile-ability-i').addEventListener('touchstart', () => mobileButtonPress('i'), { passive: false });
            document.getElementById('mobile-ability-o').addEventListener('touchstart', () => mobileButtonPress('o'), { passive: false });
            document.getElementById('mobile-ability-p').addEventListener('touchstart', () => mobileButtonPress('p'), { passive: false });
            
            updateMobileControlsPosition();
        }

        function handleJoystickStart(e) {
            e.preventDefault();
            if (!gameState.gameStarted || gameState.inMenu || gameState.gamePaused) return;
            
            joystickActive = true;
            const rect = e.currentTarget.getBoundingClientRect();
            joystickCenter = {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2
            };
            
            handleJoystickMove(e);
        }

        function handleJoystickMove(e) {
            e.preventDefault();
            if (!joystickActive) return;
            
            const touch = e.touches[0];
            const deltaX = touch.clientX - joystickCenter.x;
            const deltaY = touch.clientY - joystickCenter.y;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const maxDistance = 40; // Raio m√°ximo do joystick
            
            if (distance <= maxDistance) {
                joystickInput.x = deltaX / maxDistance;
                joystickInput.y = deltaY / maxDistance;
            } else {
                joystickInput.x = (deltaX / distance) * (maxDistance / maxDistance);
                joystickInput.y = (deltaY / distance) * (maxDistance / maxDistance);
            }
            
            // Atualizar posi√ß√£o visual do knob
            const knob = document.getElementById('joystick-knob');
            knob.style.transform = `translate(-50%, -50%) translate(${joystickInput.x * maxDistance}px, ${joystickInput.y * maxDistance}px)`;
            
            // Simular teclas pressionadas
            keys['a'] = joystickInput.x < -0.3;
            keys['d'] = joystickInput.x > 0.3;
            keys['w'] = joystickInput.y < -0.5;
            keys['s'] = joystickInput.y > 0.5;
        }

        function handleJoystickEnd(e) {
            e.preventDefault();
            joystickActive = false;
            joystickInput = { x: 0, y: 0 };
            
            // Reset visual
            const knob = document.getElementById('joystick-knob');
            knob.style.transform = 'translate(-50%, -50%)';
            
            // Reset teclas
            keys['a'] = false;
            keys['d'] = false;
            keys['w'] = false;
            keys['s'] = false;
        }

        function mobileButtonPress(action) {
            if (!gameState.gameStarted || gameState.inMenu || gameState.gamePaused) return;
            
            switch(action) {
                case 'jump':
                    keys['w'] = true;
                    setTimeout(() => keys['w'] = false, 100);
                    break;
                case 'crouch':
                    keys['s'] = !keys['s'];
                    break;
                case 'u':
                case 'i':
                case 'o':
                case 'p':
                    useAbility(action.toUpperCase());
                    break;
            }
        }

        function updateMobileControlsPosition() {
            if (!isMobile) return;
            
            const controls = document.getElementById('mobile-controls');
            if (isLandscape) {
                controls.style.display = 'block';
            } else {
                controls.style.display = 'none';
            }
        }

        // ===== MENU PRINCIPAL =====
        function validateMenuInputs() {
            const name = document.getElementById('player-name').value.trim();
            const selectedClass = document.querySelector('.class-option.selected');
            const startBtn = document.getElementById('start-game-btn');
            
            if (name.length >= 2 && selectedClass) {
                startBtn.disabled = false;
            } else {
                startBtn.disabled = true;
            }
        }

        function selectClass(className) {
            // Remove sele√ß√£o anterior
            document.querySelectorAll('.class-option').forEach(option => {
                option.classList.remove('selected');
            });
            
            // Adiciona nova sele√ß√£o
            const selectedOption = document.querySelector(`[data-class="${className}"]`);
            if (selectedOption) {
                selectedOption.classList.add('selected');
                gameState.playerClass = className;
                validateMenuInputs();
            }
        }

        function startGame() {
            const name = document.getElementById('player-name').value.trim();
            if (name.length < 2 || !gameState.playerClass) return;
            
            gameState.playerName = name;
            gameState.inMenu = false;
            gameState.gameStarted = true;
            
            // Esconder menu
            document.getElementById('main-menu').style.display = 'none';
            
            // Configurar personagem
            setupCharacter();
            
            // Mostrar controles mobile se necess√°rio
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
                document.getElementById('abilities-container').style.display = 'none';
            }
            
            // Iniciar cutscene de introdu√ß√£o
            showIntroCutscene();
        }

        function setupCharacter() {
            currentChampion = championClasses[gameState.playerClass];
            
            // Aplicar stats base da classe
            gameState.playerMaxHealth = currentChampion.baseHealth;
            gameState.playerHealth = gameState.playerMaxHealth;
            gameState.playerMaxMana = currentChampion.baseMana;
            gameState.playerMana = gameState.playerMaxMana;
            gameState.playerSpeed = currentChampion.baseSpeed;
            gameState.playerDamage = currentChampion.baseDamage;
            
            // Atualizar tooltips das habilidades
            updateAbilityTooltips();
            
            // Atualizar UI
            updateAllUI();
        }

        function updateAbilityTooltips() {
            if (!currentChampion) return;
            
            currentChampion.abilities.forEach(ability => {
                const key = ability.key.toLowerCase();
                const nameEl = document.getElementById(`tooltip-${key}-name`);
                const descEl = document.getElementById(`tooltip-${key}-desc`);
                const costEl = document.getElementById(`tooltip-${key}-cost`);
                
                if (nameEl) nameEl.textContent = ability.name;
                if (descEl) descEl.textContent = ability.description;
                if (costEl) costEl.textContent = `Custo: ${ability.manaCost} Mana`;
            });
        }

        function exitToMenu() {
            // Salvar progresso antes de sair
            saveProgress();
            
            // Reset do estado
            gameState.inMenu = true;
            gameState.gameStarted = false;
            gameState.gamePaused = false;
            gameState.inCutscene = false;
            gameState.inDialog = false;
            
            // Mostrar menu
            document.getElementById('main-menu').style.display = 'flex';
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'none';
            document.getElementById('abilities-container').style.display = 'flex';
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        // ===== SISTEMA DE FASES =====
        function loadPhase(phaseNumber) {
            gameState.currentPhase = phaseNumber;
            
            // Reset posi√ß√£o do jogador
            gameState.playerPosition = { x: 100, y: 300 };
            gameState.playerVelocity = { x: 0, y: 0 };
            gameState.isGrounded = false;
            gameState.isCrouching = false;
            
            // Limpar arrays
            enemies = [];
            abilityEffects = [];
            particles = [];
            damageNumbers = [];
            
            // Configurar fase espec√≠fica
            switch(phaseNumber) {
                case 1:
                    setupPhase1();
                    break;
                case 2:
                    setupPhase2();
                    break;
                default:
                    setupPhase1();
            }
            
            // Reset c√¢mera
            gameState.cameraOffset = { x: 0, y: 0 };
            gameState.targetCameraOffset = { x: 0, y: 0 };
            
            // Mostrar introdu√ß√£o da fase
            if (phaseNumber === 1) {
                setTimeout(() => showPhaseIntro(phaseNumber), 1000);
            }
        }

        function setupPhase1() {
            // Muralhas da Aurora - Fase expandida
            platforms = [
                // Ch√£o principal
                { x: 0, y: 400, width: CONFIG.WORLD_WIDTH, height: 50, type: 'ground' },
                
                // Plataformas iniciais
                { x: 250, y: 350, width: 100, height: 20, slippery: true },
                { x: 400, y: 300, width: 80, height: 20, slippery: true },
                { x: 550, y: 250, width: 120, height: 20 },
                
                // Se√ß√£o com gaps para crouch
                { x: 750, y: 320, width: 150, height: 80 }, // Plataforma alta
                { x: 750, y: 380, width: 150, height: 20 }, // Gap baixo para crouch
                
                // √Årea de combate
                { x: 1000, y: 350, width: 200, height: 20 },
                { x: 1300, y: 300, width: 150, height: 20, slippery: true },
                { x: 1550, y: 250, width: 100, height: 20 },
                
                // Plataformas elevadas
                { x: 1750, y: 200, width: 120, height: 20 },
                { x: 1950, y: 150, width: 100, height: 20, slippery: true },
                { x: 2150, y: 200, width: 150, height: 20 },
                
                // √Årea antes do boss
                { x: 2400, y: 350, width: 300, height: 20 },
                { x: 2800, y: 300, width: 200, height: 20 },
                { x: 3100, y: 350, width: 250, height: 20 },
                
                // Se√ß√£o de desafio
                { x: 3450, y: 300, width: 80, height: 20, slippery: true },
                { x: 3600, y: 250, width: 80, height: 20, slippery: true },
                { x: 3750, y: 200, width: 80, height: 20 },
                { x: 3900, y: 250, width: 80, height: 20, slippery: true },
                { x: 4050, y: 300, width: 80, height: 20 },
                
                // √Årea final antes do boss
                { x: 4200, y: 350, width: 400, height: 20 },
                { x: 4650, y: 300, width: 200, height: 20 },
                
                // Arena do boss (final da fase)
                { x: 4900, y: 350, width: 100, height: 50 } // Trigger para boss fight
            ];
            
            // Sentinelas de Gelo espalhadas pela fase
            enemies = [
                {
                    type: 'sentinel',
                    name: 'Sentinela G√©lida',
                    position: { x: 600, y: 350 },
                    health: 80,
                    maxHealth: 80,
                    damage: 12,
                    speed: 1.5,
                    pattern: 'patrol',
                    patrolStartX: 550,
                    patrolRange: 100,
                    xpValue: 35,
                    attackCooldown: 0,
                    lastAttack: 0
                },
                {
                    type: 'sentinel',
                    name: 'Sentinela G√©lida',
                    position: { x: 1100, y: 300 },
                    health: 80,
                    maxHealth: 80,
                    damage: 12,
                    speed: 1.5,
                    pattern: 'patrol',
                    patrolStartX: 1050,
                    patrolRange: 150,
                    xpValue: 35,
                    attackCooldown: 0,
                    lastAttack: 0
                },
                {
                    type: 'sentinel',
                    name: 'Sentinela G√©lida',
                    position: { x: 1800, y: 150 },
                    health: 80,
                    maxHealth: 80,
                    damage: 12,
                    speed: 1.5,
                    pattern: 'patrol',
                    patrolStartX: 1750,
                    patrolRange: 120,
                    xpValue: 35,
                    attackCooldown: 0,
                    lastAttack: 0
                },
                {
                    type: 'sentinel',
                    name: 'Sentinela G√©lida',
                    position: { x: 2500, y: 300 },
                    health: 80,
                    maxHealth: 80,
                    damage: 12,
                    speed: 1.5,
                    pattern: 'patrol',
                    patrolStartX: 2450,
                    patrolRange: 200,
                    xpValue: 35,
                    attackCooldown: 0,
                    lastAttack: 0
                },
                {
                    type: 'sentinel',
                    name: 'Sentinela G√©lida',
                    position: { x: 3800, y: 150 },
                    health: 80,
                    maxHealth: 80,
                    damage: 12,
                    speed: 1.5,
                    pattern: 'patrol',
                    patrolStartX: 3750,
                    patrolRange: 100,
                    xpValue: 35,
                    attackCooldown: 0,
                    lastAttack: 0
                }
            ];
            
            // Checkpoints
            checkpoints = [
                { x: 100, name: 'start', description: 'In√≠cio da Jornada' },
                { x: 1000, name: 'combat_area', description: '√Årea de Combate' },
                { x: 2400, name: 'mid_point', description: 'Meio da Muralha' },
                { x: 4200, name: 'boss_approach', description: 'Aproxima√ß√£o do Boss' }
            ];
            
            // Background layers para parallax
            backgroundLayers = [
                { color: '#1a237e', speed: 0.1, type: 'sky' },
                { color: '#283593', speed: 0.3, type: 'mountains' },
                { color: '#3949ab', speed: 0.5, type: 'hills' },
                { color: '#5c6bc0', speed: 0.7, type: 'foreground' }
            ];
        }

        function setupPhase2() {
            // Torre de Cristal - Fase vertical (placeholder para expans√£o futura)
            platforms = [
                { x: 0, y: 400, width: 2500, height: 50, type: 'ground' },
                { x: 300, y: 350, width: 100, height: 20 },
                { x: 500, y: 300, width: 100, height: 20 },
                { x: 700, y: 250, width: 100, height: 20 },
                { x: 900, y: 200, width: 100, height: 20 }
            ];
            
            enemies = [];
            
            backgroundLayers = [
                { color: '#0d47a1', speed: 0.1, type: 'sky' },
                { color: '#1565c0', speed: 0.3, type: 'mountains' },
                { color: '#1976d2', speed: 0.5, type: 'hills' }
            ];
        }

        // ===== CUTSCENES E NARRATIVA =====
        function showIntroCutscene() {
            gameState.inCutscene = true;
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            
            overlay.style.display = 'flex';
            
            const introSequence = [
                {
                    title: "O DESEQUIL√çBRIO",
                    text: "O mundo treme sob o peso do desequil√≠brio. Ignys, o Reino do Fogo, deseja guerra e j√° move suas tropas em dire√ß√£o aos reinos vizinhos."
                },
                {
                    title: "O CORA√á√ÉO DE GELO",
                    text: "Em Tup√£ry, o Cora√ß√£o de Gelo guarda a metade maligna de Anhang√°, o esp√≠rito que traz caos."
                },
                {
                    title: "A CONVOCA√á√ÉO",
                    text: `Umbra convoca ${gameState.playerName}, o Escolhido: recuperar o Cora√ß√£o de Gelo e impedir que Ignys obtenha poder suficiente para dominar todos os reinos.`
                },
                {
                    title: "O DESTINO",
                    text: "Cada passo, cada luta, cada escolha ser√° decisiva para a sobreviv√™ncia de todos."
                }
            ];
            
            let currentSequence = 0;
            
            function showNextSequence() {
                if (currentSequence < introSequence.length) {
                    const sequence = introSequence[currentSequence];
                    
                    titleElement.textContent = sequence.title;
                    textElement.textContent = sequence.text;
                    
                    titleElement.style.animation = 'none';
                    textElement.style.animation = 'none';
                    
                    void titleElement.offsetWidth; // Trigger reflow
                    void textElement.offsetWidth;
                    
                    titleElement.style.animation = 'fadeInText 2s forwards';
                    textElement.style.animation = 'fadeInText 3s forwards 0.5s';
                                        currentSequence++;
                    setTimeout(showNextSequence, 5000);
                } else {
                    // Ap√≥s a cutscene, iniciar a primeira fase
                    overlay.style.display = 'none';
                    gameState.inCutscene = false;
                    loadPhase(1);
                }
            }
            
            showNextSequence();
        }

        function showPhaseIntro(phaseNumber) {
            gameState.inCutscene = true;
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            
            overlay.style.display = 'flex';
            
            let phaseTitle = '';
            let phaseDescription = '';
            
            switch(phaseNumber) {
                case 1:
                    phaseTitle = "MISS√ÉO 1 ‚Äì AS MURALHAS DA AURORA";
                    phaseDescription = `${gameState.playerName}, prove seu valor nas terras geladas de Tup√£ry. Tarek, o Guerreiro, bloqueia a passagem adiante. Derrote as Sentinelas G√©lidas e mostre que voc√™ √© digno de prosseguir!`;
                    break;
                case 2:
                    phaseTitle = "MISS√ÉO 2 ‚Äì TORRE DE CRISTAL";
                    phaseDescription = "Solenne, a Maga da Luz, alerta sobre os perigos do Cora√ß√£o de Gelo.";
                    break;
            }
            
            titleElement.textContent = phaseTitle;
            textElement.textContent = phaseDescription;
            
            titleElement.style.animation = 'none';
            textElement.style.animation = 'none';
            void titleElement.offsetWidth;
            void textElement.offsetWidth;
            titleElement.style.animation = 'fadeInText 2s forwards';
            textElement.style.animation = 'fadeInText 3s forwards 0.5s';
            
            setTimeout(() => {
                overlay.style.display = 'none';
                gameState.inCutscene = false;
                
                // Salvar checkpoint inicial
                saveCheckpoint('phase_start');
            }, 6000);
        }

        function skipCutscene() {
            const overlay = document.getElementById('cinematic-overlay');
            overlay.style.display = 'none';
            gameState.inCutscene = false;
            
            if (gameState.currentPhase === 0) {
                loadPhase(1);
            }
        }

        function showDialog(speaker, text, options = null) {
            gameState.inDialog = true;
            const dialogContainer = document.getElementById('dialog-container');
            const speakerElement = document.getElementById('dialog-speaker');
            const textElement = document.getElementById('dialog-text');
            const optionsElement = document.getElementById('dialog-options');
            
            dialogContainer.style.display = 'block';
            speakerElement.textContent = speaker;
            textElement.textContent = text;
            
            // Limpar op√ß√µes anteriores
            optionsElement.innerHTML = '';
            
            if (options && options.length > 0) {
                options.forEach((option, index) => {
                    const button = document.createElement('div');
                    button.className = 'dialog-option';
                    button.textContent = option.text;
                    button.addEventListener('click', () => {
                        dialogContainer.style.display = 'none';
                        gameState.inDialog = false;
                        if (option.action) option.action();
                    });
                    optionsElement.appendChild(button);
                });
            } else {
                const button = document.createElement('div');
                button.className = 'dialog-option';
                button.textContent = 'Continuar';
                button.addEventListener('click', () => {
                    dialogContainer.style.display = 'none';
                    gameState.inDialog = false;
                });
                optionsElement.appendChild(button);
            }
        }

        // ===== SISTEMA DE CHECKPOINTS =====
        function saveCheckpoint(checkpointName) {
            gameState.currentCheckpoint = checkpointName;
            
            const checkpointData = {
                name: checkpointName,
                phase: gameState.currentPhase,
                position: { ...gameState.playerPosition },
                health: gameState.playerHealth,
                mana: gameState.playerMana,
                xp: gameState.playerXP,
                level: gameState.playerLevel
            };
            
            setCookie('tupary_checkpoint', JSON.stringify(checkpointData));
            showCheckpointNotification('Checkpoint Salvo', `Progresso salvo em: ${getCheckpointDescription(checkpointName)}`);
        }

        function loadCheckpoint() {
            const checkpointData = getCookie('tupary_checkpoint');
            if (checkpointData) {
                try {
                    const data = JSON.parse(checkpointData);
                    
                    gameState.currentPhase = data.phase;
                    gameState.currentCheckpoint = data.name;
                    gameState.playerPosition = { ...data.position };
                    gameState.playerHealth = data.health;
                    gameState.playerMana = data.mana;
                    gameState.playerXP = data.xp;
                    gameState.playerLevel = data.level;
                    
                    loadPhase(data.phase);
                    return true;
                } catch (e) {
                    console.error('Erro ao carregar checkpoint:', e);
                }
            }
            return false;
        }

        function getCheckpointDescription(checkpointName) {
            const checkpoint = checkpoints.find(cp => cp.name === checkpointName);
            return checkpoint ? checkpoint.description : 'Localiza√ß√£o Desconhecida';
        }

        function showCheckpointNotification(title, description) {
            const notification = document.getElementById('checkpoint-notification');
            const titleEl = notification.querySelector('.checkpoint-text');
            const descEl = notification.querySelector('.checkpoint-description');
            
            titleEl.textContent = title;
            descEl.textContent = description;
            
            notification.style.display = 'block';
            notification.style.animation = 'checkpointPulse 2s ease-in-out';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }

        function restartFromCheckpoint() {
            togglePause();
            
            if (loadCheckpoint()) {
                showCheckpointNotification('Checkpoint Carregado', 'Retornando ao √∫ltimo checkpoint salvo...');
            } else {
                // Se n√£o h√° checkpoint, reiniciar fase atual
                loadPhase(gameState.currentPhase);
            }
        }

        // ===== LOOP PRINCIPAL DO JOGO =====
        function gameLoop(timestamp) {
            // Calcular delta time
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Limitar delta time para evitar grandes saltos
            deltaTime = Math.min(deltaTime, CONFIG.DELTA_TIME_CAP);
            
            if (!gameState.gamePaused && !gameState.inMenu) {
                // Atualizar l√≥gica do jogo apenas se n√£o estiver pausado
                if (!gameState.inCutscene && !gameState.inDialog) {
                    update(deltaTime);
                }
                
                // Sempre renderizar
                render();
            }
            
            // Continuar o loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            // Atualizar jogador
            updatePlayer(deltaTime);
            
            // Atualizar inimigos
            updateEnemies(deltaTime);
            
            // Atualizar efeitos de habilidades
            updateAbilityEffects(deltaTime);
            
            // Atualizar part√≠culas
            updateParticles(deltaTime);
            
            // Atualizar n√∫meros de dano
            updateDamageNumbers(deltaTime);
            
            // Atualizar cooldowns
            updateCooldowns(deltaTime);
            
            // Regenera√ß√£o
            updateRegeneration(deltaTime);
            
            // Atualizar c√¢mera
            updateCamera(deltaTime);
            
            // Verificar checkpoints
            checkCheckpoints();
            
            // Verificar condi√ß√µes de vit√≥ria/derrota
            checkGameConditions();
        }

        function updatePlayer(deltaTime) {
            // Movimento horizontal
            let moveX = 0;
            
            if (keys['a'] || keys['arrowleft']) moveX = -1;
            if (keys['d'] || keys['arrowright']) moveX = 1;
            
            // Aplicar velocidade
            gameState.playerVelocity.x = moveX * gameState.playerSpeed;
            
            // Pular
            if ((keys['w'] || keys['arrowup'] || keys[' ']) && gameState.isGrounded && !gameState.isCrouching) {
                gameState.playerVelocity.y = -CONFIG.JUMP_FORCE;
                gameState.isGrounded = false;
                
                // Part√≠culas de pulo
                addParticles('jumpDust', gameState.playerPosition.x + 25, gameState.playerPosition.y + 50, 8);
                
                // Reset da tecla para evitar pulos m√∫ltiplos
                keys['w'] = false;
                keys['arrowup'] = false;
                keys[' '] = false;
            }
            
            // Crouch (abaixar)
            if (keys['s'] || keys['arrowdown']) {
                if (!gameState.isCrouching && gameState.isGrounded) {
                    gameState.isCrouching = true;
                    gameState.playerPosition.y += CONFIG.NORMAL_HEIGHT - CONFIG.CROUCH_HEIGHT;
                }
            } else {
                if (gameState.isCrouching) {
                    // Verificar se h√° espa√ßo para ficar em p√©
                    const newY = gameState.playerPosition.y - (CONFIG.NORMAL_HEIGHT - CONFIG.CROUCH_HEIGHT);
                    if (canStandUp(gameState.playerPosition.x, newY)) {
                        gameState.isCrouching = false;
                        gameState.playerPosition.y = newY;
                    }
                }
            }
            
            // Aplicar gravidade
            gameState.playerVelocity.y += CONFIG.GRAVITY;
            
            // Limitar velocidade vertical
            if (gameState.playerVelocity.y > 15) {
                gameState.playerVelocity.y = 15;
            }
            
            // Atualizar posi√ß√£o
            gameState.playerPosition.x += gameState.playerVelocity.x;
            gameState.playerPosition.y += gameState.playerVelocity.y;
            
            // Verificar colis√µes
            checkPlatformCollisions();
            checkEnemyCollisions();
            checkEffectCollisions();
            
            // Atualizar anima√ß√£o
            updatePlayerAnimation();
            
            // Atualizar dire√ß√£o
            if (moveX > 0) gameState.facing = 'right';
            if (moveX < 0) gameState.facing = 'left';
            
            // Limitar jogador dentro do mundo
            if (gameState.playerPosition.x < 0) {
                gameState.playerPosition.x = 0;
                gameState.playerVelocity.x = 0;
            }
            if (gameState.playerPosition.x > CONFIG.WORLD_WIDTH - 50) {
                gameState.playerPosition.x = CONFIG.WORLD_WIDTH - 50;
                gameState.playerVelocity.x = 0;
            }
            
            // Verificar queda fora do mundo
            if (gameState.playerPosition.y > CONFIG.WORLD_HEIGHT + 100) {
                takeDamage(gameState.playerMaxHealth); // Morte instant√¢nea por queda
            }
            
            // Reduzir invencibilidade
            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= deltaTime;
                if (gameState.invincibilityTimer <= 0) {
                    gameState.isInvincible = false;
                }
            }
        }

        function canStandUp(x, y) {
            const playerWidth = 50;
            const playerHeight = CONFIG.NORMAL_HEIGHT;
            
            // Verificar colis√£o com plataformas
            for (const platform of platforms) {
                if (x < platform.x + platform.width &&
                    x + playerWidth > platform.x &&
                    y < platform.y + platform.height &&
                    y + playerHeight > platform.y) {
                    return false;
                }
            }
            return true;
        }

        function checkPlatformCollisions() {
            gameState.isGrounded = false;
            const playerWidth = 50;
            const playerHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
            
            for (const platform of platforms) {
                // Verificar colis√£o AABB
                if (gameState.playerPosition.x < platform.x + platform.width &&
                    gameState.playerPosition.x + playerWidth > platform.x &&
                    gameState.playerPosition.y < platform.y + platform.height &&
                    gameState.playerPosition.y + playerHeight > platform.y) {
                    
                    // Colis√£o de cima (aterrissando)
                    if (gameState.playerVelocity.y > 0 && 
                        gameState.playerPosition.y + playerHeight - gameState.playerVelocity.y <= platform.y) {
                        gameState.playerPosition.y = platform.y - playerHeight;
                        gameState.playerVelocity.y = 0;
                        gameState.isGrounded = true;
                        
                        // Part√≠culas de aterrissagem
                        if (gameState.playerVelocity.y > 8) {
                            addParticles('landDust', gameState.playerPosition.x + 25, gameState.playerPosition.y + playerHeight, 12);
                            screenShake(3, 150);
                        }
                        
                        // Efeito de plataforma escorregadia
                        if (platform.slippery && Math.abs(gameState.playerVelocity.x) > 0) {
                            gameState.playerVelocity.x *= 1.2; // Aumenta deslizamento
                        }
                    }
                    // Colis√£o de baixo
                    else if (gameState.playerVelocity.y < 0) {
                        gameState.playerPosition.y = platform.y + platform.height;
                        gameState.playerVelocity.y = 0;
                    }
                    // Colis√£o lateral
                    else if (gameState.playerVelocity.x !== 0) {
                        if (gameState.playerPosition.x < platform.x) {
                            gameState.playerPosition.x = platform.x - playerWidth;
                        } else {
                            gameState.playerPosition.x = platform.x + platform.width;
                        }
                        gameState.playerVelocity.x = 0;
                    }
                }
            }
        }

        function checkEnemyCollisions() {
            if (gameState.isInvincible) return;
            
            const playerWidth = 50;
            const playerHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
            
            for (const enemy of enemies) {
                // Verificar colis√£o com jogador
                const dx = (gameState.playerPosition.x + playerWidth/2) - (enemy.position.x + 25);
                const dy = (gameState.playerPosition.y + playerHeight/2) - (enemy.position.y + 25);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 35) {
                    takeDamage(enemy.damage);
                    
                    // Knockback
                    const knockbackForce = 8;
                    gameState.playerVelocity.x = dx > 0 ? knockbackForce : -knockbackForce;
                    gameState.playerVelocity.y = -5;
                    
                    break; // Apenas um dano por frame
                }
            }
        }

        function checkEffectCollisions() {
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                
                if (effect.damage && effect.origin === 'player' && effect.active !== false) {
                    // Verificar colis√£o com inimigos
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        
                        // Verificar se j√° atingiu este inimigo (para efeitos piercing)
                        if (effect.hitTargets && effect.hitTargets.includes(enemy)) {
                            continue;
                        }
                        
                        const dx = (enemy.position.x + 25) - (effect.x + effect.width/2);
                        const dy = (enemy.position.y + 25) - (effect.y + effect.height/2);
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 40) {
                            // Causar dano
                            enemy.health -= effect.damage;
                            
                            // Adicionar √† lista de alvos atingidos
                            if (effect.hitTargets) {
                                effect.hitTargets.push(enemy);
                            }
                            
                            // Efeitos visuais
                            showDamageNumber(effect.damage, enemy.position.x + 25, enemy.position.y);
                            addParticles('hitSpark', enemy.position.x + 25, enemy.position.y + 25, 8);
                            screenShake(2, 100);
                            
                            // Knockback no inimigo
                            if (effect.knockback) {
                                const knockDirection = dx > 0 ? 1 : -1;
                                enemy.position.x += knockDirection * effect.knockback;
                            }
                            
                            // Efeitos especiais
                            if (effect.freezeChance && Math.random() < effect.freezeChance) {
                                enemy.frozen = true;
                                enemy.frozenTimer = 2000;
                                addParticles('freezeEffect', enemy.position.x + 25, enemy.position.y + 25, 15);
                            }
                            
                            // Verificar se inimigo morreu
                            if (enemy.health <= 0) {
                                // Ganhar XP
                                gainXP(enemy.xpValue);
                                
                                // Efeitos de morte
                                addParticles('deathExplosion', enemy.position.x + 25, enemy.position.y + 25, 20);
                                screenShake(4, 200);
                                
                                // Remover inimigo
                                enemies.splice(j, 1);
                            }
                            
                            // Desativar efeito se n√£o for piercing
                            if (!effect.piercing) {
                                effect.active = false;
                            }
                        }
                    }
                }
                
                // Verificar colis√£o de efeitos inimigos com jogador
                if (effect.damage && effect.origin === 'enemy' && !gameState.isInvincible) {
                    const playerWidth = 50;
                    const playerHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
                    
                    const dx = (gameState.playerPosition.x + playerWidth/2) - (effect.x + effect.width/2);
                    const dy = (gameState.playerPosition.y + playerHeight/2) - (effect.y + effect.height/2);
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < 35) {
                        takeDamage(effect.damage);
                        effect.active = false;
                    }
                }
            }
        }

        function updatePlayerAnimation() {
            if (!gameState.isGrounded) {
                gameState.currentAnimation = 'jump';
            } else if (gameState.isCrouching) {
                gameState.currentAnimation = 'crouch';
            } else if (Math.abs(gameState.playerVelocity.x) > 0.1) {
                gameState.currentAnimation = 'walk';
            } else {
                gameState.currentAnimation = 'idle';
            }
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Reduzir timer de congelamento
                if (enemy.frozen) {
                    enemy.frozenTimer -= deltaTime;
                    if (enemy.frozenTimer <= 0) {
                        enemy.frozen = false;
                    }
                    continue; // Pular atualiza√ß√£o se congelado
                }
                
                // Padr√£o de movimento
                if (enemy.pattern === 'patrol') {
                    updateEnemyPatrol(enemy, deltaTime);
                }
                
                // IA de combate
                updateEnemyAI(enemy, deltaTime);
                
                // Aplicar gravidade
                enemy.velocity = enemy.velocity || { x: 0, y: 0 };
                enemy.velocity.y += CONFIG.GRAVITY;
                
                // Atualizar posi√ß√£o
                enemy.position.x += enemy.velocity.x;
                enemy.position.y += enemy.velocity.y;
                
                // Verificar colis√µes com plataformas
                checkEnemyPlatformCollisions(enemy);
            }
        }

        function updateEnemyPatrol(enemy, deltaTime) {
            if (!enemy.direction) {
                enemy.direction = 1;
                enemy.patrolStartX = enemy.position.x;
            }
            
            enemy.position.x += enemy.speed * enemy.direction;
            
            // Verificar limites de patrulha
            if (enemy.position.x > enemy.patrolStartX + enemy.patrolRange) {
                enemy.direction = -1;
            } else if (enemy.position.x < enemy.patrolStartX - enemy.patrolRange) {
                enemy.direction = 1;
            }
        }

        function updateEnemyAI(enemy, deltaTime) {
            const distanceToPlayer = Math.abs(enemy.position.x - gameState.playerPosition.x);
            const playerInRange = distanceToPlayer < 200;
            
            if (playerInRange) {
                // Atacar jogador se estiver pr√≥ximo
                enemy.attackCooldown -= deltaTime;
                
                if (enemy.attackCooldown <= 0) {
                    enemyAttack(enemy);
                    enemy.attackCooldown = 2000 + Math.random() * 1000; // 2-3 segundos
                }
                
                // Mover em dire√ß√£o ao jogador (lentamente)
                if (distanceToPlayer > 60) {
                    const direction = gameState.playerPosition.x > enemy.position.x ? 1 : -1;
                    enemy.position.x += direction * enemy.speed * 0.5;
                }
            }
        }

        function enemyAttack(enemy) {
            const direction = gameState.playerPosition.x > enemy.position.x ? 1 : -1;
            
            switch(enemy.type) {
                case 'sentinel':
                    // Proj√©til de gelo
                    addAbilityEffect({
                        type: 'enemyIceShot',
                        x: enemy.position.x + (direction > 0 ? 50 : -25),
                        y: enemy.position.y + 15,
                        width: 20,
                        height: 6,
                        duration: 2000,
                        damage: enemy.damage,
                        direction: direction,
                        speed: 5,
                        origin: 'enemy'
                    });
                    
                    addParticles('enemyMuzzle', enemy.position.x + 25, enemy.position.y + 15, 6);
                    break;
            }
        }

        function checkEnemyPlatformCollisions(enemy) {
            enemy.isGrounded = false;
            
            for (const platform of platforms) {
                if (enemy.position.x < platform.x + platform.width &&
                    enemy.position.x + 50 > platform.x &&
                    enemy.position.y < platform.y + platform.height &&
                    enemy.position.y + 50 > platform.y) {
                    
                    if (enemy.velocity.y > 0 && 
                        enemy.position.y + 50 - enemy.velocity.y <= platform.y) {
                        enemy.position.y = platform.y - 50;
                        enemy.velocity.y = 0;
                        enemy.isGrounded = true;
                    }
                }
            }
        }

        function updateAbilityEffects(deltaTime) {
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                effect.timer -= deltaTime;
                
                // Movimento baseado no tipo
                switch(effect.type) {
                    case 'iceShot':
                    case 'piercingOrb':
                    case 'enemyIceShot':
                        effect.x += effect.speed * effect.direction;
                        
                        // Part√≠culas de rastro
                        if (Math.random() < 0.4) {
                            addParticles('projectileTrail', effect.x + effect.width/2, effect.y + effect.height/2, 2);
                        }
                        break;
                        
                    case 'closeOrb':
                        effect.x += effect.speed * effect.direction;
                        
                        // Orbe pr√≥ximo explode ao atingir algo ou ap√≥s dist√¢ncia
                        if (effect.explosive && (effect.timer < effect.duration - 1000 || Math.abs(effect.x - effect.startX) > 150)) {
                            // Criar explos√£o
                            addAbilityEffect({
                                type: 'explosion',
                                x: effect.x - 30,
                                y: effect.y - 30,
                                width: 90,
                                height: 90,
                                duration: 400,
                                damage: effect.damage * 1.5,
                                origin: effect.origin
                            });
                            
                            addParticles('explosion', effect.x + effect.width/2, effect.y + effect.height/2, 25);
                            screenShake(6, 250);
                            effect.timer = 0; // Remove o orbe
                        }
                        break;
                }
                
                // Remover efeitos expirados
                if (effect.timer <= 0) {
                    abilityEffects.splice(i, 1);
                }
            }
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Atualizar posi√ß√£o
                particle.x += particle.vx * (deltaTime / 16);
                particle.y += particle.vy * (deltaTime / 16);
                
                // Aplicar gravidade em algumas part√≠culas
                if (particle.gravity) {
                    particle.vy += CONFIG.GRAVITY * 0.3;
                }
                
                // Reduzir vida
                particle.life -= deltaTime;
                
                // Fade out
                if (particle.life < particle.maxLife * 0.3) {
                    particle.alpha = particle.life / (particle.maxLife * 0.3);
                }
                
                // Remover part√≠culas mortas
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Limitar n√∫mero de part√≠culas
            if (particles.length > CONFIG.MAX_PARTICLES) {
                particles.splice(0, particles.length - CONFIG.MAX_PARTICLES);
            }
            
            // Adicionar neve ambiente
            if (Math.random() < CONFIG.SNOW_SPAWN_RATE) {
                addParticles('snow', Math.random() * (canvas.width + gameState.cameraOffset.x), -10 + gameState.cameraOffset.y, 1);
            }
        }

        function updateDamageNumbers(deltaTime) {
            const damageContainer = document.getElementById('particle-container');
            const existingNumbers = damageContainer.querySelectorAll('.damage-number, .xp-number');
            
            existingNumbers.forEach(number => {
                const timeLeft = parseFloat(number.dataset.timeLeft) - deltaTime;
                number.dataset.timeLeft = timeLeft;
                
                if (timeLeft <= 0) {
                    number.remove();
                }
            });
        }

        function updateCooldowns(deltaTime) {
            for (const key in gameState.abilitiesCooldown) {
                if (gameState.abilitiesCooldown[key] > 0) {
                    gameState.abilitiesCooldown[key] -= deltaTime / 1000;
                    
                    // Atualizar visualiza√ß√£o
                    updateCooldownVisual(key);
                }
            }
        }

        function updateCooldownVisual(key) {
            const btn = document.getElementById(`ability-${key.toLowerCase()}`);
            const overlay = btn?.querySelector('.cooldown-overlay');
            
            if (btn && overlay) {
                const cooldownRatio = gameState.abilitiesCooldown[key] / gameState.abilitiesMaxCooldown[key];
                
                if (cooldownRatio > 0) {
                    btn.classList.add('cooldown');
                    const angle = 360 * (1 - cooldownRatio);
                    overlay.style.background = `conic-gradient(from 0deg, transparent ${angle}deg, rgba(0, 0, 0, 0.8) ${angle}deg)`;
                } else {
                    btn.classList.remove('cooldown');
                    overlay.style.background = '';
                }
            }
        }

        function updateRegeneration(deltaTime) {
            // Regenera√ß√£o de mana
            if (gameState.playerMana < gameState.playerMaxMana) {
                gameState.playerMana += CONFIG.MANA_REGEN_RATE * (deltaTime / 1000);
                gameState.playerMana = Math.min(gameState.playerMana, gameState.playerMaxMana);
                updateManaBar();
            }
            
            // Regenera√ß√£o lenta de vida (apenas fora de combate)
            if (gameState.playerHealth < gameState.playerMaxHealth && !gameState.isInvincible) {
                gameState.playerHealth += CONFIG.HEALTH_REGEN_RATE * (deltaTime / 1000);
                gameState.playerHealth = Math.min(gameState.playerHealth, gameState.playerMaxHealth);
                updateHealthBar();
            }
        }

        function updateCamera(deltaTime) {
            // Calcular posi√ß√£o alvo da c√¢mera
            gameState.targetCameraOffset.x = gameState.playerPosition.x - canvas.width / 2;
            gameState.targetCameraOffset.y = gameState.playerPosition.y - canvas.height / 2;
            
            // Limitar c√¢mera
            gameState.targetCameraOffset.x = Math.max(0, Math.min(gameState.targetCameraOffset.x, CONFIG.WORLD_WIDTH - canvas.width));
            gameState.targetCameraOffset.y = Math.max(-100, Math.min(gameState.targetCameraOffset.y, CONFIG.WORLD_HEIGHT - canvas.height + 100));
            
            // Suavizar movimento
            gameState.cameraOffset.x += (gameState.targetCameraOffset.x - gameState.cameraOffset.x) * CONFIG.CAMERA_SMOOTHING;
            gameState.cameraOffset.y += (gameState.targetCameraOffset.y - gameState.cameraOffset.y) * CONFIG.CAMERA_SMOOTHING;
        }

        function checkCheckpoints() {
            for (const checkpoint of checkpoints) {
                if (Math.abs(gameState.playerPosition.x - checkpoint.x) < 50 && 
                    gameState.currentCheckpoint !== checkpoint.name) {
                    saveCheckpoint(checkpoint.name);
                    break;
                }
            }
            
            // Verificar trigger do boss
            if (gameState.playerPosition.x > 4900 && !gameState.inBossFight && !gameState.bossDefeated) {
                triggerBossFight();
            }
        }

        function checkGameConditions() {
            // Verificar morte do jogador
            if (gameState.playerHealth <= 0) {
                gameOver();
            }
            
            // Verificar vit√≥ria da fase
            if (gameState.bossDefeated && gameState.playerPosition.x > 4950) {
                completePhase();
            }
        }

        // ===== SISTEMA DE HABILIDADES =====
        function useAbility(key) {
            if (!currentChampion || gameState.abilitiesCooldown[key] > 0) return;
            
            const ability = currentChampion.abilities.find(a => a.key === key);
            if (!ability) return;
            
            if (gameState.playerMana < ability.manaCost) {
                // Feedback visual de mana insuficiente
                flashScreen('#0066ff', 200);
                return;
            }
            
            // Consumir mana
            gameState.playerMana -= ability.manaCost;
            
            // Definir cooldown
            gameState.abilitiesCooldown[key] = ability.cooldown;
            
            // Executar habilidade
            ability.execute();
            
            // Atualizar UI
            updateManaBar();
        }

        function addAbilityEffect(effect) {
            effect.timer = effect.duration || 1000;
            effect.origin = effect.origin || 'player';
            effect.active = effect.active !== false;
            
            // Salvar posi√ß√£o inicial para alguns efeitos
            if (effect.type === 'closeOrb') {
                effect.startX = effect.x;
            }
            
            abilityEffects.push(effect);
        }

        // ===== SISTEMA DE PART√çCULAS =====
        function addParticles(type, x, y, count) {
            for (let i = 0; i < count; i++) {
                const particle = createParticle(type, x, y);
                particles.push(particle);
            }
        }

        function createParticle(type, x, y) {
            const baseParticle = {
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                size: 2 + Math.random() * 3,
                alpha: 1,
                gravity: false
            };
            
            switch(type) {
                case 'snow':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: 1 + Math.random() * 2,
                        size: 2 + Math.random() * 4,
                        color: '#ffffff',
                        life: 8000 + Math.random() * 4000,
                        maxLife: 12000
                    };
                    
                case 'jumpDust':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -1 - Math.random() * 2,
                        color: '#cccccc',
                        life: 400 + Math.random() * 200,
                        maxLife: 600,
                        gravity: true
                    };
                    
                case 'landDust':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 4,
                        vy: -2 - Math.random() * 3,
                        color: '#dddddd',
                        life: 500 + Math.random() * 300,
                        maxLife: 800,
                        gravity: true
                    };
                    
                case 'iceShard':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 6,
                        vy: -1 - Math.random() * 3,
                        color: '#88d8f7',
                        life: 600 + Math.random() * 400,
                        maxLife: 1000
                    };
                    
                case 'dashIce':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 4,
                        color: '#a8d0e6',
                        life: 400 + Math.random() * 300,
                        maxLife: 700
                    };
                    
                case 'hitSpark':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        color: '#ffff00',
                        life: 300 + Math.random() * 200,
                        maxLife: 500
                    };
                    
                case 'deathExplosion':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: Math.random() > 0.5 ? '#ff6666' : '#ffaa66',
                        life: 800 + Math.random() * 400,
                        maxLife: 1200,
                        size: 3 + Math.random() * 5
                    };
                    
                case 'explosion':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 12,
                        color: Math.random() > 0.3 ? '#ff8800' : '#ffff00',
                        life: 600 + Math.random() * 400,
                        maxLife: 1000,
                        size: 4 + Math.random() * 6
                    };
                    
                case 'projectileTrail':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        color: '#88d8f7',
                        life: 300 + Math.random() * 200,
                        maxLife: 500,
                        size: 1 + Math.random() * 2
                    };
                    
                default:
                    return {
                        ...baseParticle,
                        color: '#ffffff',
                        life: 500,
                        maxLife: 500
                    };
            }
        }

        // ===== SISTEMA DE DANO E COMBATE =====
        function takeDamage(amount) {
            if (gameState.isInvincible) return;
            
            gameState.playerHealth -= amount;
            gameState.playerHealth = Math.max(0, gameState.playerHealth);
            
            // Ativar invencibilidade tempor√°ria
            gameState.isInvincible = true;
            gameState.invincibilityTimer = CONFIG.INVINCIBILITY_DURATION;
            
            // Efeitos visuais
            flashScreen('#ff0000', CONFIG.DAMAGE_FLASH_DURATION);
            screenShake(5, 300);
            showDamageNumber(amount, gameState.playerPosition.x + 25, gameState.playerPosition.y, true);
            
            // Atualizar UI
            updateHealthBar();
            
            // Verificar morte
            if (gameState.playerHealth <= 0) {
                gameOver();
            }
        }

        function showDamageNumber(damage, x, y, isPlayerDamage = false) {
            const damageContainer = document.getElementById('particle-container');
            const damageNumber = document.createElement('div');
            
            damageNumber.className = isPlayerDamage ? 'damage-number' : 'damage-number';
            damageNumber.textContent = Math.round(damage);
            damageNumber.style.left = (x - gameState.cameraOffset.x) + 'px';
            damageNumber.style.top = (y - gameState.cameraOffset.y) + 'px';
            damageNumber.style.color = isPlayerDamage ? '#ff3333' : '#ffff00';
            damageNumber.dataset.timeLeft = '1000';
            
            damageContainer.appendChild(damageNumber);
        }

        function gainXP(amount) {
            gameState.playerXP += amount;
            
            // Mostrar n√∫mero de XP
            const xpContainer = document.getElementById('particle-container');
            const xpNumber = document.createElement('div');
            xpNumber.className = 'xp-number';
            xpNumber.textContent = `+${amount} XP`;
            xpNumber.style.left = (gameState.playerPosition.x + 25 - gameState.cameraOffset.x) + 'px';
            xpNumber.style.top = (gameState.playerPosition.y - gameState.cameraOffset.y) + 'px';
            xpNumber.dataset.timeLeft = '1500';
            xpContainer.appendChild(xpNumber);
            
            // Part√≠culas de XP
            addParticles('xpGain', gameState.playerPosition.x + 25, gameState.playerPosition.y, 8);
            
            // Verificar level up
            if (gameState.playerXP >= gameState.playerNextLevelXP) {
                levelUp();
            }
            
            updateXPBar();
            updatePlayerStats();
        }

        function levelUp() {
            gameState.playerLevel++;
            gameState.playerXP -= gameState.playerNextLevelXP;
            gameState.playerNextLevelXP = Math.floor(gameState.playerNextLevelXP * 1.4);
            
            // Efeitos visuais
            flashScreen('#9c27b0', 500);
            addParticles('levelUpEffect', gameState.playerPosition.x + 25, gameState.playerPosition.y + 25, 30);
            
            // Mostrar menu de level up
            showLevelUpMenu();
        }

        function showLevelUpMenu() {
            const levelUpMenu = document.getElementById('level-up');
            levelUpMenu.style.display = 'block';
            levelUpMenu.style.animation = 'levelUpAnimation 0.8s forwards';
            
            gameState.gamePaused = true;
        }

        function applyUpgrade(upgradeType) {
            switch(upgradeType) {
                case 'health':
                    gameState.playerMaxHealth += 25;
                    gameState.playerHealth = gameState.playerMaxHealth; // Cura completa
                    break;
                case 'mana':
                    gameState.playerMaxMana += 35;
                    gameState.playerMana = gameState.playerMaxMana; // Restaura completa
                    // Aumentar regenera√ß√£o de mana
                    CONFIG.MANA_REGEN_RATE *= 1.5;
                    break;
                case 'damage':
                    gameState.playerDamage += 8;
                    break;
                case 'speed':
                    gameState.playerSpeed += 0.8;
                    // Reduzir cooldowns
                    for (const key in gameState.abilitiesMaxCooldown) {
                        gameState.abilitiesMaxCooldown[key] *= 0.85;
                    }
                    break;
            }
            
            // Esconder menu
            document.getElementById('level-up').style.display = 'none';
            gameState.gamePaused = false;
            
            // Atualizar UI
            updateAllUI();
            
            // Salvar progresso
            saveProgress();
        }

        // ===== BOSS FIGHT - TAREK =====
        function triggerBossFight() {
            gameState.inBossFight = true;
            
            // Pausar o jogo para di√°logo
            gameState.gamePaused = true;
            
            // Mostrar di√°logo de introdu√ß√£o do boss
            setTimeout(() => {
                showDialog(
                    "TAREK, O GUERREIRO",
                    `Ent√£o voc√™ √© ${gameState.playerName}, o tal Escolhido? Estas terras geladas n√£o s√£o lugar para forasteiros fracos. Prove que merece passar por aqui, ou volte de onde veio!`,
                    [
                        {
                            text: "Aceito seu desafio, Tarek!",
                            action: () => startBossFight()
                        },
                        {
                            text: "N√£o vim aqui para lutar, mas para salvar todos n√≥s.",
                            action: () => {
                                showDialog(
                                    "TAREK",
                                    "Palavras bonitas n√£o derretem o gelo, Escolhido. Se realmente quer salvar algu√©m, mostre sua for√ßa primeiro!",
                                    [
                                        {
                                            text: "Ent√£o que assim seja!",
                                            action: () => startBossFight()
                                        }
                                    ]
                                );
                            }
                        }                    ]
                );
            }, 1000);
        }

        function startBossFight() {
            gameState.gamePaused = false;
            
            // Criar Tarek como boss
            const tarek = {
                type: 'boss',
                name: 'Tarek, o Guerreiro',
                position: { x: 4800, y: 300 },
                health: 400,
                maxHealth: 400,
                damage: 25,
                speed: 2,
                velocity: { x: 0, y: 0 },
                isGrounded: false,
                
                // IA do Boss
                aiState: 'patrol',
                aiTimer: 0,
                attackCooldown: 0,
                lastAttack: 0,
                comboCount: 0,
                enraged: false,
                
                // Habilidades do Boss
                abilities: [
                    {
                        name: 'Golpe Devastador',
                        cooldown: 3000,
                        lastUsed: 0,
                        range: 80,
                        damage: 35
                    },
                    {
                        name: 'Investida G√©lida',
                        cooldown: 6000,
                        lastUsed: 0,
                        range: 300,
                        damage: 45
                    },
                    {
                        name: 'Orbe Congelante',
                        cooldown: 8000,
                        lastUsed: 0,
                        range: 400,
                        damage: 30
                    },
                    {
                        name: 'Pris√£o de Gelo',
                        cooldown: 12000,
                        lastUsed: 0,
                        range: 200,
                        damage: 20
                    }
                ],
                
                // Padr√µes de ataque
                attackPatterns: [
                    ['Golpe Devastador', 'Golpe Devastador'],
                    ['Investida G√©lida', 'Orbe Congelante'],
                    ['Orbe Congelante', 'Golpe Devastador', 'Investida G√©lida'],
                    ['Pris√£o de Gelo', 'Golpe Devastador', 'Golpe Devastador']
                ],
                currentPattern: 0,
                patternStep: 0
            };
            
            // Adicionar Tarek aos inimigos
            enemies.push(tarek);
            
            // Mostrar barra de vida do boss
            document.getElementById('boss-name').style.display = 'block';
            document.getElementById('boss-health-bar').style.display = 'block';
            updateBossHealthBar(tarek);
            
            // Salvar checkpoint antes do boss
            saveCheckpoint('boss_fight');
            
            // Efeitos visuais de in√≠cio da luta
            screenShake(8, 500);
            flashScreen('#ff6600', 300);
            addParticles('bossIntro', tarek.position.x + 25, tarek.position.y, 40);
        }

        function updateBossAI(boss, deltaTime) {
            const distanceToPlayer = Math.abs(boss.position.x - gameState.playerPosition.x);
            const playerY = gameState.playerPosition.y;
            const bossY = boss.position.y;
            const verticalDistance = Math.abs(playerY - bossY);
            
            // Verificar se deve entrar em modo enraged
            if (boss.health < boss.maxHealth * 0.3 && !boss.enraged) {
                boss.enraged = true;
                boss.speed *= 1.5;
                boss.damage *= 1.2;
                
                // Efeitos visuais de enraged
                flashScreen('#ff0000', 500);
                addParticles('enrageEffect', boss.position.x + 25, boss.position.y + 25, 50);
                
                showDialog(
                    "TAREK",
                    "Voc√™... √© mais forte do que pensei! Mas n√£o vou cair facilmente!",
                    []
                );
            }
            
            // Atualizar cooldowns das habilidades
            boss.abilities.forEach(ability => {
                if (Date.now() - ability.lastUsed < ability.cooldown) {
                    ability.ready = false;
                } else {
                    ability.ready = true;
                }
            });
            
            // IA baseada na dist√¢ncia e situa√ß√£o
            boss.aiTimer += deltaTime;
            
            switch(boss.aiState) {
                case 'patrol':
                    updateBossPatrol(boss, deltaTime);
                    if (distanceToPlayer < 250) {
                        boss.aiState = 'combat';
                        boss.aiTimer = 0;
                    }
                    break;
                    
                case 'combat':
                    updateBossCombat(boss, deltaTime, distanceToPlayer, verticalDistance);
                    break;
                    
                case 'attacking':
                    // Durante ataque, boss n√£o se move
                    if (boss.aiTimer > 1000) {
                        boss.aiState = 'combat';
                        boss.aiTimer = 0;
                    }
                    break;
                    
                case 'stunned':
                    // Boss atordoado temporariamente
                    if (boss.aiTimer > 2000) {
                        boss.aiState = 'combat';
                        boss.aiTimer = 0;
                    }
                    break;
            }
        }

        function updateBossPatrol(boss, deltaTime) {
            // Movimento de patrulha b√°sico
            if (!boss.patrolDirection) {
                boss.patrolDirection = 1;
                boss.patrolCenter = boss.position.x;
            }
            
            boss.position.x += boss.speed * boss.patrolDirection;
            
            if (boss.position.x > boss.patrolCenter + 100) {
                boss.patrolDirection = -1;
            } else if (boss.position.x < boss.patrolCenter - 100) {
                boss.patrolDirection = 1;
            }
        }

        function updateBossCombat(boss, deltaTime, distanceToPlayer, verticalDistance) {
            const currentTime = Date.now();
            
            // Escolher habilidade baseada na dist√¢ncia e cooldowns
            let chosenAbility = null;
            
            if (distanceToPlayer < 80 && boss.abilities[0].ready) {
                // Golpe Devastador - curta dist√¢ncia
                chosenAbility = boss.abilities[0];
            } else if (distanceToPlayer > 150 && distanceToPlayer < 300 && boss.abilities[1].ready) {
                // Investida G√©lida - m√©dia dist√¢ncia
                chosenAbility = boss.abilities[1];
            } else if (distanceToPlayer > 200 && boss.abilities[2].ready) {
                // Orbe Congelante - longa dist√¢ncia
                chosenAbility = boss.abilities[2];
            } else if (distanceToPlayer < 200 && boss.abilities[3].ready && Math.random() < 0.3) {
                // Pris√£o de Gelo - ocasional
                chosenAbility = boss.abilities[3];
            }
            
            if (chosenAbility && boss.aiTimer > 1000) {
                executeBossAbility(boss, chosenAbility);
                boss.aiState = 'attacking';
                boss.aiTimer = 0;
            } else {
                // Mover em dire√ß√£o ao jogador
                moveBossTowardsPlayer(boss, distanceToPlayer);
            }
        }

        function moveBossTowardsPlayer(boss, distance) {
            if (distance > 60) {
                const direction = gameState.playerPosition.x > boss.position.x ? 1 : -1;
                boss.position.x += direction * boss.speed * 0.7;
                
                // Pular se jogador estiver em plataforma superior
                if (gameState.playerPosition.y < boss.position.y - 50 && boss.isGrounded) {
                    boss.velocity.y = -CONFIG.JUMP_FORCE * 0.8;
                    boss.isGrounded = false;
                }
            }
        }

        function executeBossAbility(boss, ability) {
            const direction = gameState.playerPosition.x > boss.position.x ? 1 : -1;
            ability.lastUsed = Date.now();
            
            switch(ability.name) {
                case 'Golpe Devastador':
                    // Ataque corpo a corpo poderoso
                    addAbilityEffect({
                        type: 'bossSlash',
                        x: boss.position.x + (direction > 0 ? 50 : -70),
                        y: boss.position.y + 10,
                        width: 70,
                        height: 30,
                        duration: 500,
                        damage: ability.damage,
                        origin: 'enemy',
                        knockback: 20
                    });
                    
                    // Efeitos visuais
                    addParticles('slashEffect', boss.position.x + 25, boss.position.y + 25, 20);
                    screenShake(6, 300);
                    break;
                    
                case 'Investida G√©lida':
                    // Dash poderoso em dire√ß√£o ao jogador
                    boss.velocity.x = direction * 15;
                    
                    addAbilityEffect({
                        type: 'bossDash',
                        x: boss.position.x,
                        y: boss.position.y,
                        width: 80,
                        height: 50,
                        duration: 800,
                        damage: ability.damage,
                        origin: 'enemy',
                        followBoss: boss
                    });
                    
                    addParticles('dashIce', boss.position.x + 25, boss.position.y + 40, 30);
                    screenShake(8, 400);
                    break;
                    
                case 'Orbe Congelante':
                    // Proj√©til de gelo grande
                    addAbilityEffect({
                        type: 'bossIceOrb',
                        x: boss.position.x + (direction > 0 ? 60 : -60),
                        y: boss.position.y + 20,
                        width: 40,
                        height: 40,
                        duration: 3000,
                        damage: ability.damage,
                        direction: direction,
                        speed: 4,
                        origin: 'enemy',
                        freezing: true
                    });
                    
                    addParticles('orbCharge', boss.position.x + 25, boss.position.y + 25, 25);
                    break;
                    
                case 'Pris√£o de Gelo':
                    // Cria m√∫ltiplas pris√µes ao redor do jogador
                    for (let i = 0; i < 3; i++) {
                        const offsetX = (i - 1) * 80;
                        addAbilityEffect({
                            type: 'bossPrison',
                            x: gameState.playerPosition.x + offsetX,
                            y: gameState.playerPosition.y - 60,
                            width: 30,
                            height: 120,
                            duration: 5000,
                            damage: ability.damage,
                            origin: 'enemy',
                            trapping: true,
                            delay: i * 200
                        });
                    }
                    
                    addParticles('prisonSummon', gameState.playerPosition.x, gameState.playerPosition.y, 40);
                    screenShake(5, 600);
                    break;
            }
        }

        function updateBossHealthBar(boss) {
            const healthFill = document.getElementById('boss-health-fill');
            const healthPercentage = (boss.health / boss.maxHealth) * 100;
            healthFill.style.width = healthPercentage + '%';
            
            // Mudar cor baseada na vida
            if (healthPercentage > 60) {
                healthFill.style.background = 'linear-gradient(90deg, #ff6b6b, #ff3333)';
            } else if (healthPercentage > 30) {
                healthFill.style.background = 'linear-gradient(90deg, #ff9500, #ff6600)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, #ff0000, #cc0000)';
            }
        }

        function defeatBoss(boss) {
            gameState.bossDefeated = true;
            gameState.inBossFight = false;
            
            // Esconder barra do boss
            document.getElementById('boss-name').style.display = 'none';
            document.getElementById('boss-health-bar').style.display = 'none';
            
            // Efeitos visuais de vit√≥ria
            flashScreen('#00ff00', 800);
            screenShake(10, 1000);
            addParticles('victoryExplosion', boss.position.x + 25, boss.position.y + 25, 60);
            
            // XP massivo por derrotar o boss
            gainXP(200);
            
            // Remover boss
            const bossIndex = enemies.indexOf(boss);
            if (bossIndex > -1) {
                enemies.splice(bossIndex, 1);
            }
            
            // Di√°logo de vit√≥ria
            setTimeout(() => {
                showDialog(
                    "TAREK",
                    `Impressionante, ${gameState.playerName}... Voc√™ realmente tem a for√ßa de um Escolhido. Pode passar, mas saiba que desafios ainda maiores o aguardam adiante.`,
                    [
                        {
                            text: "Obrigado pela luta honrosa, Tarek.",
                            action: () => {
                                showDialog(
                                    "TAREK",
                                    "Que os ventos gelados guiem seus passos, Escolhido. E que voc√™ encontre o que procura antes que seja tarde demais.",
                                    [
                                        {
                                            text: "Continuar jornada",
                                            action: () => {
                                                saveCheckpoint('boss_defeated');
                                                // Aqui poderia transicionar para a pr√≥xima fase
                                                showDialog(
                                                    "NARRA√á√ÉO",
                                                    "Com Tarek derrotado, o caminho para o interior de Tup√£ry est√° aberto. Mas esta √© apenas a primeira de muitas prova√ß√µes que aguardam o Escolhido...",
                                                    [
                                                        {
                                                            text: "Fim da Demo",
                                                            action: () => showVictoryScreen()
                                                        }
                                                    ]
                                                );
                                            }
                                        }
                                    ]
                                );
                            }
                        }
                    ]
                );
            }, 2000);
        }

        // ===== EFEITOS VISUAIS =====
        function screenShake(intensity, duration) {
            const gameContainer = document.getElementById('game-container');
            const originalTransform = gameContainer.style.transform;
            
            const startTime = Date.now();
            
            function shake() {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    const currentIntensity = intensity * (1 - progress);
                    
                    const offsetX = (Math.random() - 0.5) * currentIntensity;
                    const offsetY = (Math.random() - 0.5) * currentIntensity;
                    
                    gameContainer.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                    
                    requestAnimationFrame(shake);
                } else {
                    gameContainer.style.transform = originalTransform;
                }
            }
            
            shake();
        }

        function flashScreen(color, duration) {
            const flash = document.getElementById('screen-flash');
            flash.style.background = color;
            flash.classList.add('active');
            
            setTimeout(() => {
                flash.classList.remove('active');
            }, duration);
        }

        function createMuzzleFlash() {
            const direction = gameState.facing === 'right' ? 1 : -1;
            addParticles('muzzleFlash', 
                gameState.playerPosition.x + (direction > 0 ? 55 : -5), 
                gameState.playerPosition.y + 20, 
                12
            );
        }

        // ===== RENDERIZA√á√ÉO =====
        function render() {
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Renderizar background com parallax
            renderBackground();
            
            // Renderizar plataformas
            renderPlatforms();
            
            // Renderizar efeitos de habilidades (atr√°s dos personagens)
            renderAbilityEffects();
            
            // Renderizar jogador
            renderPlayer();
            
            // Renderizar inimigos
            renderEnemies();
            
            // Renderizar part√≠culas
            renderParticles();
            
            // Renderizar efeitos de debug (se necess√°rio)
            if (window.DEBUG_MODE) {
                renderDebugInfo();
            }
        }

        function renderBackground() {
            // Gradiente base do c√©u
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a237e');
            gradient.addColorStop(0.3, '#283593');
            gradient.addColorStop(0.7, '#3949ab');
            gradient.addColorStop(1, '#5c6bc0');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Camadas de parallax
            backgroundLayers.forEach((layer, index) => {
                const parallaxOffset = gameState.cameraOffset.x * layer.speed;
                
                // Desenhar montanhas/colinas como formas simples
                ctx.fillStyle = layer.color;
                ctx.globalAlpha = 0.6 - (index * 0.1);
                
                // Criar formas de montanha procedurais
                ctx.beginPath();
                ctx.moveTo(-parallaxOffset, canvas.height);
                
                for (let x = 0; x < canvas.width + 200; x += 50) {
                    const height = 100 + Math.sin((x + parallaxOffset) * 0.01) * 50 + Math.sin((x + parallaxOffset) * 0.003) * 100;
                    ctx.lineTo(x - parallaxOffset, canvas.height - height - (index * 30));
                }
                
                ctx.lineTo(canvas.width + 200, canvas.height);
                ctx.closePath();
                ctx.fill();
            });
            
            ctx.globalAlpha = 1;
        }

        function renderPlatforms() {
            for (const platform of platforms) {
                const x = platform.x - gameState.cameraOffset.x;
                const y = platform.y - gameState.cameraOffset.y;
                
                // Culling - n√£o renderizar se fora da tela
                if (x + platform.width < -50 || x > canvas.width + 50 || 
                    y + platform.height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                // Cor base da plataforma
                if (platform.slippery) {
                    // Plataforma de gelo
                    const iceGradient = ctx.createLinearGradient(x, y, x, y + platform.height);
                    iceGradient.addColorStop(0, '#e3f2fd');
                    iceGradient.addColorStop(0.5, '#bbdefb');
                    iceGradient.addColorStop(1, '#90caf9');
                    ctx.fillStyle = iceGradient;
                } else {
                    // Plataforma de pedra
                    const stoneGradient = ctx.createLinearGradient(x, y, x, y + platform.height);
                    stoneGradient.addColorStop(0, '#8d6e63');
                    stoneGradient.addColorStop(0.5, '#6d4c41');
                    stoneGradient.addColorStop(1, '#5d4037');
                    ctx.fillStyle = stoneGradient;
                }
                
                ctx.fillRect(x, y, platform.width, platform.height);
                
                // Detalhes visuais
                if (platform.slippery) {
                    // Efeito de gelo brilhante
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 1, y + 1, platform.width - 2, platform.height - 2);
                    
                    // Padr√£o de cristais
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < platform.width; i += 20) {
                        ctx.beginPath();
                        ctx.moveTo(x + i, y);
                        ctx.lineTo(x + i + 10, y + platform.height);
                        ctx.stroke();
                    }
                } else {
                    // Textura de pedra
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i < platform.width; i += 30) {
                        for (let j = 0; j < platform.height; j += 15) {
                            if (Math.random() > 0.7) {
                                ctx.strokeRect(x + i, y + j, 25, 10);
                            }
                        }
                    }
                }
                
                // Bordas
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, platform.width, platform.height);
            }
        }

        function renderPlayer() {
            const x = gameState.playerPosition.x - gameState.cameraOffset.x;
            const y = gameState.playerPosition.y - gameState.cameraOffset.y;
            const width = 50;
            const height = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
            
            // Culling
            if (x + width < -50 || x > canvas.width + 50 || y + height < -50 || y > canvas.height + 50) {
                return;
            }
            
            // Efeito de invencibilidade (piscar)
            if (gameState.isInvincible && Math.floor(Date.now() / 100) % 2) {
                ctx.globalAlpha = 0.5;
            }
            
            // Corpo principal do jogador
            const playerGradient = ctx.createLinearGradient(x, y, x, y + height);
            if (currentChampion) {
                if (currentChampion.type === 'ranged') {
                    playerGradient.addColorStop(0, '#4fc3f7');
                    playerGradient.addColorStop(1, '#29b6f6');
                } else {
                    playerGradient.addColorStop(0, '#66bb6a');
                    playerGradient.addColorStop(1, '#4caf50');
                }
            } else {
                playerGradient.addColorStop(0, '#42a5f5');
                playerGradient.addColorStop(1, '#1e88e5');
            }
            
            ctx.fillStyle = playerGradient;
            ctx.fillRect(x, y, width, height);
            
            // Detalhes baseados na anima√ß√£o
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            
            if (gameState.currentAnimation === 'idle') {
                // Bra√ßos parados
                ctx.fillRect(x + 5, y + 10, 8, 20);
                ctx.fillRect(x + 37, y + 10, 8, 20);
                // Olhos
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 15, y + 8, 3, 3);
                ctx.fillRect(x + 32, y + 8, 3, 3);
            } else if (gameState.currentAnimation === 'walk') {
                // Bra√ßos em movimento
                const armOffset = Math.sin(Date.now() / 150) * 3;
                ctx.fillRect(x + 5, y + 10 + armOffset, 8, 20);
                ctx.fillRect(x + 37, y + 10 - armOffset, 8, 20);
                // Olhos
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 15, y + 8, 3, 3);
                ctx.fillRect(x + 32, y + 8, 3, 3);
            } else if (gameState.currentAnimation === 'jump') {
                // Bra√ßos para cima
                ctx.fillRect(x + 5, y - 5, 8, 25);
                ctx.fillRect(x + 37, y - 5, 8, 25);
                // Olhos
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 15, y + 8, 3, 3);
                ctx.fillRect(x + 32, y + 8, 3, 3);
            } else if (gameState.currentAnimation === 'crouch') {
                // Posi√ß√£o agachada
                ctx.fillRect(x + 10, y + 5, 6, 15);
                ctx.fillRect(x + 34, y + 5, 6, 15);
                // Olhos
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 15, y + 5, 3, 3);
                ctx.fillRect(x + 32, y + 5, 3, 3);
            }
            
            // Indicador de dire√ß√£o
            ctx.fillStyle = '#000';
            if (gameState.facing === 'right') {
                ctx.fillRect(x + 42, y + height/2 - 2, 4, 4);
            } else {
                ctx.fillRect(x + 4, y + height/2 - 2, 4, 4);
            }
            
            // Indicador de classe
            ctx.fillStyle = currentChampion?.type === 'ranged' ? '#ffeb3b' : '#ff5722';
            ctx.fillRect(x + width/2 - 3, y - 8, 6, 6);
            
            ctx.globalAlpha = 1;
        }

        function renderEnemies() {
            for (const enemy of enemies) {
                const x = enemy.position.x - gameState.cameraOffset.x;
                const y = enemy.position.y - gameState.cameraOffset.y;
                const width = 50;
                const height = 50;
                
                // Culling
                if (x + width < -50 || x > canvas.width + 50 || y + height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                // Efeito de congelamento
                if (enemy.frozen) {
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#81d4fa';
                    ctx.fillRect(x - 5, y - 5, width + 10, height + 10);
                }
                
                // Renderizar baseado no tipo
                if (enemy.type === 'sentinel') {
                    renderSentinel(enemy, x, y, width, height);
                } else if (enemy.type === 'boss') {
                    renderBoss(enemy, x, y, width, height);
                }
                
                // Barra de vida do inimigo
                if (enemy.health < enemy.maxHealth) {
                    const barWidth = 60;
                    const barHeight = 6;
                    const barX = x - 5;
                    const barY = y - 15;
                    
                    // Fundo da barra
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Barra de vida
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = healthPercent > 0.5 ? '#4caf50' : healthPercent > 0.25 ? '#ff9800' : '#f44336';
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    // Borda
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
                
                // Nome do inimigo (apenas para boss)
                if (enemy.type === 'boss' && enemy.name) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(enemy.name, x + width/2, y - 25);
                    ctx.textAlign = 'left';
                }
                
                ctx.globalAlpha = 1;
            }
        }

        function renderSentinel(enemy, x, y, width, height) {
            // Corpo da sentinela
            const sentinelGradient = ctx.createLinearGradient(x, y, x, y + height);
            sentinelGradient.addColorStop(0, '#b39ddb');
            sentinelGradient.addColorStop(1, '#9575cd');
            
            ctx.fillStyle = sentinelGradient;
            ctx.fillRect(x, y, width, height);
            
            // Detalhes da armadura
            ctx.fillStyle = '#7e57c2';
            ctx.fillRect(x + 10, y + 10, 30, 15); // Peito
            ctx.fillRect(x + 5, y + 30, 40, 15); // Cintura
            
            // Capacete
            ctx.fillStyle = '#5e35b1';
            ctx.fillRect(x + 5, y, 40, 15);
            
            // Olhos brilhantes
            ctx.fillStyle = '#00e5ff';
            ctx.fillRect(x + 15, y + 5, 4, 4);
            ctx.fillRect(x + 31, y + 5, 4, 4);
            
            // Arma (lan√ßa de gelo)
            ctx.strokeStyle = '#81d4fa';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + width/2, y - 20);
            ctx.lineTo(x + width/2, y + height + 10);
            ctx.stroke();
            
            // Ponta da lan√ßa
            ctx.fillStyle = '#4fc3f7';
            ctx.beginPath();
            ctx.moveTo(x + width/2, y - 25);
            ctx.lineTo(x + width/2 - 5, y - 15);
            ctx.lineTo(x + width/2 + 5, y - 15);
            ctx.closePath();
            ctx.fill();
        }

        function renderBoss(enemy, x, y, width, height) {
            // Tarek √© maior que inimigos normais
            const bossWidth = 70;
            const bossHeight = 70;
            const bossX = x - 10;
            const bossY = y - 10;
            
            // Aura de poder (se enraged)
            if (enemy.enraged) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                ctx.fillRect(bossX - 10, bossY - 10, bossWidth + 20, bossHeight + 20);
            }
            
            // Corpo do boss
            const bossGradient = ctx.createLinearGradient(bossX, bossY, bossX, bossY + bossHeight);
            bossGradient.addColorStop(0, '#ff7043');
            bossGradient.addColorStop(0.5, '#ff5722');
            bossGradient.addColorStop(1, '#d84315');
            
            ctx.fillStyle = bossGradient;
            ctx.fillRect(bossX, bossY, bossWidth, bossHeight);
            
            // Armadura detalhada
            ctx.fillStyle = '#bf360c';
            ctx.fillRect(bossX + 10, bossY + 15, 50, 20); // Peito
            ctx.fillRect(bossX + 5, bossY + 40, 60, 25); // Cintura e pernas
            
            // Ombros
            ctx.fillStyle = '#8d6e63';
            ctx.fillRect(bossX, bossY + 10, 15, 20);
            ctx.fillRect(bossX + 55, bossY + 10, 15, 20);
            
            // Capacete √©pico
            ctx.fillStyle = '#3e2723';
            ctx.fillRect(bossX + 5, bossY, 60, 20);
            
            // Chifres do capacete
            ctx.fillStyle = '#1a0e13';
            ctx.fillRect(bossX + 10, bossY - 10, 8, 15);
            ctx.fillRect(bossX + 52, bossY - 10, 8, 15);
            
            // Olhos intimidadores
            ctx.fillStyle = '#ff1744';
            ctx.fillRect(bossX + 20, bossY + 8, 6, 6);
            ctx.fillRect(bossX + 44, bossY + 8, 6, 6);
            
            // Arma massiva (martelo de guerra)
            const hammerDirection = enemy.direction || 1;
            ctx.strokeStyle = '#6d4c41';
            ctx.lineWidth = 8;
            ctx.beginPath();
            ctx.moveTo(bossX + bossWidth/2, bossY + 20);
            ctx.lineTo(bossX + bossWidth/2 + (hammerDirection * 40), bossY - 30);
            ctx.stroke();
            
            // Cabe√ßa do martelo
            ctx.fillStyle = '#37474f';
            ctx.fillRect(bossX + bossWidth/2 + (hammerDirection * 30), bossY - 40, 20, 15);
            
            // Efeitos de gelo no martelo
            ctx.fillStyle = '#81d4fa';
            ctx.fillRect(bossX + bossWidth/2 + (hammerDirection * 32), bossY - 38, 16, 3);
            ctx.fillRect(bossX + bossWidth/2 + (hammerDirection * 32), bossY - 32, 16, 3);
        }

        function renderAbilityEffects() {
            for (const effect of abilityEffects) {
                const x = effect.x - gameState.cameraOffset.x;
                const y = effect.y - gameState.cameraOffset.y;
                
                // Culling
                if (x + effect.width < -50 || x > canvas.width + 50 || 
                    y + effect.height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                switch(effect.type) {
                    case 'iceShot':
                        renderIceShot(effect, x, y);
                        break;
                    case 'piercingOrb':
                        renderPiercingOrb(effect, x, y);
                        break;
                    case 'meleeAttack':
                        renderMeleeAttack(effect, x, y);
                        break;
                    case 'dashTrail':
                        renderDashTrail(effect, x, y);
                        break;
                    case 'crystalBarrier':
                        renderCrystalBarrier(effect, x, y);
                        break;
                    case 'bossSlash':
                        renderBossSlash(effect, x, y);
                        break;
                    case 'bossIceOrb':
                        renderBossIceOrb(effect, x, y);
                        break;
                    case 'explosion':
                        renderExplosion(effect, x, y);
                        break;
                    // Adicionar outros tipos conforme necess√°rio
                }
            }
        }

        function renderIceShot(effect, x, y) {
            // Proj√©til de gelo b√°sico
            ctx.fillStyle = '#4fc3f7';
            ctx.fillRect(x, y, effect.width, effect.height);
            
            // Brilho
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.fillRect(x + 2, y + 1, effect.width - 4, effect.height - 2);
            
            // Ponta afiada
            ctx.fillStyle = '#29b6f6';
            const direction = effect.direction;
            if (direction > 0) {
                ctx.fillRect(x + effect.width - 5, y - 2, 8, effect.height + 4);
            } else {
                ctx.fillRect(x - 3, y - 2, 8, effect.height + 4);
            }
        }

        function renderPiercingOrb(effect, x, y) {
            // Orbe perfurante animado
            const time = Date.now() / 1000;
            const pulseSize = 2 + Math.sin(time * 8) * 3;
            
            // Aura externa
            ctx.fillStyle = 'rgba(136, 216, 247, 0.4)';
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, effect.width/2 + pulseSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Orbe principal
            ctx.fillStyle = '#4fc3f7';
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, effect.width/2, 0, Math.PI * 2);
            ctx.fill();
            
            // N√∫cleo brilhante
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, effect.width/4, 0, Math.PI * 2);
            ctx.fill();
            
            // Espirais de energia
            ctx.strokeStyle = '#81d4fa';
            ctx.lineWidth = 2;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                const spiralRadius = (effect.width/2) * (0.7 + i * 0.1);
                const spiralOffset = (time * 4 + i * Math.PI * 2/3) % (Math.PI * 2);
                const spiralX = x + effect.width/2 + Math.cos(spiralOffset) * spiralRadius;
                const spiralY = y + effect.height/2 + Math.sin(spiralOffset) * spiralRadius;
                ctx.arc(spiralX, spiralY, 3, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        function renderMeleeAttack(effect, x, y) {
            // Efeito de ataque corpo a corpo
            const alpha = 1 - (effect.duration - effect.timer) / effect.duration;
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#4fc3f7';
            ctx.fillRect(x, y, effect.width, effect.height);
            
            // Linhas de impacto
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const lineX = x + (i / 4) * effect.width;
                ctx.moveTo(lineX, y);
                ctx.lineTo(lineX + 10, y + effect.height);
            }
            ctx.stroke();
            
            ctx.globalAlpha = 1;
        }

        function renderDashTrail(effect, x, y) {
            // Rastro de dash
            const alpha = effect.timer / effect.duration;
            
            ctx.globalAlpha = alpha * 0.7;
            
            // Gradiente de movimento
            const gradient = ctx.createLinearGradient(x, y, x + effect.width, y);
            gradient.addColorStop(0, 'rgba(79, 195, 247, 0)');
            gradient.addColorStop(0.5, 'rgba(79, 195, 247, 0.8)');
            gradient.addColorStop(1, 'rgba(79, 195, 247, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, effect.width, effect.height);
            
            ctx.globalAlpha = 1;
        }

        function renderCrystalBarrier(effect, x, y) {
            // Barreira de cristal
            ctx.fillStyle = 'rgba(168, 208, 230, 0.7)';
            ctx.fillRect(x, y, effect.width, effect.height);
            
            // Bordas cristalinas
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(x, y, effect.width, effect.height);
            
            // Padr√£o interno
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            for (let i = 0; i < effect.height; i += 15) {
                ctx.beginPath();
                ctx.moveTo(x, y + i);
                ctx.lineTo(x + effect.width, y + i);
                ctx.stroke();
            }
            
            // Brilho no topo
            const glowGradient = ctx.createLinearGradient(x, y, x, y + 20);
            glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
            glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = glowGradient;
            ctx.fillRect(x, y, effect.width, 20);
        }

        function renderBossSlash(effect, x, y) {
            // Ataque do boss - mais dram√°tico
            const alpha = 1 - (effect.duration - effect.timer) / effect.duration;
            
            ctx.globalAlpha = alpha;
            
            // Rastro vermelho
            ctx.fillStyle = '#ff5722';
            ctx.fillRect(x, y, effect.width, effect.height);
            
            // Linhas de energia
            ctx.strokeStyle = '#ffeb3b';
            ctx.lineWidth = 4;
            ctx.beginPath();
            for (let i = 0; i < 3; i++) {
                const lineY = y + (i / 2) * effect.height;
                ctx.moveTo(x, lineY);
                ctx.lineTo(x + effect.width, lineY);
            }
            ctx.stroke();
            
            ctx.globalAlpha = 1;
        }

        function renderBossIceOrb(effect, x, y) {
            // Orbe de gelo do boss - maior e mais amea√ßador
            const time = Date.now() / 1000;
            
            // Aura congelante
            ctx.fillStyle = 'rgba(129, 212, 250, 0.3)';
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, effect.width/2 + 10, 0, Math.PI * 2);
            ctx.fill();
            
            // Orbe principal
            ctx.fillStyle = '#81d4fa';
            ctx.beginPath();
            ctx.arc(x + effect.width/2, y + effect.height/2, effect.width/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Cristais internos
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + time;
                const crystalX = x + effect.width/2 + Math.cos(angle) * (effect.width/3);
                const crystalY = y + effect.height/2 + Math.sin(angle) * (effect.height/3);
                
                ctx.beginPath();
                ctx.moveTo(crystalX, crystalY - 5);
                ctx.lineTo(crystalX - 3, crystalY + 3);
                ctx.lineTo(crystalX + 3, crystalY + 3);
                ctx.closePath();
                ctx.stroke();
            }
        }

        function renderExplosion(effect, x, y) {
            // Explos√£o animada
            const progress = 1 - (effect.timer / effect.duration);            const maxRadius = effect.width / 2;
            const currentRadius = maxRadius * progress;
            
            // M√∫ltiplas ondas de explos√£o
            for (let i = 0; i < 3; i++) {
                const waveProgress = Math.max(0, progress - i * 0.2);
                const waveRadius = maxRadius * waveProgress;
                const alpha = (1 - waveProgress) * 0.8;
                
                ctx.globalAlpha = alpha;
                
                // Gradiente radial
                const gradient = ctx.createRadialGradient(
                    x + effect.width/2, y + effect.height/2, 0,
                    x + effect.width/2, y + effect.height/2, waveRadius
                );
                gradient.addColorStop(0, '#ffeb3b');
                gradient.addColorStop(0.5, '#ff9800');
                gradient.addColorStop(1, '#ff5722');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x + effect.width/2, y + effect.height/2, waveRadius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.globalAlpha = 1;
        }

        function renderParticles() {
            for (const particle of particles) {
                const x = particle.x - gameState.cameraOffset.x;
                const y = particle.y - gameState.cameraOffset.y;
                
                // Culling
                if (x < -20 || x > canvas.width + 20 || y < -20 || y > canvas.height + 20) {
                    continue;
                }
                
                ctx.globalAlpha = particle.alpha || 1;
                ctx.fillStyle = particle.color;
                
                // Renderizar baseado no tipo
                switch(particle.type) {
                    case 'snow':
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'crystal':
                        // Formato de cristal
                        ctx.beginPath();
                        ctx.moveTo(x, y - particle.size);
                        ctx.lineTo(x + particle.size, y);
                        ctx.lineTo(x, y + particle.size);
                        ctx.lineTo(x - particle.size, y);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    default:
                        // Part√≠cula circular padr√£o
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
            }
            
            ctx.globalAlpha = 1;
        }

        function renderDebugInfo() {
            // Informa√ß√µes de debug (apenas se DEBUG_MODE estiver ativo)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, canvas.height - 150, 200, 140);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px monospace';
            ctx.fillText(`FPS: ${Math.round(1000 / (Date.now() - lastTime))}`, 15, canvas.height - 130);
            ctx.fillText(`Player: ${Math.round(gameState.playerPosition.x)}, ${Math.round(gameState.playerPosition.y)}`, 15, canvas.height - 115);
            ctx.fillText(`Velocity: ${Math.round(gameState.playerVelocity.x)}, ${Math.round(gameState.playerVelocity.y)}`, 15, canvas.height - 100);
            ctx.fillText(`Camera: ${Math.round(gameState.cameraOffset.x)}, ${Math.round(gameState.cameraOffset.y)}`, 15, canvas.height - 85);
            ctx.fillText(`Enemies: ${enemies.length}`, 15, canvas.height - 70);
            ctx.fillText(`Particles: ${particles.length}`, 15, canvas.height - 55);
            ctx.fillText(`Effects: ${abilityEffects.length}`, 15, canvas.height - 40);
            ctx.fillText(`Grounded: ${gameState.isGrounded}`, 15, canvas.height - 25);
            ctx.fillText(`Animation: ${gameState.currentAnimation}`, 15, canvas.height - 10);
        }

        // ===== ATUALIZA√á√ÉO DE UI =====
        function updateAllUI() {
            updateHealthBar();
            updateManaBar();
            updateXPBar();
            updatePlayerStats();
        }

        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            const healthText = document.getElementById('health-text');
            
            if (healthFill && healthText) {
                const percentage = (gameState.playerHealth / gameState.playerMaxHealth) * 100;
                healthFill.style.width = percentage + '%';
                healthText.textContent = `${Math.round(gameState.playerHealth)}/${gameState.playerMaxHealth}`;
            }
        }

        function updateManaBar() {
            const manaFill = document.getElementById('mana-fill');
            const manaText = document.getElementById('mana-text');
            
            if (manaFill && manaText) {
                const percentage = (gameState.playerMana / gameState.playerMaxMana) * 100;
                manaFill.style.width = percentage + '%';
                manaText.textContent = `${Math.round(gameState.playerMana)}/${gameState.playerMaxMana}`;
            }
        }

        function updateXPBar() {
            const xpFill = document.getElementById('xp-fill');
            const xpText = document.getElementById('xp-text');
            
            if (xpFill && xpText) {
                const percentage = (gameState.playerXP / gameState.playerNextLevelXP) * 100;
                xpFill.style.width = percentage + '%';
                xpText.textContent = `${gameState.playerXP}/${gameState.playerNextLevelXP}`;
            }
        }

        function updatePlayerStats() {
            const levelEl = document.getElementById('player-level');
            const classEl = document.getElementById('player-class');
            const damageEl = document.getElementById('player-damage');
            
            if (levelEl) levelEl.textContent = gameState.playerLevel;
            if (classEl) classEl.textContent = currentChampion ? currentChampion.name.split(' ')[0] : '-';
            if (damageEl) damageEl.textContent = Math.round(gameState.playerDamage);
        }

        // ===== CONTROLE DE JOGO =====
        function togglePause() {
            if (gameState.inMenu || gameState.inCutscene) return;
            
            gameState.gamePaused = !gameState.gamePaused;
            const pauseMenu = document.getElementById('pause-menu');
            
            if (gameState.gamePaused) {
                pauseMenu.style.display = 'flex';
            } else {
                pauseMenu.style.display = 'none';
            }
        }

        function gameOver() {
            gameState.gamePaused = true;
            
            // Efeitos visuais de game over
            flashScreen('#000000', 1000);
            
            setTimeout(() => {
                showDialog(
                    "SISTEMA",
                    `${gameState.playerName} foi derrotado... Mas a jornada n√£o termina aqui. O destino de todos os reinos ainda depende de suas escolhas.`,
                    [
                        {
                            text: "Voltar ao √∫ltimo checkpoint",
                            action: () => {
                                restartFromCheckpoint();
                            }
                        },
                        {
                            text: "Reiniciar fase atual",
                            action: () => {
                                loadPhase(gameState.currentPhase);
                                gameState.gamePaused = false;
                            }
                        },
                        {
                            text: "Voltar ao menu principal",
                            action: () => {
                                exitToMenu();
                            }
                        }
                    ]
                );
            }, 1500);
        }

        function completePhase() {
            gameState.gamePaused = true;
            
            // Efeitos de vit√≥ria
            flashScreen('#00ff00', 800);
            addParticles('victory', gameState.playerPosition.x + 25, gameState.playerPosition.y, 50);
            
            setTimeout(() => {
                if (gameState.currentPhase < 2) {
                    showDialog(
                        "SISTEMA",
                        "Fase conclu√≠da com maestria! Voc√™ provou ser digno do t√≠tulo de Escolhido. Preparando para os pr√≥ximos desafios...",
                        [
                            {
                                text: "Continuar para pr√≥xima fase",
                                action: () => {
                                    loadPhase(gameState.currentPhase + 1);
                                    gameState.gamePaused = false;
                                }
                            },
                            {
                                text: "Salvar e voltar ao menu",
                                action: () => {
                                    saveProgress();
                                    exitToMenu();
                                }
                            }
                        ]
                    );
                } else {
                    showVictoryScreen();
                }
            }, 2000);
        }

        function showVictoryScreen() {
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            
            overlay.style.display = 'flex';
            
            titleElement.textContent = "VIT√ìRIA!";
            textElement.innerHTML = `
                <p>Parab√©ns, ${gameState.playerName}!</p>
                <br>
                <p>Voc√™ completou a primeira parte da jornada em Tup√£ry. Tarek foi derrotado e o caminho para o interior do reino gelado est√° aberto.</p>
                <br>
                <p>Mas esta √© apenas a primeira de muitas prova√ß√µes. O Cora√ß√£o de Gelo ainda aguarda, e Ignys se aproxima...</p>
                <br>
                <p><strong>Estat√≠sticas Finais:</strong></p>
                <p>N√≠vel Alcan√ßado: ${gameState.playerLevel}</p>
                <p>Classe: ${currentChampion ? currentChampion.name : 'Desconhecida'}</p>
                <p>XP Total: ${gameState.playerXP}</p>
                <br>
                <p><em>Obrigado por jogar Tup√£ry: O Reino Congelado!</em></p>
                <p><em>Mais cap√≠tulos em breve...</em></p>
            `;
            
            titleElement.style.animation = 'none';
            textElement.style.animation = 'none';
            void titleElement.offsetWidth;
            void textElement.offsetWidth;
            titleElement.style.animation = 'fadeInText 2s forwards';
            textElement.style.animation = 'fadeInText 3s forwards 1s';
            
            // Bot√£o especial de vit√≥ria
            const skipBtn = document.getElementById('skip-btn');
            skipBtn.textContent = 'Voltar ao Menu';
            skipBtn.onclick = () => {
                // Limpar save para permitir novo jogo
                setCookie('tupary_save', '', -1);
                setCookie('tupary_checkpoint', '', -1);
                exitToMenu();
            };
        }

        // ===== EFEITOS ESPECIAIS PARA BOSS =====
        function updateBossEffects(deltaTime) {
            // Atualizar efeitos espec√≠ficos do boss
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                
                if (effect.followBoss && effect.followBoss.position) {
                    // Efeito que segue o boss (como dash trail)
                    effect.x = effect.followBoss.position.x;
                    effect.y = effect.followBoss.position.y;
                }
                
                if (effect.delay && effect.delay > 0) {
                    // Efeito com delay (como pris√µes de gelo)
                    effect.delay -= deltaTime;
                    if (effect.delay <= 0) {
                        effect.active = true;
                        addParticles('prisonActivate', effect.x + effect.width/2, effect.y + effect.height/2, 20);
                    }
                    continue;
                }
                
                // Efeitos especiais do boss
                if (effect.type === 'bossPrison' && effect.trapping) {
                    // Verificar se jogador est√° preso
                    const playerInTrap = 
                        gameState.playerPosition.x > effect.x - 20 &&
                        gameState.playerPosition.x < effect.x + effect.width + 20 &&
                        gameState.playerPosition.y > effect.y - 10 &&
                        gameState.playerPosition.y < effect.y + effect.height + 10;
                    
                    if (playerInTrap) {
                        // Reduzir movimento do jogador
                        gameState.playerVelocity.x *= 0.3;
                        gameState.playerVelocity.y *= 0.3;
                        
                        // Dano cont√≠nuo
                        if (Math.random() < 0.02) {
                            takeDamage(effect.damage * 0.1);
                        }
                    }
                }
            }
        }

        // ===== SISTEMA DE CONQUISTAS (PLACEHOLDER) =====
        const achievements = {
            firstBlood: { name: 'Primeiro Sangue', description: 'Derrote seu primeiro inimigo', unlocked: false },
            iceBreaker: { name: 'Quebra-Gelo', description: 'Use 50 habilidades de gelo', unlocked: false },
            bossSlayer: { name: 'Matador de Chefes', description: 'Derrote Tarek', unlocked: false },
            survivor: { name: 'Sobrevivente', description: 'Complete uma fase sem morrer', unlocked: false },
            levelMaster: { name: 'Mestre dos N√≠veis', description: 'Alcance o n√≠vel 10', unlocked: false }
        };

        function checkAchievements() {
            // Verificar conquistas (implementa√ß√£o b√°sica)
            if (gameState.playerLevel >= 10 && !achievements.levelMaster.unlocked) {
                unlockAchievement('levelMaster');
            }
            
            if (gameState.bossDefeated && !achievements.bossSlayer.unlocked) {
                unlockAchievement('bossSlayer');
            }
        }

        function unlockAchievement(achievementId) {
            const achievement = achievements[achievementId];
            if (achievement && !achievement.unlocked) {
                achievement.unlocked = true;
                
                // Mostrar notifica√ß√£o
                showAchievementNotification(achievement);
                
                // Salvar conquistas
                const unlockedAchievements = Object.keys(achievements)
                    .filter(key => achievements[key].unlocked);
                setCookie('tupary_achievements', JSON.stringify(unlockedAchievements));
            }
        }

        function showAchievementNotification(achievement) {
            // Criar elemento de notifica√ß√£o tempor√°rio
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: linear-gradient(45deg, #ffb300, #ff8f00);
                color: #1a1a2e;
                padding: 15px 20px;
                border-radius: 8px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 4px 15px rgba(255, 179, 0, 0.4);
                animation: slideInRight 0.5s ease-out;
            `;
            
            notification.innerHTML = `
                <div style="font-size: 14px; margin-bottom: 5px;">üèÜ CONQUISTA DESBLOQUEADA!</div>
                <div style="font-size: 16px;">${achievement.name}</div>
                <div style="font-size: 12px; opacity: 0.8;">${achievement.description}</div>
            `;
            
            document.body.appendChild(notification);
            
            // Remover ap√≥s 4 segundos
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease-out';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 500);
            }, 4000);
        }

        // ===== SISTEMA DE √ÅUDIO (PLACEHOLDER) =====
        const audioSystem = {
            sounds: {},
            music: null,
            volume: 0.7,
            
            loadSound: function(name, url) {
                // Placeholder para carregamento de √°udio
                console.log(`Loading sound: ${name} from ${url}`);
            },
            
            playSound: function(name) {
                // Placeholder para reprodu√ß√£o de som
                console.log(`Playing sound: ${name}`);
            },
            
            playMusic: function(name, loop = true) {
                // Placeholder para m√∫sica
                console.log(`Playing music: ${name}, loop: ${loop}`);
            },
            
            stopMusic: function() {
                console.log('Stopping music');
            }
        };

        // ===== SISTEMA DE CONFIGURA√á√ïES =====
        const gameSettings = {
            volume: 0.7,
            sfxVolume: 0.8,
            musicVolume: 0.6,
            showFPS: false,
            particleQuality: 'high', // low, medium, high
            screenShake: true,
            
            load: function() {
                const saved = getCookie('tupary_settings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        Object.assign(this, settings);
                    } catch (e) {
                        console.error('Erro ao carregar configura√ß√µes:', e);
                    }
                }
            },
            
            save: function() {
                setCookie('tupary_settings', JSON.stringify(this));
            }
        };

        // ===== OTIMIZA√á√ïES DE PERFORMANCE =====
        function optimizePerformance() {
            // Ajustar qualidade baseada na performance
            const fps = 1000 / (Date.now() - lastTime);
            
            if (fps < 30) {
                // Reduzir qualidade se FPS baixo
                CONFIG.MAX_PARTICLES = Math.max(50, CONFIG.MAX_PARTICLES - 10);
                CONFIG.SNOW_SPAWN_RATE *= 0.8;
            } else if (fps > 55) {
                // Aumentar qualidade se FPS alto
                CONFIG.MAX_PARTICLES = Math.min(200, CONFIG.MAX_PARTICLES + 5);
                CONFIG.SNOW_SPAWN_RATE = Math.min(0.15, CONFIG.SNOW_SPAWN_RATE * 1.1);
            }
        }

        // ===== INICIALIZA√á√ÉO FINAL =====
        function finalizeInitialization() {
            // Carregar configura√ß√µes
            gameSettings.load();
            
            // Carregar conquistas
            const savedAchievements = getCookie('tupary_achievements');
            if (savedAchievements) {
                try {
                    const unlocked = JSON.parse(savedAchievements);
                    unlocked.forEach(id => {
                        if (achievements[id]) {
                            achievements[id].unlocked = true;
                        }
                    });
                } catch (e) {
                    console.error('Erro ao carregar conquistas:', e);
                }
            }
            
            // Configurar debug mode
            if (window.location.hash === '#debug') {
                window.DEBUG_MODE = true;
                console.log('Debug mode ativado');
            }
            
            // Otimiza√ß√£o cont√≠nua
            setInterval(optimizePerformance, 5000);
            
            console.log('Tup√£ry: O Reino Congelado - Inicializado com sucesso!');
        }

        // ===== EVENTOS DE JANELA =====
        window.addEventListener('beforeunload', (e) => {
            // Salvar progresso antes de fechar
            if (gameState.gameStarted && !gameState.inMenu) {
                saveProgress();
            }
        });

        window.addEventListener('visibilitychange', () => {
            // Pausar quando aba perde foco
            if (document.hidden && gameState.gameStarted && !gameState.inMenu && !gameState.gamePaused) {
                togglePause();
            }
        });

        // ===== IN√çCIO DO JOGO =====
        window.addEventListener('DOMContentLoaded', () => {
            init();
            finalizeInitialization();
        });

        // ===== EXPOSI√á√ÉO GLOBAL PARA DEBUG =====
        if (window.DEBUG_MODE) {
            window.gameState = gameState;
            window.CONFIG = CONFIG;
            window.enemies = enemies;
            window.particles = particles;
            window.abilityEffects = abilityEffects;
            window.platforms = platforms;
            
            // Comandos de debug
            window.debugCommands = {
                godMode: () => {
                    gameState.playerMaxHealth = 9999;
                    gameState.playerHealth = 9999;
                    gameState.playerMaxMana = 9999;
                    gameState.playerMana = 9999;
                    updateAllUI();
                },
                
                levelUp: () => {
                    gainXP(gameState.playerNextLevelXP);
                },
                
                teleport: (x, y) => {
                    gameState.playerPosition.x = x || 4800;
                    gameState.playerPosition.y = y || 300;
                },
                
                spawnBoss: () => {
                    triggerBossFight();
                },
                
                clearEnemies: () => {
                    enemies.length = 0;
                },
                
                addParticles: (type, count) => {
                    addParticles(type || 'snow', gameState.playerPosition.x, gameState.playerPosition.y, count || 50);
                }
            };
            
            console.log('Debug commands available:', Object.keys(window.debugCommands));
        }
    </script>
</body>
</html>