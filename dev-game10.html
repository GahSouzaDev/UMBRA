<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tup√£ry: O Reino Congelado - Refatorado (DOM)</title>
    <style>
        /* ===== VARI√ÅVEIS CSS ===== */
        :root {
            --primary-dark: #000000;
            --primary-medium: #0a0a0a;
            --primary-light: #1a1a1a;
            --accent-gold: #d4af37;
            --accent-gold-light: #f5d76e;
            --accent-blue: #3a86ff;
            --accent-ice: #90e0ef;
            --accent-fire: #ff6b6b;
            --accent-nature: #52b788;
            --text-light: #f0f0f0;
            --text-gray: #aaaaaa;
            --health-color: var(--accent-fire);
            --mana-color: var(--accent-blue);
            --xp-color: var(--accent-gold);
            --shadow-dark: rgba(0, 0, 0, 0.8);
            --spike-color: #666666;
            --umbra-color: #7b0099; /* Nova cor para Atirador(a) de Umbra */
            --player-color: #4CAF50; /* Cor para o Escolhido (Ben 10-ish) */
        }

        /* ===== RESET E BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* CORRE√á√ÉO CR√çTICA: Permite sele√ß√£o e digita√ß√£o em campos de input */
        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body {
            background: var(--primary-dark);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* ===== CONTAINER PRINCIPAL DO JOGO ===== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1600px;
            max-height: 770px;
            overflow: hidden;
            border: 3px solid var(--accent-gold);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
            background: linear-gradient(to bottom, #0f1419, #1a1a2e);
        }

        /* O Canvas agora √© opcional, pode ser usado para efeitos seletivos ou removido */
        #game-canvas {
            display: none; /* Desabilitado por padr√£o no rendering DOM */
        }

        /* Container do Mundo do Jogo (ser√° movido pelo JS para parallax e camera) */
        #game-world {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Ser√° ajustado para o WORLD_WIDTH pelo JS */
            height: 100%;
            transform-origin: top left;
            z-index: 0; /* Abaixo da UI */
            /* Aqui pode ter um background padr√£o que ser√° substitu√≠do por assets carregados */
            background-color: #1a1a1a;
            overflow: hidden; /* Garante que entidades fora dos limites n√£o apare√ßam */
        }

        /* Sprites de Entidades (Player, Enemies, Projectiles) */
        .game-entity {
            position: absolute;
            transform-origin: center;
            image-rendering: pixelated; /* Para pixel art */
            overflow: hidden; /* Esconde partes da imagem se o sprite for maior que o elemento */
        }
        /* Para sprites com Imagem */
        .game-entity img {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Garante que a imagem se ajuste sem cortar */
        }

        /* Sprites Espec√≠ficos */
        .player-sprite {
            /* Definir tamanho inicial no JS */
            background-color: var(--player-color); /* Fallback */
        }

        .enemy-sprite {
            background-color: #78909c; /* Fallback */
        }

        .projectile-sprite {
            background-color: var(--umbra-color); /* Fallback */
            border-radius: 50%; /* Para orbes */
        }

        /* Plataformas */
        .platform-entity {
            position: absolute;
            background-color: #4a4a4a; /* Cor padr√£o */
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }
        .platform-entity.slippery {
            background: linear-gradient(to bottom, var(--accent-ice), #bbdefb, #90caf9);
        }
        .platform-entity.spike {
            background-color: transparent;
            /* Espinhos ser√£o desenhados com clip-path */
        }
        .falling-spike-entity {
            background-color: var(--spike-color);
            clip-path: polygon(0% 100%, 50% 0%, 100% 100%); /* Forma de tri√¢ngulo */
        }
        
        /* Barra de vida para inimigos (elementos DOM) */
        .entity-health-bar {
            position: absolute;
            width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #fff;
            border-radius: 3px;
            overflow: hidden;
            /* transform: translateX(-50%); /* Centraliza - ajustado pelo JS para o pai */
            z-index: 10;
        }
        .entity-health-fill {
            height: 100%;
            width: 100%; /* Ser√° ajustado por JS */
            background: linear-gradient(90deg, #4caf50, #8bc34a);
        }
        /* Checkpoint visual apenas para debug */
        .checkpoint-entity {
            background-color: rgba(0, 255, 0, 0.2);
            border: 1px dashed green;
            z-index: -1; /* Abaixo das entidades de jogo */
        }

        /* ===== AVISO DE ORIENTA√á√ÉO MOBILE ===== */
        .orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--primary-dark);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }

        .orientation-warning h2 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            font-size: 24px;
        }

        .orientation-warning p {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
        }

        .rotate-icon {
            font-size: 48px;
            margin: 20px 0;
            animation: rotatePhone 2s infinite;
        }

        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        /* ===== TELA DE IN√çCIO / MENU PRINCIPAL ===== */
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.95) 100%);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-title {
            font-size: 42px;
            font-weight: bold;
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 20px;
            color: var(--accent-ice);
            text-align: center;
            margin-bottom: 40px;
            font-style: italic;
        }

        .character-selection {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 700px;
        }

        .character-selection h3 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            text-align: center;
            font-size: 20px;
        }

        .name-input-group {
            margin-bottom: 25px;
            text-align: center;
        }

        .name-input-group label {
            display: block;
            color: var(--text-light);
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 18px;
        }

        .name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--accent-blue);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
            text-align: center;
        }

        .name-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold-light);
        }

        .start-game-btn {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
        }

        .start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.5);
        }

        .start-game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* ===== UI LAYER ===== */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Allows clicks to pass through by default */
        }

        /* ===== BARRAS DE STATUS ===== */
        .status-bars {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
        }

        .bar-container {
            width: 200px;
            height: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--text-light);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
        }

        .mana-fill {
            background: linear-gradient(90deg, #4dabf7, #3366ff);
        }

        .xp-fill {
            background: linear-gradient(90deg, var(--accent-gold-light), var(--accent-gold));
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        /* ===== STATS DO JOGADOR ===== */
        .player-stats {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 14px;
            text-align: right;
            min-width: 150px;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-line:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: var(--accent-ice);
            font-weight: bold;
        }

        .stat-value {
            color: var(--accent-gold);
            font-weight: bold;
        }

        /* ===== SISTEMA DE HABILIDADES (Desktop & Mobile) ===== */
        .abilities-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 12px;
            pointer-events: auto; /* Permite intera√ß√£o */
        }

        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
            border: 3px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .ability-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        .ability-btn:active {
            transform: scale(0.95);
        }

        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .ability-btn.cooldown:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(0, 0, 0, 0.8) 0deg);
            transition: background 0.1s linear;
        }

        .ability-tooltip {
            position: absolute;
            bottom: 70px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--accent-blue);
            border-radius: 8px;
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            width: 200px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .ability-btn:hover .ability-tooltip {
            opacity: 1;
        }

        .tooltip-name {
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip-description {
            color: var(--text-light);
            font-size: 12px;
            line-height: 1.3;
            margin-bottom: 5px;
        }

        .tooltip-cost {
            color: var(--mana-color);
            font-size: 11px;
            font-style: italic;
        }

        /* ===== CONTROLES MOBILE (D-pad e A√ß√µes) ===== */
        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 5px;
            pointer-events: auto;
            z-index: 5;
            align-items: center;
        }
        .mobile-dpad {
            grid-column: 1 / 2;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 120px;
            height: 120px;
            position: relative;
            margin-left: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .dpad-btn {
            background: var(--primary-medium);
            border: 2px solid var(--accent-blue);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.1s;
            border-radius: 5px;
        }
        .dpad-btn:active {
            background: var(--accent-blue);
            transform: scale(0.95);
        }

        .dpad-up { grid-area: 1 / 2 / 2 / 3; }
        .dpad-left { grid-area: 2 / 1 / 3 / 2; }
        .dpad-center { grid-area: 2 / 2 / 3 / 3; opacity: 0.3; pointer-events: none;}
        .dpad-right { grid-area: 2 / 3 / 3 / 4; }
        .dpad-down { grid-area: 3 / 2 / 4 / 3; }

        /* ===== SISTEMA DE DI√ÅLOGO ===== */
        .dialog-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(10, 10, 10, 0.9));
            border: 3px solid var(--accent-blue);
            border-radius: 15px;
            padding: 20px;
            display: none;
            pointer-events: none; /* Controlled by JS now */
            z-index: 20;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .dialog-speaker {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dialog-text {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .dialog-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dialog-option {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(255, 107, 107, 0.2));
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-light);
            font-weight: bold;
        }

        .dialog-option:hover {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4), rgba(255, 107, 107, 0.4));
            transform: translateX(5px);
        }

        .dialog-option:active {
            transform: translateX(5px) scale(0.98);
        }

        /* ===== CUTSCENES ===== */
        .cinematic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            z-index: 30;
            display: none; /* Controlled by JS now */
            pointer-events: none; /* Controlled by JS now */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .cinematic-overlay img.cutscene-gif {
            display: none; /* Inicia oculto, ser√° 'block' quando src √© definido */
            max-width: 80%;
            max-height: 40vh;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            object-fit: contain; /* Garante que a imagem se ajuste sem cortar */
        }

        .cinematic-text {
            font-size: 20px;
            text-align: center;
            max-width: 80%;
            margin-bottom: 30px;
            color: var(--text-light);
            line-height: 1.6;
            opacity: 0;
            animation: fadeInText 3s forwards;
        }

        .cinematic-title {
            font-size: 32px;
            color: var(--accent-gold);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .skip-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto; /* Always clickable if parent allows */
            transition: all 0.3s;
            font-weight: bold;
        }

        .skip-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
        }

        /* ===== PAUSE MENU ===== */
        .pause-btn {
            position: absolute;
            top: 15px;
            right: 180px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-size: 16px;
        }

        .pause-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: scale(1.1);
        }

        .pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 40;
            display: none; /* Controlled by JS now */
            pointer-events: none; /* Controlled by JS now */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .pause-title {
            font-size: 36px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-option {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 200px;
        }

        .menu-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        /* ===== LEVEL UP (COM ESCOLHAS) ===== */
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            border: 3px solid var(--accent-gold);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            z-index: 35;
            display: none; /* Controlled by JS now */
            pointer-events: none; /* Controlled by JS now */
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .level-up-title {
            font-size: 28px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .level-up-subtitle {
            font-size: 16px;
            color: var(--text-light);
            margin-bottom: 25px;
        }

        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .upgrade-option {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .upgrade-option:hover {
            background: rgba(0, 0, 0, 0.6);
            transform: translateX(5px);
            box-shadow: 0 6px 15px rgba(212, 175, 55, 0.5);
        }

        .upgrade-name {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .upgrade-description {
            color: var(--text-light);
            font-size: 14px;
            line-height: 1.3;
        }

        /* ===== CHECKPOINT SYSTEM ===== */
        .checkpoint-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 25;
            display: none;
            animation: checkpointPulse 2s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        @keyframes checkpointPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }

        .checkpoint-text {
            color: var(--accent-blue);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .checkpoint-description {
            color: var(--text-light);
            font-size: 14px;
        }

        /* ===== ANIMA√á√ïES GERAIS ===== */
        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes levelUpAnimation {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* ===== EFEITOS ESPECIAIS ===== */
        .screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 15;
            opacity: 0;
            pointer-events: none;
        }

        .screen-flash.active {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .boss-health-bar {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-fire);
            border-radius: 10px;
            display: none; /* Controlled by JS */
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5);
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
            transition: width 0.5s ease;
            position: relative;
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        .boss-name {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--accent-fire);
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none; /* Controlled by JS */
            z-index: 10;
        }

        /* ===== PART√çCULAS E N√öMEROS ===== */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .damage-number, .xp-number {
            position: absolute;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
            animation: damageNumber 1s ease-out forwards;
        }
        .damage-number { color: var(--accent-fire); }
        .xp-number { color: var(--xp-color); animation: xpNumber 1.5s ease-out forwards; }

        @keyframes damageNumber {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
        }

        @keyframes xpNumber {
            0% { opacity: 1; transform: translateY(0) scale(0.8); }
            100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
        }

        /* ===== RESPONSIVIDADE ===== */
        @media (max-width: 800px) {
            #game-container {
                width: 100vw;
                height: 100vh;
                max-width: none;
                max-height: none;
                border: none;
                border-radius: 0;
            }

            .main-menu {
                padding: 10px;
            }

            .game-title {
                font-size: 36px;
            }

            .game-subtitle {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .character-selection {
                padding: 15px;
                margin-bottom: 15px;
            }

            /* Habilidades e controles m√≥veis */
            .abilities-container {
                display: flex;
                bottom: 10px;
                right: 10px;
                gap: 8px;
            }

            .mobile-controls {
                display: grid;
            }

            .status-bars {
                top: 10px;
                left: 10px;
            }

            .bar-container {
                width: 150px;
                height: 12px;
            }

            .player-stats {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 12px;
                min-width: 120px;
            }

            .pause-btn {
                top: 10px;
                right: 140px;
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .dialog-container {
                width: 95%;
                padding: 15px;
                bottom: 15px;
            }

            .dialog-text {
                font-size: 14px;
                min-height: 50px;
            }

            .cinematic-text {
                font-size: 16px;
                max-width: 90%;
            }

            .cinematic-title {
                font-size: 24px;
            }

            .skip-btn {
                bottom: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 14px;
            }

            .level-up {
                min-width: 90%;
                padding: 20px;
            }

            .upgrade-option {
                padding: 12px;
            }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            .status-bars {
                top: 5px;
                left: 5px;
            }

            .bar-container {
                width: 120px;
                height: 10px;
            }

            .player-stats {
                top: 5px;
                right: 5px;
                padding: 5px 8px;
                font-size: 10px;
                min-width: 100px;
            }

            .mobile-dpad {
                bottom: 10px;
                left: 10px;
                width: 100px;
                height: 100px;
                margin-left: 10px;
            }

            .abilities-container {
                bottom: 10px;
                right: 10px;
                gap: 5px;
            }
            .ability-btn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- Aviso de Orienta√ß√£o Mobile -->
    <div class="orientation-warning" id="orientation-warning">
        <div class="rotate-icon">üì±</div>
        <h2>Vire o Dispositivo</h2>
        <p>Para uma melhor experi√™ncia de jogo, por favor vire seu dispositivo para o modo paisagem (horizontal).</p>
    </div>

    <!-- Container Principal do Jogo -->
    <div id="game-container">
        <!-- Tela de In√≠cio / Menu Principal -->
        <div class="main-menu" id="main-menu">
            <h1 class="game-title">TUP√ÉRY</h1>
            <p class="game-subtitle">O Reino Congelado</p>
            
            <div class="character-selection">
                <h3>Desperte, Escolhido! Diga-me seu nome:</h3>
                <div class="name-input-group">
                    <label for="player-name">Nome do Escolhido:</label>
                    <input type="text" id="player-name" class="name-input" placeholder="Seu nome, para que o destino o chame..." maxlength="20">
                </div>
            </div>
            <button class="start-game-btn" id="start-game-btn" disabled>Iniciar Jornada</button>
        </div>

        <!-- game-world: Container para os elementos do jogo (personagens, plataformas, etc.) -->
        <div id="game-world">
            <!-- Os elementos do jogo ser√£o injetados aqui pelo JavaScript -->
        </div>

        <!-- Canvas do Jogo (Opcional, para efeitos que se beneficiem do Canvas, mas n√£o para entidades principais) -->
        <canvas id="game-canvas"></canvas>
        
        <!-- Flash de Tela -->
        <div class="screen-flash" id="screen-flash"></div>
        
        <!-- Container de Part√≠culas (para DOM-based particles) -->
        <div class="particle-container" id="particle-container"></div>

        <!-- UI Layer -->
        <div class="ui-layer">
            <!-- Barras de Status -->
            <div class="status-bars">
                <div class="status-bar">
                    <div class="status-icon">‚ù§Ô∏è</div>
                    <div class="bar-container">
                        <div class="bar-fill health-fill" id="health-fill"></div>
                        <div class="bar-text" id="health-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">üíô</div>
                    <div class="bar-container">
                        <div class="bar-fill mana-fill" id="mana-fill"></div>
                        <div class="bar-text" id="mana-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">‚≠ê</div>
                    <div class="bar-container">
                        <div class="bar-fill xp-fill" id="xp-fill"></div>
                        <div class="bar-text" id="xp-text">0/100</div>
                    </div>
                </div>
            </div>
            
            <!-- Stats do Jogador -->
            <div class="player-stats" id="player-stats">
                <div class="stat-line">
                    <span class="stat-label">N√≠vel:</span>
                    <span class="stat-value" id="player-level">1</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Classe:</span>
                    <span class="stat-value" id="player-class">Escolhido</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Dano:</span>
                    <span class="stat-value" id="player-damage">15</span>
                </div>
            </div>
            
            <!-- Barra de Vida do Boss -->
            <div class="boss-name" id="boss-name">TAREK, O GUERREIRO</div>
            <div class="boss-health-bar" id="boss-health-bar">
                <div class="boss-health-fill" id="boss-health-fill"></div>
            </div>
            
            <!-- Habilidades (Desktop & Mobile) -->
            <div class="abilities-container" id="abilities-container">
                <div class="ability-btn" id="ability-u" data-key="U">
                    U
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-u-name">Tiro Sombrio</div>
                        <div class="tooltip-description" id="tooltip-u-desc">Dispara um proj√©til de energia sombria.</div>
                        <div class="tooltip-cost" id="tooltip-u-cost">Custo: 0 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-i" data-key="I">
                    I
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-i-name">Sombra √Ågil</div>
                        <div class="tooltip-description" id="tooltip-i-desc">Deslocamento r√°pido que atravessa inimigos.</div>
                        <div class="tooltip-cost" id="tooltip-i-cost">Custo: 25 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-o" data-key="O">
                    O
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-o-name">Orbe Et√©reo</div>
                        <div class="tooltip-description" id="tooltip-o-desc">Lan√ßa um orbe de energia sombria que perfura.</div>
                        <div class="tooltip-cost" id="tooltip-o-cost">Custo: 35 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-p" data-key="P">
                    P
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-p-name">F√∫ria de Umbra</div>
                        <div class="tooltip-description" id="tooltip-p-desc">Canaliza a energia de Umbra para amplificar poder.</div>
                        <div class="tooltip-cost" id="tooltip-p-cost">Custo: 50 Mana</div>
                    </div>
                </div>
            </div>
            
            <!-- Bot√£o de Pausa -->
            <div class="pause-btn" id="pause-btn">‚è∏Ô∏è</div>
            
            <!-- Controles Mobile (D-pad e A√ß√µes) -->
            <div class="mobile-controls" id="mobile-controls">
                <div class="mobile-dpad">
                    <div class="dpad-btn dpad-up" id="mobile-up">‚ñ≤</div>
                    <div class="dpad-btn dpad-left" id="mobile-left">‚óÄ</div>
                    <div class="dpad-btn dpad-center"></div>
                    <div class="dpad-btn dpad-right" id="mobile-right">‚ñ∂</div>
                    <div class="dpad-btn dpad-down" id="mobile-down">‚ñº</div>
                </div>
            </div>
            
            <!-- Sistema de Di√°logo -->
            <div class="dialog-container" id="dialog-container">
                <div class="dialog-speaker" id="dialog-speaker"></div>
                <div class="dialog-text" id="dialog-text"></div>
                <div class="dialog-options" id="dialog-options"></div>
            </div>
            
            <!-- Overlay de Cutscene -->
            <div class="cinematic-overlay" id="cinematic-overlay">
                <div class="cinematic-title" id="cinematic-title"></div>
                <img id="cutscene-gif" class="cutscene-gif" src="" alt="Cena Animada">
                <div class="cinematic-text" id="cinematic-text"></div>
                <button class="skip-btn" id="skip-btn">Pr√≥ximo</button>
            </div>
            
            <!-- Menu de Pausa -->
            <div class="pause-menu" id="pause-menu">
                <h2 class="pause-title">JOGO PAUSADO</h2>
                <button class="menu-option" id="resume-btn">Continuar</button>
                <button class="menu-option" id="restart-btn">Reiniciar Checkpoint</button>
                <button class="menu-option" id="save-btn">Salvar Progresso</button>
                <button class="menu-option" id="exit-btn">Voltar ao Menu</button>
            </div>
            
            <!-- Sistema de Level Up (Com Escolhas) -->
            <div class="level-up" id="level-up">
                <h2 class="level-up-title">N√çVEL AUMENTADO!</h2>
                <p class="level-up-subtitle">Escolha uma melhoria para fortalecer seu poder:</p>
                <div class="upgrade-options">
                    <div class="upgrade-option" data-upgrade="health">
                        <div class="upgrade-name">+ Vitalidade Aprimorada</div>
                        <div class="upgrade-description">Aumenta sua vida m√°xima em 25 pontos e restaura completamente sua sa√∫de.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="mana">
                        <div class="upgrade-name">+ Reserva M√≠stica</div>
                        <div class="upgrade-description">Aumenta sua mana m√°xima em 35 pontos e acelera a regenera√ß√£o em 50%.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="damage">
                        <div class="upgrade-name">+ Poder Destrutivo</div>
                        <div class="upgrade-description">Aumenta o dano de todas suas habilidades em 8 pontos permanentemente.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="speed">
                        <div class="upgrade-name">+ Agilidade de Umbra</div>
                        <div class="upgrade-description">Aumenta velocidade de movimento em 20% e reduz cooldowns em 15%.</div>
                    </div>
                </div>
            </div>
            
            <!-- Notifica√ß√£o de Checkpoint -->
            <div class="checkpoint-notification" id="checkpoint-notification">
                <div class="checkpoint-text">CHECKPOINT SALVO</div>
                <div class="checkpoint-description">Seu progresso foi salvo automaticamente</div>
            </div>
        </div>
    </div>

    <script>
        /**
         * =================================================================================================
         * ARQUITETURA DO JOGO E APLICA√á√ÉO DOS DESIGN PATTERNS
         * =================================================================================================
         *
         * Este jogo foi refatorado para utilizar os seguintes Design Patterns:
         *
         * 1.  State Pattern:
         *     - O jogador e os inimigos agora possuem um `currentState` que gerencia seu comportamento
         *       atual (ex: `PlayerIdleState`, `PlayerWalkState`, `EnemyPatrolState`).
         *     - Cada estado √© uma classe separada com m√©todos `onEnter()`, `onUpdate()`, `onFixedUpdate()`,
         *       e `onExit()`.
         *     - A l√≥gica para mudar de um estado para outro √© encapsulada dentro dos pr√≥prios estados ou
         *       no objeto principal (Player/Enemy), usando um m√©todo `transitionToState()`.
         *     - Benef√≠cios: Facilita a adi√ß√£o de novos comportamentos, evita "switch case hell",
         *       melhora a legibilidade e manuten√ß√£o.
         *
         * 2.  Component Pattern (Simulado em JavaScript):
         *     - Embora n√£o haja um motor de jogo como Unity com componentes nativos, simulamos o padr√£o
         *       separando responsabilidades em objetos/classes menores que s√£o "compostos" pelo objeto principal.
         *     - Ex: `Player` agora tem um `PhysicsComponent` (para lidar com movimento e colis√£o),
         *       um `HealthComponent`, um `ManaComponent`, um `AnimationComponent` e um `InputComponent`.
         *     - Em vez de um √∫nico objeto `player` fazendo tudo, ele delega tarefas para esses "componentes".
         *     - Benef√≠cios: Modularidade, reusabilidade (ex: `HealthComponent` pode ser usado por Player e inimigos),
         *       facilita a manuten√ß√£o e teste de partes espec√≠ficas do c√≥digo.
         *
         * 3.  Observer Pattern:
         *     - Implementado via um `EventBus` global.
         *     - Eventos como `player_damaged`, `xp_gained`, `level_up`, `ability_used` s√£o "emitidos".
         *     - Elementos da UI (barras de status), sistema de √°udio, etc., "assinam" esses eventos
         *       para reagir a eles sem precisar de refer√™ncias diretas ao objeto que os emitiu.
         *     - Benef√≠cios: Desacoplamento forte entre emissores e receptores de eventos, flexibilidade,
         *       facilita a adi√ß√£o de novas funcionalidades que precisam reagir a eventos existentes.
         *
         * 4.  Object Pooling:
         *     - Implementado com uma classe `ObjectPooler`.
         *     - Utilizado para objetos que s√£o criados e destru√≠dos frequentemente, como proj√©teis de habilidades,
         *       part√≠culas de efeitos visuais e, opcionalmente, inimigos.
         *     - Em vez de `new` e `delete` constantes, objetos s√£o "emprestados" da pool e retornados ap√≥s o uso,
         *       apenas sendo desativados e reativados.
         *     - Benef√≠cios: Reduz o lixo da mem√≥ria (garbage collection), otimiza a performance (especialmente em mobile),
         *       evita picos de CPU devido √† cria√ß√£o/destrui√ß√£o de objetos.
         *
         * =================================================================================================
         */

        /**
         * =================================================================================================
         * ESTRUTURA GERAL DO JOGO
         * =================================================================================================
         *
         * 1.  Vari√°veis Globais e Configura√ß√µes (CONFIG, gameState, COLOR_VARS)
         * 2.  EventBus (Observer Pattern)
         * 3.  Classes de Componentes (PlayerInput, HealthComponent, ManaComponent, PhysicsComponent, AnimationComponent)
         * 4.  Classes de Estados (PlayerState, PlayerIdleState, PlayerWalkState, etc.)
         * 5.  Classes de Entidades do Jogo (Player, Enemy, Projectile, Particle, Platform) - Composi√ß√£o dos Componentes
         * 6.  ObjectPooler (Object Pooling Pattern)
         * 7.  Classes de Habilidades (PlayerAbility, DarkShotAbility, etc.)
         * 8.  Gerenciadores Globais (GameManager, UIManager, AudioManager, AssetLoader)
         * 9.  L√≥gica do Jogo (init, gameLoop, update, render, setupPhases)
         * 10. Fun√ß√µes Utilit√°rias (flashScreen, screenShake, save/load cookies, etc.)
         *
         * =================================================================================================
         */


        // ===== 1. VARI√ÅVEIS GLOBAIS E CONFIGURA√á√ïES =====
        const CONFIG = {
            // F√≠sica do jogo
            GRAVITY: 0.6,
            PLAYER_BASE_SPEED: 4,
            JUMP_FORCE: 14,
            PLAYER_WIDTH: 40,
            PLAYER_HEIGHT: 80,
            CROUCH_HEIGHT: 40,
            
            // Mundo
            WORLD_WIDTH: 5000,
            WORLD_HEIGHT: 450,
            CAMERA_SMOOTHING: 0.08,
            
            // Combate
            DAMAGE_FLASH_DURATION: 200,
            INVINCIBILITY_DURATION: 1000,
            
            // Regenera√ß√£o
            MANA_REGEN_RATE: 1.5,
            HEALTH_REGEN_RATE: 0.05,
            
            // Part√≠culas
            MAX_PARTICLES: 200, // Controlado pelo Object Pooling
            SNOW_SPAWN_RATE: 0.15,
            
            // Performance
            TARGET_FPS: 60,
            DELTA_TIME_CAP: 32, // Limite para deltaTime para evitar pulos em lags extremos

            // Habilidades do Escolhido
            UMBRA_FURY_DURATION: 7000,
            UMBRA_FURY_DAMAGE_BOOST: 1.5,
            UMBRA_FURY_SPEED_BOOST: 1.3,
            UMBRA_FURY_DAMAGE_REDUCTION: 0.5,

            // CAMINHOS DE RECURSOS (Imagens e √Åudios)
            // IMPORTANTE: Para anima√ß√µes de sprites (personagens, inimigos),
            // os caminhos devem apontar para ARRAYS DE CAMINHOS DE IMAGENS (quadros/frames).
            // Ex: player_idle: ['path/to/frame0.png', 'path/to/frame1.png', ...]
            // Se for um √∫nico GIF (string) para um sprite animado, o AssetLoader ainda carregar√°
            // ele como um objeto Image, mas o AnimationManager s√≥ poder√° usar o primeiro frame,
            // pois o DOM n√£o anima GIFs como sprites (exceto o <img> de cutscene).
            // VOC√ä PRECISA FORNECER ESSES ARQUIVOS NAS PASTAS CORRETAS.
            ASSET_PATHS: {
                // Exemplo de como voc√™ deve estruturar seus assets para anima√ß√£o de sprites:
                // Crie subpastas para os frames PNGs extra√≠dos dos seus GIFs.
                // player_idle: [
                //     'assets/personagens/Escolhido/idle/escolhido-parado01-frame0.png',
                //     'assets/personagens/Escolhido/idle/escolhido-parado01-frame1.png',
                //     'assets/personagens/Escolhido/idle/escolhido-parado01-frame2.png',
                // ],
                // Se voc√™ n√£o fornecer arrays, apenas o primeiro frame do GIF ser√° usado como est√°tico.
                player_idle: 'assets/personagens/Escolhido/gifs/escolhido-parado01.gif', 
                player_walk: 'assets/personagens/Escolhido/gifs/escolhido-andando01.gif', 
                player_jump: 'assets/personagens/Escolhido/gifs/escolhido-salto01.gif', 
                player_crouch: 'assets/personagens/Escolhido/gifs/escolhido-abaixar.gif', 
                player_attack_u: 'assets/personagens/Escolhido/gifs/escolhido-ataque-u.gif', 
                player_attack_i: 'assets/personagens/Escolhido/gifs/escolhido-ataque-i.gif', 
                player_attack_o: 'assets/personagens/Escolhido/gifs/escolhido-ataque-o.gif', 
                player_ultimate: 'assets/personagens/Escolhido/gifs/escolhido-ultimate.gif', 
                player_damage: 'assets/personagens/Escolhido/gifs/escolhido-dano.gif', 

                sentinel_sprite: 'assets/inimigos/sentinela.gif', 
                tarek_sprite: 'assets/bosses/tarek.gif', 
                tarek_background: 'assets/fundos/gelo/muralhas-gelo.png', // Exemplo de imagem est√°tica

                projectile_i: 'assets/sprites/effects/projectile_i.gif', 
                explosion_o: 'assets/sprites/effects/explosion_o.gif', 
                tarek_ice_orb: 'assets/sprites/effects/tarek_ice_orb.gif', 
                tarek_prison: 'assets/sprites/effects/tarek_prison.gif', 

                // Cutscene (pode ser GIF animado porque √© um elemento <img> HTML)
                cutscene_gif_1: 'assets/animacoes/AislinsVsFayra.gif', 

                // √Åudios - VERIFIQUE SE EST√ÉO NA PASTA CORRETA E S√ÉO MP3s V√ÅLIDOS!
                music_menu: 'assets/audio/music/menu.mp3',
                music_platforming: 'assets/audio/music/platforming.mp3',
                music_boss_tarek: 'assets/audio/music/tarek_boss.mp3',
                sfx_jump: 'assets/audio/sfx/jump.mp3',
                sfx_attack_u: 'assets/audio/sfx/attack_u.mp3',
                sfx_ability_i: 'assets/audio/sfx/ability_i.mp3',
                sfx_ability_o: 'assets/audio/sfx/ability_o.mp3',
                sfx_ability_p: 'assets/audio/sfx/ability_p.mp3',
                sfx_damage_player: 'assets/audio/sfx/damage_player.mp3',
                sfx_damage_enemy: 'assets/audio/sfx/damage_enemy.mp3',
                sfx_level_up: 'assets/audio/sfx/level_up.mp3',
                sfx_boss_roar: 'assets/audio/sfx/boss_roar.mp3',
            },
            // Este objeto armazenar√° os recursos carregados (Image e AudioBuffer)
            ASSET_LOADED: {}
        };

        let gameState = {
            playerName: '',
            player: null, // Refer√™ncia √† inst√¢ncia do Player
            currentPhase: 0,
            currentCheckpoint: 'start',
            
            gamePaused: false,
            inDialog: false,
            inCutscene: false,
            inMenu: true,
            gameStarted: false,
            
            cameraOffset: { x: 0, y: 0 },
            targetCameraOffset: { x: 0, y: 0 },
            
            // Boss fight
            inBossFight: false,
            bossDefeated: false,
            inTarekEncounter: false,
            tarekDialogStep: 0,
            tarekDialogCompleted: false,
            tarekEncounterTriggerX: 5500, // Posi√ß√£o X para iniciar o encontro com Tarek
            fixedCamera: false,
            fixedCameraTarget: { x: 0, y: 0 }
        };

        // Arrays de entidades
        let platforms = [];
        let enemies = [];
        let fallingSpikes = [];
        let checkpoints = [];
        
        // DOM element para o mundo do jogo - Essencial para renderiza√ß√£o via DOM
        let gameWorldElement;

        // Cores CSS pr√©-calculadas para performance
        let COLOR_HEALTH, COLOR_MANA, COLOR_XP, COLOR_ACCENT_FIRE, COLOR_ACCENT_GOLD, COLOR_ACCENT_BLUE, COLOR_ACCENT_ICE, COLOR_TEXT_LIGHT, COLOR_UMBRA, COLOR_PLAYER_COLOR, COLOR_SPIKE;

        // Vari√°veis de controle do jogo
        let canvas, ctx; // Canvas agora √© opcional, pode ser usado para efeitos seletivos ou removido
        let isMobile = false;
        let isLandscape = true;
        let lastTime = 0;
        let animationFrameId = null;


        // =================================================================================================
        // ===== 2. EVENT BUS (OBSERVER PATTERN) =========================================================
        // =================================================================================================
        /**
         * @class EventBus
         * @description Implementa o padr√£o Observer para desacoplar a comunica√ß√£o entre diferentes partes do jogo.
         *              Componentes podem emitir eventos e outros componentes podem ouvi-los sem ter refer√™ncias diretas.
         */
        class EventBus {
            constructor() {
                this.listeners = {};
            }

            /**
             * Assina um evento.
             * @param {string} eventName - O nome do evento a ser ouvido.
             * @param {Function} callback - A fun√ß√£o a ser chamada quando o evento √© emitido.
             */
            subscribe(eventName, callback) {
                if (!this.listeners[eventName]) {
                    this.listeners[eventName] = [];
                }
                this.listeners[eventName].push(callback);
            }

            /**
             * Desassina um evento.
             * @param {string} eventName - O nome do evento.
             * @param {Function} callback - A fun√ß√£o que foi originalmente assinada.
             */
            unsubscribe(eventName, callback) {
                if (this.listeners[eventName]) {
                    this.listeners[eventName] = this.listeners[eventName].filter(cb => cb !== callback);
                }
            }

            /**
             * Emite um evento, notificando todos os assinantes.
             * @param {string} eventName - O nome do evento a ser emitido.
             * @param {*} data - Dados opcionais a serem passados para os callbacks.
             */
            emit(eventName, data) {
                if (this.listeners[eventName]) {
                    this.listeners[eventName].forEach(callback => callback(data));
                }
            }
        }

        const EventManager = new EventBus();


        // =================================================================================================
        // ===== 3. CLASSES DE COMPONENTES (Component Pattern) =============================================
        // =================================================================================================
        /**
         * @class PlayerInput
         * @description Componente respons√°vel por gerenciar todas as entradas do jogador (teclado e touch).
         *              Separa a l√≥gica de input do PlayerController.
         */
        class PlayerInput {
            constructor() {
                this.keys = {}; // Estado atual das teclas pressionadas
                this.lastJumpInput = 0; // Para garantir que o pulo s√≥ ocorra uma vez por pressionar
                
                // Estados para controles mobile (d-pad)
                this.mobileLeft = false;
                this.mobileRight = false;
                this.mobileUp = false;
                this.mobileDown = false;

                // Bind de eventos de teclado
                window.addEventListener('keydown', this._handleKeyDown.bind(this));
                window.addEventListener('keyup', this._handleKeyUp.bind(this));
                
                // Bind de eventos touch para d-pad e habilidades
                this._initMobileControlsListeners();
            }

            _handleKeyDown(e) {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault(); // Previne scroll da p√°gina
                }
                this.keys[e.key.toLowerCase()] = true;
            }

            _handleKeyUp(e) {
                this.keys[e.key.toLowerCase()] = false;
            }

            _initMobileControlsListeners() {
                const addTouchListeners = (elementId, startCallback, endCallback) => {
                    const el = document.getElementById(elementId);
                    if (el) {
                        el.addEventListener('touchstart', (e) => { e.preventDefault(); startCallback(); });
                        el.addEventListener('touchend', (e) => { e.preventDefault(); endCallback(); });
                        el.addEventListener('touchcancel', (e) => { e.preventDefault(); endCallback(); }); // Em caso de interrup√ß√£o
                    }
                };

                addTouchListeners('mobile-up', () => this.mobileUp = true, () => this.mobileUp = false);
                addTouchListeners('mobile-down', () => this.mobileDown = true, () => this.mobileDown = false);
                addTouchListeners('mobile-left', () => this.mobileLeft = true, () => this.mobileLeft = false);
                addTouchListeners('mobile-right', () => this.mobileRight = true, () => this.mobileRight = false);

                // Habilidades (U, I, O, P) - j√° est√£o sendo tratadas como clicks/touches no HTML
                // O PlayerAbilityManager vai ouvir esses eventos de clique/toque nos bot√µes
            }

            /**
             * Retorna a dire√ß√£o de movimento horizontal (-1 para esquerda, 1 para direita, 0 para parado).
             * @returns {number}
             */
            getMoveDirection() {
                let moveX = 0;
                if (this.keys['a'] || this.keys['arrowleft'] || this.mobileLeft) moveX = -1;
                if (this.keys['d'] || this.keys['arrowright'] || this.mobileRight) moveX = 1;
                return moveX;
            }

            /**
             * Verifica se o input de pulo foi acionado.
             * @returns {boolean}
             */
            isJumpPressed() {
                const jumpKey = this.keys['w'] || this.keys['arrowup'] || this.keys[' '];
                const jumpMobile = this.mobileUp; // O d-pad up tamb√©m √© o pulo
                
                // L√≥gica para detectar o "down" do input, n√£o o segurar
                const currentJumpInput = (jumpKey || jumpMobile) ? 1 : 0;
                const jumped = currentJumpInput === 1 && this.lastJumpInput === 0;
                this.lastJumpInput = currentJumpInput;
                return jumped;
            }

            /**
             * Verifica se o input de agachar est√° ativo.
             * @returns {boolean}
             */
            isCrouchActive() {
                return this.keys['s'] || this.keys['arrowdown'] || this.mobileDown;
            }

            /**
             * Verifica se uma tecla de habilidade espec√≠fica foi pressionada.
             * @param {string} key - A letra da tecla (ex: 'u', 'i', 'o', 'p').
             * @returns {boolean}
             */
            isAbilityPressed(key) {
                return this.keys[key.toLowerCase()];
            }

            /**
             * Limpa os inputs que devem ser de "apenas um toque" (ex: pulo)
             * Chamado ap√≥s o frame de update.
             */
            clearOneShotInputs() {
                // `isJumpPressed` j√° lida com isso internamente usando `lastJumpInput`
            }
        }

        /**
         * @class HealthComponent
         * @description Componente que gerencia a sa√∫de e invencibilidade de uma entidade.
         */
        class HealthComponent {
            constructor(maxHealth, regenRate = 0) {
                this.maxHealth = maxHealth;
                this.currentHealth = maxHealth;
                this.regenRate = regenRate;
                this.isInvincible = false;
                this.invincibilityTimer = 0;
                this.flashActive = false; // Estado para o efeito de flash visual
            }

            /**
             * Causa dano √† entidade.
             * @param {number} amount - Quantidade de dano.
             * @param {number} invincibilityDuration - Dura√ß√£o da invencibilidade ap√≥s o dano.
             */
            takeDamage(amount, invincibilityDuration = CONFIG.INVINCIBILITY_DURATION) {
                if (this.isInvincible) return;

                this.currentHealth -= amount;
                this.currentHealth = Math.max(0, this.currentHealth);
                this.isInvincible = true;
                this.invincibilityTimer = invincibilityDuration;
                
                // Efeito visual de flash de tela ou sprite
                EventManager.emit('screen_flash', { color: COLOR_HEALTH, duration: CONFIG.DAMAGE_FLASH_DURATION });
                EventManager.emit('screen_shake', { intensity: 5, duration: 300 });
                EventManager.emit('sfx_play', 'sfx_damage_player');

                EventManager.emit('player_damaged', { current: this.currentHealth, max: this.maxHealth });

                if (this.currentHealth <= 0) {
                    EventManager.emit('entity_died', this); // Notifica que a entidade morreu
                }
            }

            /**
             * Cura a entidade.
             * @param {number} amount - Quantidade de cura.
             */
            heal(amount) {
                this.currentHealth += amount;
                this.currentHealth = Math.min(this.maxHealth, this.currentHealth);
                EventManager.emit('player_healed', { current: this.currentHealth, max: this.maxHealth });
            }

            /**
             * Atualiza a l√≥gica de regenera√ß√£o e invencibilidade.
             * @param {number} deltaTime - Tempo decorrido desde o √∫ltimo frame (em ms).
             */
            update(deltaTime) {
                // Regenera√ß√£o
                if (this.currentHealth < this.maxHealth && this.regenRate > 0) {
                    this.currentHealth += this.regenRate * (deltaTime / 1000);
                    this.currentHealth = Math.min(this.maxHealth, this.currentHealth);
                    EventManager.emit('player_healed', { current: this.currentHealth, max: this.maxHealth }); // Usar o mesmo evento de cura
                }

                // Invencibilidade
                if (this.isInvincible) {
                    this.invincibilityTimer -= deltaTime;
                    if (this.invincibilityTimer <= 0) {
                        this.isInvincible = false;
                    }
                }
            }
        }

        /**
         * @class ManaComponent
         * @description Componente que gerencia a mana e sua regenera√ß√£o para uma entidade.
         */
        class ManaComponent {
            constructor(maxMana, regenRate) {
                this.maxMana = maxMana;
                this.currentMana = maxMana;
                this.regenRate = regenRate;
            }

            /**
             * Tenta usar uma quantidade de mana.
             * @param {number} amount - Quantidade de mana a ser usada.
             * @returns {boolean} - True se a mana foi usada com sucesso, false caso contr√°rio.
             */
            useMana(amount) {
                if (this.currentMana >= amount) {
                    this.currentMana -= amount;
                    EventManager.emit('player_mana_changed', { current: this.currentMana, max: this.maxMana });
                    return true;
                }
                EventManager.emit('screen_flash', { color: COLOR_MANA, duration: 200 }); // Sinal visual de mana insuficiente
                return false;
            }

            /**
             * Atualiza a regenera√ß√£o de mana.
             * @param {number} deltaTime - Tempo decorrido desde o √∫ltimo frame (em ms).
             */
            update(deltaTime) {
                if (this.currentMana < this.maxMana) {
                    this.currentMana += this.regenRate * (deltaTime / 1000);
                    this.currentMana = Math.min(this.maxMana, this.currentMana);
                    EventManager.emit('player_mana_changed', { current: this.currentMana, max: this.maxMana });
                }
            }
        }

        /**
         * @class PhysicsComponent
         * @description Componente que lida com a f√≠sica (movimento, gravidade, colis√£o) de uma entidade.
         */
        class PhysicsComponent {
            constructor(entity, width, height) {
                this.entity = entity; // Refer√™ncia √† entidade (Player ou Enemy)
                this.width = width;
                this.height = height;
                this.velocity = { x: 0, y: 0 };
                this.isGrounded = false;
                this.collisionOffset = 0.01; // Pequeno offset para evitar bugs de "encaixe" em colis√µes
            }

            /**
             * Aplica a gravidade e atualiza a posi√ß√£o baseada na velocidade.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                // Aplicar gravidade
                this.velocity.y += CONFIG.GRAVITY;

                // Limitar velocidade de queda para evitar quebras de colis√£o
                if (this.velocity.y > 15) {
                    this.velocity.y = 15;
                }

                // Atualizar posi√ß√£o tentativa
                let newX = this.entity.position.x + this.velocity.x * (deltaTime / 1000);
                let newY = this.entity.position.y + this.velocity.y * (deltaTime / 1000);

                // Resetar estado de ch√£o
                this.isGrounded = false;

                // Checar colis√µes em X
                for (const platform of platforms) {
                    if (this._checkCollision(newX, this.entity.position.y, this.width, this.height, platform)) {
                        if (this.velocity.x > 0) { // Indo para a direita
                            newX = platform.x - this.width - this.collisionOffset;
                        } else if (this.velocity.x < 0) { // Indo para a esquerda
                            newX = platform.x + platform.width + this.collisionOffset;
                        }
                        this.velocity.x = 0;
                        break;
                    }
                }
                this.entity.position.x = newX;

                // Checar colis√µes em Y
                for (const platform of platforms) {
                    if (this._checkCollision(this.entity.position.x, newY, this.width, this.height, platform)) {
                        if (platform.type === 'spike') {
                            if (this.entity.isPlayer) { // S√≥ o jogador toma dano de spike
                                this.entity.health.takeDamage(10);
                            }
                            // N√£o para a colis√£o para que ele caia, apenas causa dano
                            continue;
                        }

                        if (this.velocity.y > 0) { // Caindo (colis√£o com o ch√£o/topo da plataforma)
                            newY = platform.y - this.height - this.collisionOffset;
                            this.isGrounded = true;
                            // Se a queda foi forte, emite part√≠culas
                            if (this.velocity.y > 8) { 
                                EventManager.emit('add_particles', { type: 'landDust', x: this.entity.position.x + this.width / 2, y: this.entity.position.y + this.height, count: 12 });
                                EventManager.emit('screen_shake', { intensity: 3, duration: 150 });
                            }
                        } else if (this.velocity.y < 0) { // Subindo (colis√£o com o lado de baixo da plataforma)
                            newY = platform.y + platform.height + this.collisionOffset;
                        }
                        this.velocity.y = 0;
                        break;
                    }
                }
                this.entity.position.y = newY;

                // Colis√£o com o "ch√£o do mundo" (se cair muito)
                if (this.entity.position.y > CONFIG.WORLD_HEIGHT - this.height) {
                    this.entity.position.y = CONFIG.WORLD_HEIGHT - this.height;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                    // Se o jogador cair pra fora do mapa, ele "morre" ou toma muito dano
                    if (this.entity.isPlayer) {
                        this.entity.health.takeDamage(this.entity.health.maxHealth);
                    }
                }
            }

            /**
             * Checa colis√£o entre dois ret√¢ngulos (AABB).
             * @param {number} x1, y1, w1, h1 - Posi√ß√£o e dimens√µes do primeiro ret√¢ngulo.
             * @param {object} rect2 - Objeto com x, y, width, height do segundo ret√¢ngulo.
             * @returns {boolean} - True se houver colis√£o.
             */
            _checkCollision(x1, y1, w1, h1, rect2) {
                return x1 < rect2.x + rect2.width &&
                       x1 + w1 > rect2.x &&
                       y1 < rect2.y + rect2.height &&
                       y1 + h1 > rect2.y;
            }

            /**
             * Aplica uma for√ßa de pulo.
             * @param {number} force - A for√ßa do pulo.
             */
            jump(force) {
                this.velocity.y = -force;
                this.isGrounded = false;
                EventManager.emit('sfx_play', 'sfx_jump');
                EventManager.emit('add_particles', { type: 'jumpDust', x: this.entity.position.x + this.width / 2, y: this.entity.position.y + this.height, count: 8 });
            }

            /**
             * Aplica uma for√ßa horizontal (movimento).
             * @param {number} direction - -1 para esquerda, 1 para direita, 0 para parado.
             * @param {number} speed - Velocidade de movimento.
             */
            moveX(direction, speed) {
                this.velocity.x = direction * speed;
            }

            /**
             * Aplica um empurr√£o (knockback).
             * @param {number} forceX - For√ßa em X.
             * @param {number} forceY - For√ßa em Y.
             */
            applyKnockback(forceX, forceY) {
                this.velocity.x = forceX;
                this.velocity.y = forceY;
            }
        }

        /**
         * @class AnimationManager
         * @description Componente respons√°vel por gerenciar anima√ß√µes de sprite.
         *              Ele agora opera manipulando o `src` de um elemento `<img>` ou `background-image` de um `div`.
         *              IMPORTANTE: Para anima√ß√µes, `frames` deve ser um ARRAY DE OBJETOS Image (quadros).
         *              Se um √∫nico Image for passado, ele assumir√° um sprite est√°tico.
         */
        class AnimationManager {
            constructor(entity, animationsConfig) {
                this.entity = entity; // Refer√™ncia √† entidade (Player, Enemy)
                this.htmlElement = entity.htmlElement; // O elemento DOM que representa a entidade
                this.imageElement = null; // Para entidades que usam <img>
                
                // Se a entidade usa <img> dentro de sua div, crie-a
                if (this.htmlElement.tagName === 'DIV') {
                    this.imageElement = document.createElement('img');
                    this.imageElement.style.width = '100%';
                    this.imageElement.style.height = '100%';
                    this.htmlElement.appendChild(this.imageElement);
                } else if (this.htmlElement.tagName === 'IMG') {
                    this.imageElement = this.htmlElement;
                }

                this.animations = {}; // { "idle": { frames: [Image, Image], frameDelay: 100, loop: true, currentFrameIndex: 0, frameTimer: 0 } }
                this.currentAnimationKey = 'idle'; // Key da anima√ß√£o atual
                this.isPlaying = true;
                this.onFinishCallbacks = {}; // Callbacks para anima√ß√µes n√£o-looping { "attack_u": callback }

                // Carrega as configura√ß√µes de anima√ß√£o
                for (const key in animationsConfig) {
                    const config = animationsConfig[key];
                    // IMPORTANT: `frames` here should be an array of Image objects for animation
                    // If you provide a single Image, it will be treated as a static sprite.
                    this.animations[key] = {
                        frames: Array.isArray(config.frames) ? config.frames : [config.frames],
                        frameDelay: config.frameDelay || 100,
                        loop: config.loop !== undefined ? config.loop : true,
                        currentFrameIndex: 0,
                        frameTimer: 0
                    };
                }
            }

            /**
             * Define uma fun√ß√£o de callback para quando uma anima√ß√£o n√£o-looping terminar.
             * @param {string} animationKey - A chave da anima√ß√£o.
             * @param {Function} callback - A fun√ß√£o a ser chamada.
             */
            onAnimationFinish(animationKey, callback) {
                this.onFinishCallbacks[animationKey] = callback;
            }

            /**
             * Muda para uma nova anima√ß√£o.
             * @param {string} animationKey - A chave da anima√ß√£o a ser tocada.
             * @param {boolean} forceRestart - Se true, reinicia a anima√ß√£o mesmo que j√° esteja tocando.
             */
            play(animationKey, forceRestart = false) {
                if (this.currentAnimationKey === animationKey && !forceRestart) {
                    return; // J√° est√° tocando esta anima√ß√£o
                }
                if (!this.animations[animationKey]) {
                    console.warn(`Anima√ß√£o '${animationKey}' n√£o encontrada.`);
                    return;
                }

                this.currentAnimationKey = animationKey;
                this.animations[animationKey].currentFrameIndex = 0; // Reinicia a anima√ß√£o
                this.animations[animationKey].frameTimer = 0;
                this.isPlaying = true;
            }

            /**
             * Atualiza o estado da anima√ß√£o (avan√ßa o quadro) e atualiza o sprite no DOM.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                if (!this.isPlaying || !this.htmlElement) return;

                const currentAnim = this.animations[this.currentAnimationKey];
                if (!currentAnim || currentAnim.frames.length === 0) {
                    if (this.imageElement) this.imageElement.src = ''; // Limpa a imagem se n√£o houver frames
                    return;
                }

                // Avan√ßa o frame da anima√ß√£o
                if (currentAnim.frames.length > 1) { // S√≥ anima se tiver mais de um frame
                    currentAnim.frameTimer += deltaTime;
                    if (currentAnim.frameTimer >= currentAnim.frameDelay) {
                        currentAnim.currentFrameIndex++;
                        currentAnim.frameTimer = 0;

                        if (currentAnim.currentFrameIndex >= currentAnim.frames.length) {
                            if (currentAnim.loop) {
                                currentAnim.currentFrameIndex = 0; // Volta para o in√≠cio
                            } else {
                                currentAnim.currentFrameIndex = currentAnim.frames.length - 1; // Para no √∫ltimo quadro
                                this.isPlaying = false; // Para a anima√ß√£o
                                if (this.onFinishCallbacks[this.currentAnimationKey]) {
                                    this.onFinishCallbacks[this.currentAnimationKey](); // Chama o callback de t√©rmino
                                }
                            }
                        }
                    }
                } else { // Se s√≥ tem 1 frame, s√≥ mostra ele e n√£o anima
                    currentAnim.currentFrameIndex = 0;
                    this.isPlaying = false;
                }

                // Atualiza o src do <img> ou background-image do <div>
                const currentFrame = currentAnim.frames[currentAnim.currentFrameIndex];
                if (this.imageElement) { // Se usa <img> tag interna
                    this.imageElement.src = currentFrame.src;
                } else { // Se usa background-image na pr√≥pria div
                    this.htmlElement.style.backgroundImage = `url('${currentFrame.src}')`;
                    this.htmlElement.style.backgroundSize = '100% 100%'; // Garante que a imagem preencha
                }
            }
        }

        // =================================================================================================
        // ===== 4. CLASSES DE ESTADOS (State Pattern) =====================================================
        // =================================================================================================

        /**
         * @class PlayerState
         * @description Classe base abstrata para todos os estados do jogador.
         */
        class PlayerState {
            constructor(player) {
                this.player = player;
            }

            onEnter() {}
            onUpdate(deltaTime) {}
            onFixedUpdate(deltaTime) {} // Para l√≥gica de f√≠sica
            onExit() {}
        }

        class PlayerIdleState extends PlayerState {
            onEnter() {
                this.player.animation.play('idle');
                this.player.physics.velocity.x = 0; // Para o movimento horizontal
            }
            onUpdate(deltaTime) {
                if (this.player.input.getMoveDirection() !== 0) {
                    this.player.transitionToState(new PlayerWalkState(this.player));
                } else if (this.player.input.isJumpPressed()) {
                    this.player.jump();
                    this.player.transitionToState(new PlayerJumpState(this.player)); // Transiciona para jump imediatamente
                } else if (this.player.input.isCrouchActive()) {
                    this.player.crouch(true);
                    this.player.transitionToState(new PlayerCrouchState(this.player));
                }
                // Habilidades s√£o verificadas fora dos estados para que possam ser usadas em qualquer estado relevante
            }
        }

        class PlayerWalkState extends PlayerState {
            onEnter() {
                this.player.animation.play('walk');
            }
            onUpdate(deltaTime) {
                const moveDirection = this.player.input.getMoveDirection();
                if (moveDirection === 0) {
                    this.player.transitionToState(new PlayerIdleState(this.player));
                } else if (this.player.input.isJumpPressed()) {
                    this.player.jump();
                    this.player.transitionToState(new PlayerJumpState(this.player));
                } else if (this.player.input.isCrouchActive()) {
                    this.player.crouch(true);
                    this.player.transitionToState(new PlayerCrouchState(this.player));
                }
                this.player.move(moveDirection);
            }
            onFixedUpdate(deltaTime) {
                this.player.physics.moveX(this.player.input.getMoveDirection(), this.player.currentSpeed);
            }
            onExit() {
                this.player.physics.velocity.x = 0; // Para o movimento ao sair do estado de andar
            }
        }

        class PlayerJumpState extends PlayerState {
            onEnter() {
                this.player.animation.play('jump', true); // Force restart para garantir a anima√ß√£o de pulo
                this.player.animation.onAnimationFinish('jump', () => {
                    // Ap√≥s a anima√ß√£o de pulo terminar, se ainda n√£o estiver no ch√£o, mant√©m o √∫ltimo frame
                    // ou transiciona para um estado de "caindo" se implementado.
                    // Para simplicidade, manteremos o controle de isGrounded para transi√ß√£o.
                });
            }
            onUpdate(deltaTime) {
                const moveDirection = this.player.input.getMoveDirection();
                this.player.move(moveDirection);

                // Se o jogador estiver no ch√£o e o input de pulo n√£o estiver mais ativo, retorna para Idle/Walk
                if (this.player.physics.isGrounded && !this.player.input.isJumpPressed()) {
                    if (moveDirection !== 0) {
                        this.player.transitionToState(new PlayerWalkState(this.player));
                    } else {
                        this.player.transitionToState(new PlayerIdleState(this.player));
                    }
                }
                // Se o input de agachar for pressionado no air, transiciona para agachado no ar (se aplic√°vel)
                // ou simplesmente ajusta a altura de colis√£o.
            }
            onFixedUpdate(deltaTime) {
                this.player.physics.moveX(this.player.input.getMoveDirection(), this.player.currentSpeed);
            }
        }

        class PlayerCrouchState extends PlayerState {
            onEnter() {
                this.player.crouch(true);
                this.player.animation.play('crouch');
            }
            onUpdate(deltaTime) {
                if (!this.player.input.isCrouchActive()) {
                    // Tenta levantar
                    if (this.player.canStandUp()) {
                        this.player.crouch(false);
                        const moveDirection = this.player.input.getMoveDirection();
                        if (moveDirection !== 0) {
                            this.player.transitionToState(new PlayerWalkState(this.player));
                        } else {
                            this.player.transitionToState(new PlayerIdleState(this.player));
                        }
                    }
                }
                // Se pular enquanto agachado (salto baixo ou rolamento)
                else if (this.player.input.isJumpPressed()) {
                    this.player.crouch(false); // Levanta ao pular
                    this.player.jump(CONFIG.JUMP_FORCE * 0.7); // Pulo mais baixo
                    this.player.transitionToState(new PlayerJumpState(this.player));
                }
            }
            onExit() {
                this.player.crouch(false); // Garante que o jogador est√° em p√© ao sair
            }
        }

        class PlayerAbilityState extends PlayerState {
            constructor(player, animationKey, nextStateIfFinished = null) {
                super(player);
                this.animationKey = animationKey;
                // Define o estado para o qual transicionar automaticamente ap√≥s a anima√ß√£o da habilidade
                this.nextStateIfFinished = nextStateIfFinished || new PlayerIdleState(player);
            }

            onEnter() {
                this.player.animation.play(this.animationKey, true); // For√ßa a anima√ß√£o da habilidade
                // Define um callback para quando a anima√ß√£o da habilidade terminar
                this.player.animation.onAnimationFinish(this.animationKey, () => {
                    this.player.transitionToState(this.nextStateIfFinished);
                });
            }

            onUpdate(deltaTime) {
                // Durante a anima√ß√£o da habilidade, o jogador pode ter movimento limitado ou nenhum.
                // Isso depende da habilidade. Por exemplo, um dash ainda pode ter movimento.
                // Para simplificar, o jogador n√£o se move durante a anima√ß√£o de habilidade aqui.
            }
            onFixedUpdate(deltaTime) {
                 this.player.physics.velocity.x = 0; // Para garantir que o jogador n√£o deslize durante a habilidade
            }
            onExit() {
                // Remove o callback para evitar que seja chamado novamente se o estado mudar antes da anima√ß√£o terminar
                this.player.animation.onAnimationFinish(this.animationKey, null);
            }
        }
        
        class PlayerDamageState extends PlayerState {
            constructor(player) {
                super(player);
                this.canExit = false;
            }

            onEnter() {
                this.player.animation.play('take_damage', true);
                this.player.animation.onAnimationFinish('take_damage', () => {
                    this.canExit = true; // Permite sair do estado ap√≥s a anima√ß√£o de dano
                });
            }

            onUpdate(deltaTime) {
                // Se a invencibilidade acabou e a anima√ß√£o de dano terminou, volta para o estado normal.
                if (!this.player.health.isInvincible && this.canExit) {
                    // Volta para idle ou walk dependendo do input
                    const moveDirection = this.player.input.getMoveDirection();
                    if (moveDirection !== 0) {
                        this.player.transitionToState(new PlayerWalkState(this.player));
                    } else {
                        this.player.transitionToState(new PlayerIdleState(this.player));
                    }
                }
                // Permite algum controle de movimento leve enquanto toma dano
                // this.player.physics.moveX(this.player.input.getMoveDirection(), this.player.currentSpeed * 0.5);
            }

            onFixedUpdate(deltaTime) {
                // N√£o altera a velocidade de knockback enquanto estiver neste estado
            }

            onExit() {
                this.player.animation.onAnimationFinish('take_damage', null);
            }
        }


        /**
         * @class EnemyState
         * @description Classe base abstrata para todos os estados do inimigo.
         */
        class EnemyState {
            constructor(enemy) {
                this.enemy = enemy;
            }
            onEnter() {}
            onUpdate(deltaTime) {}
            onFixedUpdate(deltaTime) {}
            onExit() {}
        }

        class EnemyPatrolState extends EnemyState {
            onEnter() {
                this.enemy.animation.play('idle'); // Inimigos podem ter anima√ß√µes diferentes para patrulha
            }
            onUpdate(deltaTime) {
                // Verifica a proximidade do jogador para transicionar para o estado de ataque
                const distanceToPlayer = Math.abs(this.enemy.position.x - gameState.player.position.x);
                if (distanceToPlayer < 200) { // Raio de detec√ß√£o
                    this.enemy.transitionToState(new EnemyAttackState(this.enemy));
                }
            }
            onFixedUpdate(deltaTime) {
                this.enemy._patrol(deltaTime);
            }
        }

        class EnemyAttackState extends EnemyState {
            onEnter() {
                this.enemy.animation.play('attack');
                this.enemy.attackCooldown = 0; // Reseta cooldown para poder atacar imediatamente
            }
            onUpdate(deltaTime) {
                const distanceToPlayer = Math.abs(this.enemy.position.x - gameState.player.position.x);
                if (distanceToPlayer > 250) { // Se o jogador se afastou muito
                    this.enemy.transitionToState(new EnemyPatrolState(this.enemy));
                } else {
                    this.enemy.attackCooldown -= deltaTime;
                    if (this.enemy.attackCooldown <= 0) {
                        this.enemy._attack();
                        this.enemy.attackCooldown = 2000 + Math.random() * 1000;
                    }
                }
            }
            onFixedUpdate(deltaTime) {
                // Inimigo pode se mover levemente enquanto ataca
                const directionToPlayer = gameState.player.position.x > this.enemy.position.x ? 1 : -1;
                this.enemy.physics.moveX(directionToPlayer, this.enemy.speed * 0.5);
            }
        }

        class EnemyBossState extends EnemyState {
            onEnter() {
                this.enemy.animation.play('idle'); // Bosses podem ter anima√ß√µes de combate espec√≠ficas
            }
            onUpdate(deltaTime) {
                // L√≥gica de AI do boss
                this.enemy._updateBossAI(deltaTime);
            }
            onFixedUpdate(deltaTime) {
                // A movimenta√ß√£o do boss √© controlada pela AI em _updateBossAI
            }
        }

        // =================================================================================================
        // ===== 5. CLASSES DE ENTIDADES DO JOGO (Composi√ß√£o de Componentes) ===============================
        // =================================================================================================

        /**
         * @class Player
         * @description Representa o personagem principal do jogo, usando composi√ß√£o de componentes e State Pattern.
         */
        class Player {
            constructor(name, playerConfig) {
                this.playerName = name;
                this.isPlayer = true; // Flag para identificar
                this.position = { x: 100, y: 300 }; // Posi√ß√£o inicial

                // Cria o elemento DOM para o jogador
                this.htmlElement = document.createElement('div');
                this.htmlElement.className = 'game-entity player-sprite';
                this.htmlElement.id = 'player-entity';
                gameWorldElement.appendChild(this.htmlElement);

                this.damage = playerConfig.baseDamage; // Dano base do jogador
                this.baseSpeed = playerConfig.baseSpeed;
                this.currentSpeed = this.baseSpeed; // Velocidade atual

                // Componentes
                this.input = new PlayerInput();
                this.health = new HealthComponent(playerConfig.baseHealth, CONFIG.HEALTH_REGEN_RATE);
                this.mana = new ManaComponent(playerConfig.baseMana, playerConfig.manaRegenRate);
                this.physics = new PhysicsComponent(this, CONFIG.PLAYER_WIDTH, CONFIG.PLAYER_HEIGHT);
                this.animation = new AnimationManager(this, {
                    // Para funcionar com GIFs ou sequ√™ncias de frames, certifique-se que ASSET_LOADED
                    // cont√©m o array de objetos Image para cada anima√ß√£o.
                    // Se apenas um √∫nico Image (do GIF) estiver em ASSET_LOADED, a anima√ß√£o ser√° est√°tica.
                    idle: { frames: CONFIG.ASSET_LOADED.player_idle, frameDelay: 150 },
                    walk: { frames: CONFIG.ASSET_LOADED.player_walk, frameDelay: 100 },
                    jump: { frames: CONFIG.ASSET_LOADED.player_jump, frameDelay: 100, loop: false },
                    crouch: { frames: CONFIG.ASSET_LOADED.player_crouch, frameDelay: 100 },
                    attack_u: { frames: CONFIG.ASSET_LOADED.player_attack_u, frameDelay: 80, loop: false },
                    attack_i: { frames: CONFIG.ASSET_LOADED.player_attack_i, frameDelay: 100, loop: false },
                    attack_o: { frames: CONFIG.ASSET_LOADED.player_attack_o, frameDelay: 120, loop: false },
                    ultimate: { frames: CONFIG.ASSET_LOADED.player_ultimate, frameDelay: 100, loop: true },
                    take_damage: { frames: CONFIG.ASSET_LOADED.player_damage, frameDelay: 200, loop: false }
                });

                // Estado (State Pattern)
                this.currentState = null;
                this.transitionToState(new PlayerIdleState(this));

                // Propriedades espec√≠ficas do jogador
                this.isCrouching = false;
                this.facing = 'right'; // Dire√ß√£o para onde o jogador est√° olhando

                // Habilidades
                this.abilities = {};
                playerConfig.abilities.forEach(abilityData => {
                    const AbilityClass = PlayerAbilityFactory.createAbility(abilityData.name);
                    if (AbilityClass) {
                        this.abilities[abilityData.key] = new AbilityClass(this, abilityData);
                    }
                });
                
                // Event Listeners (Observer Pattern)
                EventManager.subscribe('player_damaged', (data) => {
                    UIManager.updateHealth(data);
                    // Transiciona para o estado de dano se n√£o estiver invenc√≠vel ou j√° em dano
                    if (this.health.isInvincible && !(this.currentState instanceof PlayerDamageState)) {
                        this.transitionToState(new PlayerDamageState(this));
                    }
                });
                EventManager.subscribe('player_healed', (data) => {
                    UIManager.updateHealth(data);
                });
                EventManager.subscribe('player_mana_changed', (data) => {
                    UIManager.updateMana(data);
                });
                EventManager.subscribe('xp_gained', (data) => {
                    UIManager.updateXP(data);
                });
                EventManager.subscribe('level_up', (data) => {
                    UIManager.showLevelUpMenu(data);
                });
                EventManager.subscribe('player_state_change', (newState) => {
                    // L√≥gica para debug ou rea√ß√µes globais a mudan√ßas de estado
                });
            }

            /**
             * Transiciona o jogador para um novo estado.
             * @param {PlayerState} newState - A nova inst√¢ncia de estado.
             */
            transitionToState(newState) {
                if (this.currentState) {
                    this.currentState.onExit();
                }
                this.currentState = newState;
                this.currentState.onEnter();
                EventManager.emit('player_state_change', newState.constructor.name);
            }

            /**
             * Atualiza o jogador no loop de jogo.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                this.health.update(deltaTime);
                this.mana.update(deltaTime);

                // Atualiza o estado atual (movimento, a√ß√µes espec√≠ficas do estado)
                this.currentState.onUpdate(deltaTime);
                
                // Processa as habilidades (elas podem ser ativadas em v√°rios estados)
                this._processAbilities(deltaTime);

                // Atualiza a anima√ß√£o
                this.animation.update(deltaTime);

                // Atualiza a dire√ß√£o do sprite baseado na f√≠sica ou input
                const moveDir = this.input.getMoveDirection();
                if (moveDir > 0) {
                    this.facing = 'right';
                    this.htmlElement.style.transform = 'scaleX(1)'; // N√£o vira o sprite
                } else if (moveDir < 0) {
                    this.facing = 'left';
                    this.htmlElement.style.transform = 'scaleX(-1)'; // Vira o sprite horizontalmente
                }
            }
            
            /**
             * Atualiza a l√≥gica de f√≠sica do jogador no loop de jogo (chamado em FixedUpdate).
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            fixedUpdate(deltaTime) {
                this.currentState.onFixedUpdate(deltaTime);
                this.physics.update(deltaTime);
            }

            /**
             * Move o jogador horizontalmente.
             * @param {number} direction - -1 para esquerda, 1 para direita, 0 para parado.
             */
            move(direction) {
                this.physics.moveX(direction, this.currentSpeed);
            }

            /**
             * Faz o jogador pular.
             */
            jump(force = CONFIG.JUMP_FORCE) {
                if (this.physics.isGrounded) {
                    this.physics.jump(force);
                }
            }

            /**
             * Altera o estado de agachamento do jogador.
             * @param {boolean} crouch - True para agachar, false para levantar.
             */
            crouch(crouch) {
                this.isCrouching = crouch;
                this.physics.height = crouch ? CONFIG.CROUCH_HEIGHT : CONFIG.PLAYER_HEIGHT;
                // Ajusta a posi√ß√£o Y ao agachar para que o ch√£o permane√ßa o mesmo
                if (crouch && this.physics.isGrounded) {
                    this.position.y += (CONFIG.PLAYER_HEIGHT - CONFIG.CROUCH_HEIGHT);
                } else if (!crouch && this.physics.isGrounded) {
                    this.position.y -= (CONFIG.PLAYER_HEIGHT - CONFIG.CROUCH_HEIGHT);
                }
                // Atualiza o estilo da altura do elemento HTML
                this.htmlElement.style.height = `${this.physics.height}px`;
            }

            /**
             * Verifica se o jogador pode levantar sem colidir com algo acima.
             * @returns {boolean}
             */
            canStandUp() {
                const newHeight = CONFIG.PLAYER_HEIGHT;
                const newY = this.position.y - (newHeight - CONFIG.CROUCH_HEIGHT);
                for (const platform of platforms) {
                    if (this.physics._checkCollision(this.position.x, newY, CONFIG.PLAYER_WIDTH, newHeight, platform)) {
                        return false;
                    }
                }
                return true;
            }

            /**
             * Gerencia o uso das habilidades.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            _processAbilities(deltaTime) {
                for (const key in this.abilities) {
                    const ability = this.abilities[key];
                    ability.updateCooldown(deltaTime); // Atualiza cooldown para todas as habilidades

                    if (this.input.isAbilityPressed(key.toLowerCase())) {
                        ability.activate(); // Tenta ativar a habilidade
                    }
                }
            }

            /**
             * Atualiza a posi√ß√£o do elemento DOM do jogador.
             */
            render() {
                // Atualiza a posi√ß√£o e tamanho do elemento HTML
                this.htmlElement.style.left = `${this.position.x}px`;
                this.htmlElement.style.top = `${this.position.y}px`;
                this.htmlElement.style.width = `${CONFIG.PLAYER_WIDTH}px`;
                this.htmlElement.style.height = `${this.physics.height}px`; // Altura pode mudar ao agachar

                // Efeito de piscar durante a invencibilidade
                if (this.health.isInvincible && Math.floor(performance.now() / 100) % 2) {
                    this.htmlElement.style.opacity = '0.5';
                } else {
                    this.htmlElement.style.opacity = '1';
                }
            }

            /**
             * Remove o elemento DOM do jogo.
             */
            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }

        /**
         * @class Enemy
         * @description Classe base para inimigos.
         */
        class Enemy {
            constructor(type, x, y, config) {
                this.type = type;
                this.isPlayer = false;
                this.position = { x: x, y: y };
                this.config = config;

                // Cria o elemento DOM para o inimigo
                this.htmlElement = document.createElement('div');
                this.htmlElement.className = `game-entity enemy-sprite enemy-${type}`;
                this.htmlElement.id = `enemy-${Date.now()}-${Math.random().toFixed(0)}`; // ID √∫nico
                gameWorldElement.appendChild(this.htmlElement);

                // Elemento da barra de vida (DOM)
                this.healthBarElement = document.createElement('div');
                this.healthBarElement.className = 'entity-health-bar';
                this.healthFillElement = document.createElement('div');
                this.healthFillElement.className = 'entity-health-fill';
                this.healthBarElement.appendChild(this.healthFillElement);
                this.htmlElement.appendChild(this.healthBarElement);
                this.healthBarElement.style.display = 'none'; // Esconder por padr√£o

                this.health = new HealthComponent(config.health);
                this.physics = new PhysicsComponent(this, 50, 50); // Assumindo tamanho padr√£o para inimigos
                this.damage = config.damage;
                this.speed = config.speed;
                this.xpValue = config.xpValue;

                this.animation = new AnimationManager(this, {
                    idle: { frames: CONFIG.ASSET_LOADED.sentinel_sprite, frameDelay: 150 },
                    attack: { frames: CONFIG.ASSET_LOADED.sentinel_sprite, frameDelay: 150 }, // Exemplo, pode ser um sprite diferente
                    // ... mais anima√ß√µes para inimigos
                });
                this.animation.play('idle');

                this.currentState = null;
                this.transitionToState(new EnemyPatrolState(this)); // Estado inicial

                // Propriedades de patrulha
                this.patrolStartX = x;
                this.patrolRange = config.patrolRange || 100;
                this.patrolDirection = 1;

                // Propriedades de ataque
                this.attackCooldown = 0;

                // Event Listeners
                EventManager.subscribe('entity_died', (entity) => {
                    if (entity === this) {
                        EventManager.emit('enemy_defeated', this);
                        this.destroy(); // Remove o elemento DOM quando morre
                    }
                });
                // Evento para mostrar barra de vida do inimigo quando atingido pelo jogador
                EventManager.subscribe('player_attack', (attackData) => {
                    // Simplifica√ß√£o: se o player ataca, mostramos a barra de vida de todos os inimigos.
                    // Em um jogo real, voc√™ passaria o inimigo atingido.
                    this.healthBarElement.style.display = 'block';
                });
            }

            transitionToState(newState) {
                if (this.currentState) {
                    this.currentState.onExit();
                }
                this.currentState = newState;
                this.currentState.onEnter();
            }

            update(deltaTime) {
                this.health.update(deltaTime);
                this.currentState.onUpdate(deltaTime);
                this.animation.update(deltaTime);
            }
            
            fixedUpdate(deltaTime) {
                this.currentState.onFixedUpdate(deltaTime);
                this.physics.update(deltaTime);
            }

            render() {
                // Atualiza a posi√ß√£o e tamanho do elemento HTML
                this.htmlElement.style.left = `${this.position.x}px`;
                this.htmlElement.style.top = `${this.position.y}px`;
                this.htmlElement.style.width = `${this.physics.width}px`;
                this.htmlElement.style.height = `${this.physics.height}px`;

                // Renderizar barra de vida se houver dano
                if (this.health.currentHealth < this.health.maxHealth) {
                    this.healthBarElement.style.display = 'block';
                    const healthPercent = this.health.currentHealth / this.health.maxHealth;
                    this.healthFillElement.style.width = `${healthPercent * 100}%`;
                    if (healthPercent > 0.5) {
                        this.healthFillElement.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
                    } else if (healthPercent > 0.25) {
                        this.healthFillElement.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
                    } else {
                        this.healthFillElement.style.background = 'linear-gradient(90deg, #f44336, #e53935)';
                    }
                    // Posiciona a barra de vida acima do inimigo
                    this.healthBarElement.style.left = `${(this.physics.width / 2) - (this.healthBarElement.offsetWidth / 2)}px`; // Centraliza no inimigo
                    this.healthBarElement.style.top = `-15px`;
                } else {
                    this.healthBarElement.style.display = 'none';
                }
            }

            takeDamage(amount) {
                this.health.takeDamage(amount, 0); // Inimigos n√£o t√™m invencibilidade ap√≥s dano por padr√£o
                EventManager.emit('add_particles', { type: 'hitSpark', x: this.position.x + this.physics.width / 2, y: this.position.y + this.physics.height / 2, count: 8 });
                EventManager.emit('sfx_play', 'sfx_damage_enemy');
                
                if (this.health.currentHealth <= 0) {
                    EventManager.emit('add_particles', { type: 'deathExplosion', x: this.position.x + this.physics.width / 2, y: this.position.y + this.physics.height / 2, count: 20 });
                    EventManager.emit('screen_shake', { intensity: 4, duration: 200 });
                }
            }

            _patrol(deltaTime) {
                this.physics.moveX(this.patrolDirection, this.speed);
                if (this.position.x > this.patrolStartX + this.patrolRange) {
                    this.patrolDirection = -1;
                    this.htmlElement.style.transform = 'scaleX(-1)'; // Vira o sprite
                } else if (this.position.x < this.patrolStartX - this.patrolRange) {
                    this.patrolDirection = 1;
                    this.htmlElement.style.transform = 'scaleX(1)'; // Vira o sprite
                }
            }

            _attack() {
                // Implementa√ß√£o padr√£o de ataque para sentinela
                const direction = gameState.player.position.x > this.position.x ? 1 : -1;
                EventManager.emit('spawn_projectile', {
                    type: 'enemyIceShot',
                    x: this.position.x + (direction > 0 ? this.physics.width : -25),
                    y: this.position.y + 15,
                    damage: this.damage,
                    direction: direction,
                    speed: 5,
                    origin: 'enemy'
                });
                EventManager.emit('add_particles', { type: 'enemyMuzzle', x: this.position.x + this.physics.width / 2, y: this.position.y + 15, count: 6 });
            }

            /**
             * Remove o elemento DOM do jogo.
             */
            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }

        /**
         * @class BossTarek
         * @description Classe espec√≠fica para o boss Tarek, que estende Enemy.
         */
        class BossTarek extends Enemy {
            constructor(x, y, config) {
                super('boss', x, y, config);
                this.name = 'Tarek, o Guerreiro';
                // Adapta o elemento HTML para o sprite do Tarek (se houver um CSS espec√≠fico)
                this.htmlElement.classList.add('boss-tarek-sprite');

                this.health = new HealthComponent(config.health); // Sobrescreve para usar o HealthComponent
                this.physics = new PhysicsComponent(this, 70, 70); // Tamanho espec√≠fico para o boss
                // Ajusta o tamanho do elemento HTML
                this.htmlElement.style.width = `${this.physics.width}px`;
                this.htmlElement.style.height = `${this.physics.height}px`;

                this.animation = new AnimationManager(this, {
                    idle: { frames: CONFIG.ASSET_LOADED.tarek_sprite, frameDelay: 150 },
                    // ... outras anima√ß√µes do boss (ataque, habilidades)
                });
                this.animation.play('idle');

                this.abilities = [
                    { name: 'Golpe Devastador', cooldown: 3000, range: 80, damage: 35, lastUsed: 0 },
                    { name: 'Investida G√©lida', cooldown: 6000, range: 300, damage: 45, lastUsed: 0 },
                    { name: 'Orbe Congelante', cooldown: 5000, range: 400, damage: 30, lastUsed: 0 },
                    { name: 'Pris√£o de Gelo', cooldown: 10000, range: 200, damage: 20, lastUsed: 0 }
                ];
                this.aiState = 'combat';
                this.aiTimer = 0;
                this.enraged = false; // Estado de f√∫ria do boss

                this.transitionToState(new EnemyBossState(this)); // Estado inicial
            }

            _updateBossAI(deltaTime) {
                const distanceToPlayer = Math.abs(this.position.x - gameState.player.position.x);
                const currentTime = performance.now();

                // L√≥gica de F√∫ria
                if (this.health.currentHealth < this.health.maxHealth * 0.4 && !this.enraged) {
                    this.enraged = true;
                    this.speed *= 1.3;
                    this.damage *= 1.1;
                    this.abilities.forEach(ab => ab.cooldown *= 0.8);
                    EventManager.emit('screen_flash', { color: COLOR_ACCENT_FIRE, duration: 500 });
                    EventManager.emit('add_particles', { type: 'bossIntro', x: this.position.x + 35, y: this.position.y + 35, count: 50 });
                    GameManager.showDialog("TAREK", "Voc√™... √© mais forte do que pensei! Mas n√£o vou cair facilmente!");
                }

                this.aiTimer += deltaTime;

                // Movimento para dentro da arena (fixo se c√¢mera fixa)
                // A l√≥gica de arena fixa com cameraOffset ser√° tratada pela renderiza√ß√£o global do gameWorldElement
                // mas o boss precisa respeitar limites.
                const arenaMinX = gameState.fixedCamera ? gameState.cameraOffset.x : 0;
                const arenaMaxX = gameState.fixedCamera ? gameState.cameraOffset.x + gameWorldElement.offsetWidth - this.physics.width : CONFIG.WORLD_WIDTH - this.physics.width;

                // Verifica qual habilidade usar
                let chosenAbility = null;
                this.abilities.forEach(ability => {
                    const ready = (currentTime - ability.lastUsed) >= ability.cooldown;
                    if (ready) {
                        if (ability.name === 'Golpe Devastador' && distanceToPlayer < ability.range) {
                            chosenAbility = ability;
                        } else if (ability.name === 'Investida G√©lida' && distanceToPlayer > 100 && distanceToPlayer < ability.range) {
                            chosenAbility = ability;
                        } else if (ability.name === 'Orbe Congelante' && distanceToPlayer > 150) {
                            chosenAbility = ability;
                        } else if (ability.name === 'Pris√£o de Gelo' && Math.random() < 0.3) {
                            chosenAbility = ability;
                        }
                    }
                });
                
                if (chosenAbility && this.aiTimer > 500) {
                    this._executeBossAbility(chosenAbility);
                    this.aiTimer = 0;
                } else {
                    this._moveBossTowardsPlayer(distanceToPlayer);
                }
            }

            _moveBossTowardsPlayer(distance) {
                if (distance > 50) {
                    const direction = gameState.player.position.x > this.position.x ? 1 : -1;
                    this.physics.moveX(direction, this.speed);
                    // L√≥gica de pulo do boss se necess√°rio
                    if (this.physics.isGrounded && gameState.player.position.y < this.position.y - 50) {
                         this.physics.jump(CONFIG.JUMP_FORCE * 0.8);
                    }
                } else {
                    this.physics.velocity.x = 0; // Para quando est√° perto
                }
            }

            _executeBossAbility(ability) {
                const direction = gameState.player.position.x > this.position.x ? 1 : -1;
                ability.lastUsed = performance.now();

                switch(ability.name) {
                    case 'Golpe Devastador':
                        EventManager.emit('spawn_projectile', {
                            type: 'bossSlash', x: this.position.x + (direction > 0 ? 70 : -50), y: this.position.y + 10,
                            width: 70, height: 30, duration: 300, damage: ability.damage, origin: 'enemy', knockback: 20
                        });
                        EventManager.emit('screen_shake', { intensity: 6, duration: 300 });
                        break;
                    case 'Investida G√©lida':
                        this.physics.applyKnockback(direction * 10, 0); // Impulso para a investida
                        EventManager.emit('spawn_projectile', {
                            type: 'bossDash', x: this.position.x, y: this.position.y,
                            width: 70, height: 50, duration: 800, damage: ability.damage, origin: 'enemy', followBoss: this
                        });
                        EventManager.emit('add_particles', { type: 'dashIce', x: this.position.x + 35, y: this.position.y + 35, count: 30 });
                        EventManager.emit('screen_shake', { intensity: 8, duration: 400 });
                        break;
                    case 'Orbe Congelante':
                        EventManager.emit('spawn_projectile', {
                            type: 'bossIceOrb', x: this.position.x + (direction > 0 ? 80 : -30), y: this.position.y + 20,
                            width: 40, height: 40, duration: 3000, damage: ability.damage, direction: direction, speed: 4, origin: 'enemy'
                        });
                        break;
                    case 'Pris√£o de Gelo':
                        for (let i = 0; i < 3; i++) {
                            const offsetX = (i - 1) * 80;
                            EventManager.emit('spawn_projectile', {
                                type: 'bossPrison', x: gameState.player.position.x + offsetX - 15, y: gameState.player.position.y - 60,
                                width: 30, height: 120, duration: 5000, damage: ability.damage, origin: 'enemy', trapping: true, delay: i * 200, active: false
                            });
                        }
                        EventManager.emit('screen_shake', { intensity: 5, duration: 600 });
                        break;
                }
            }
        }


        /**
         * @class Projectile
         * @description Classe base para proj√©teis (habilidades, ataques inimigos), integrada com Object Pooling.
         */
        class Projectile {
            constructor(poolTag) {
                this.poolTag = poolTag;
                this.isActive = false;
                this.position = { x: 0, y: 0 };
                this.width = 0;
                this.height = 0;
                this.speed = 0;
                this.damage = 0;
                this.direction = { x: 0, y: 0 };
                this.originTag = ''; // "player" ou "enemy"
                this.lifetime = 0;
                this.currentLifetime = 0;
                this.piercing = false;
                this.hitTargets = []; // Para proj√©teis perfurantes
                this.followBoss = null; // Para habilidades que seguem o boss
                this.delay = 0; // Para armadilhas com delay de ativa√ß√£o
                this.trapping = false; // Para pris√µes que prendem o jogador

                // Elemento DOM para o proj√©til
                this.htmlElement = document.createElement('div');
                this.htmlElement.className = `game-entity projectile-sprite projectile-${poolTag}`;
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.display = 'none'; // Esconder por padr√£o
                gameWorldElement.appendChild(this.htmlElement);
            }

            /**
             * Inicializa o proj√©til ao ser retirado da pool.
             * @param {object} config - Configura√ß√µes do proj√©til.
             */
            initialize(config) {
                this.isActive = true;
                this.position.x = config.x;
                this.position.y = config.y;
                this.width = config.width || 20;
                this.height = config.height || 20;
                this.speed = config.speed || 0;
                this.damage = config.damage || 0;
                this.direction.x = config.direction || 0;
                this.direction.y = config.directionY || 0; // Adicionado para dire√ß√µes Y
                this.originTag = config.origin || '';
                this.lifetime = config.duration || 1000;
                this.currentLifetime = this.lifetime;
                this.piercing = config.piercing || false;
                this.hitTargets = []; // Reseta hits para cada uso
                this.followBoss = config.followBoss || null;
                this.delay = config.delay || 0;
                this.trapping = config.trapping || false;

                this.htmlElement.style.display = 'block'; // Mostrar
                this.htmlElement.style.width = `${this.width}px`;
                this.htmlElement.style.height = `${this.height}px`;

                // Configura o visual do proj√©til baseado no tipo
                switch(this.poolTag) {
                    case 'darkShotProjectile':
                        this.htmlElement.style.backgroundColor = COLOR_UMBRA;
                        this.htmlElement.style.borderRadius = '0'; // Rectangular
                        break;
                    case 'etherealOrbProjectile':
                        this.htmlElement.style.borderRadius = '50%';
                        this.htmlElement.style.backgroundColor = COLOR_UMBRA;
                        this.htmlElement.style.boxShadow = `0 0 10px ${COLOR_UMBRA}`;
                        break;
                    case 'enemyIceShot':
                        this.htmlElement.style.backgroundColor = COLOR_ACCENT_ICE;
                        this.htmlElement.style.borderRadius = '0';
                        break;
                    case 'bossSlash':
                        this.htmlElement.style.backgroundColor = COLOR_ACCENT_FIRE;
                        this.htmlElement.style.borderRadius = '0';
                        break;
                    case 'bossIceOrb':
                        this.htmlElement.style.borderRadius = '50%';
                        this.htmlElement.style.backgroundColor = COLOR_ACCENT_ICE;
                        break;
                    case 'bossPrison':
                        this.htmlElement.style.backgroundColor = 'rgba(168, 208, 230, 0.7)';
                        this.htmlElement.style.border = `3px solid ${COLOR_ACCENT_ICE}`;
                        this.htmlElement.style.borderRadius = '0';
                        break;
                    case 'bossDash':
                        this.htmlElement.style.backgroundColor = 'rgba(255, 107, 107, 0.5)';
                        this.htmlElement.style.borderRadius = '0';
                        break;
                }
            }

            /**
             * Atualiza a l√≥gica do proj√©til a cada frame.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                if (!this.isActive) return;

                if (this.delay > 0) {
                    this.delay -= deltaTime;
                    if (this.delay <= 0) {
                        // Ativa o proj√©til ap√≥s o delay
                        this.isActive = true;
                        if (this.poolTag === 'bossPrison') { // type √© para l√≥gica, poolTag para o visual
                            EventManager.emit('add_particles', { type: 'prisonActivate', x: this.position.x + this.width / 2, y: this.position.y + this.height / 2, count: 20 });
                        }
                    } else {
                        this.htmlElement.style.display = 'none'; // Esconder durante o delay
                        return; // N√£o atualiza movimento ou colis√£o durante o delay
                    }
                } else {
                    this.htmlElement.style.display = 'block'; // Garantir visibilidade ap√≥s delay
                }

                // L√≥gica de movimento e lifetime
                if (this.followBoss) {
                    this.position.x = this.followBoss.position.x;
                    this.position.y = this.followBoss.position.y;
                } else {
                    this.position.x += this.speed * this.direction.x * (deltaTime / 1000);
                    this.position.y += this.speed * this.direction.y * (deltaTime / 1000);
                }

                this.currentLifetime -= deltaTime;
                if (this.currentLifetime <= 0) {
                    this.deactivate(); // Retorna √† pool
                    return;
                }

                this._checkCollisions();

                // L√≥gica espec√≠fica para armadilhas (pris√µes)
                if (this.trapping && this.isActive) {
                    const playerRect = {
                        x: gameState.player.position.x,
                        y: gameState.player.position.y,
                        width: CONFIG.PLAYER_WIDTH,
                        height: gameState.player.physics.height
                    };
                    const prisonRect = {
                        x: this.position.x,
                        y: this.position.y,
                        width: this.width,
                        height: this.height
                    };

                    if (this._checkAABB(playerRect, prisonRect)) {
                        // Reduzir velocidade do jogador
                        gameState.player.physics.velocity.x *= 0.1;
                        gameState.player.physics.velocity.y *= 0.1;
                        // Dano cont√≠nuo
                        if (Math.random() < 0.05) { // 5% de chance de dano por frame
                            gameState.player.health.takeDamage(this.damage * (deltaTime / 1000), 0); // Sem invencibilidade
                        }
                    }
                }
            }

            _checkCollisions() {
                const targetRect = { x: this.position.x, y: this.position.y, width: this.width, height: this.height };

                if (this.originTag === 'player') {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const enemyRect = { x: enemy.position.x, y: enemy.position.y, width: enemy.physics.width, height: enemy.physics.height };

                        if (!this.hitTargets.includes(enemy) && this._checkAABB(targetRect, enemyRect)) {
                            enemy.takeDamage(this.damage);
                            if (!this.piercing) {
                                this.deactivate();
                                return; // Atingiu um inimigo, desativa e sai
                            } else {
                                this.hitTargets.push(enemy); // Adiciona ao hitTargets para n√£o atingir de novo
                            }
                        }
                    }
                } else if (this.originTag === 'enemy') {
                    const playerRect = { x: gameState.player.position.x, y: gameState.player.position.y, width: CONFIG.PLAYER_WIDTH, height: gameState.player.physics.height };
                    if (this._checkAABB(targetRect, playerRect)) {
                        gameState.player.health.takeDamage(this.damage);
                        this.deactivate(); // Atingiu o jogador, desativa
                        return;
                    }
                }

                // Colis√£o com plataformas (para proj√©teis que n√£o atravessam paredes)
                if (this.poolTag !== 'bossDash' && this.poolTag !== 'bossPrison' && this.poolTag !== 'explosion') {
                    for (const platform of platforms) {
                        const platformRect = { x: platform.x, y: platform.y, width: platform.width, height: platform.height };
                        if (this._checkAABB(targetRect, platformRect)) {
                            this.deactivate(); // Colidiu com plataforma, desativa
                            return;
                        }
                    }
                }
            }

            _checkAABB(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            /**
             * Retorna o proj√©til para a pool.
             */
            deactivate() {
                this.isActive = false;
                this.htmlElement.style.display = 'none'; // Esconder
                ObjectPooler.Instance.returnToPool(this.poolTag, this);
            }

            /**
             * Atualiza a posi√ß√£o do elemento DOM do proj√©til.
             */
            render() {
                if (!this.isActive || this.delay > 0) return; // N√£o renderiza durante o delay

                this.htmlElement.style.left = `${this.position.x}px`;
                this.htmlElement.style.top = `${this.position.y}px`;

                // Transpar√™ncia para bossDash
                if (this.poolTag === 'bossDash') {
                    const alpha = this.currentLifetime / this.lifetime;
                    this.htmlElement.style.opacity = `${alpha * 0.5}`;
                } else {
                    this.htmlElement.style.opacity = '1';
                }
            }
        }

        /**
         * @class Particle
         * @description Classe para part√≠culas de efeitos visuais, integrada com Object Pooling.
         *              Renderiza no DOM como divs pequenas e coloridas.
         */
        class Particle {
            constructor(poolTag) {
                this.poolTag = poolTag;
                this.isActive = false;
                this.x = 0;
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                this.size = 0;
                this.alpha = 1;
                this.color = '';
                this.gravity = false;
                this.life = 0;
                this.maxLife = 0;

                this.htmlElement = document.createElement('div');
                this.htmlElement.className = `particle particle-${poolTag}`;
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.borderRadius = '50%';
                this.htmlElement.style.display = 'none';
                gameWorldElement.appendChild(this.htmlElement);
            }

            /**
             * Inicializa a part√≠cula ao ser retirada da pool.
             * @param {object} config - Configura√ß√µes da part√≠cula.
             */
            initialize(config) {
                this.isActive = true;
                this.x = config.x + (Math.random() - 0.5) * 20;
                this.y = config.y + (Math.random() - 0.5) * 20;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.size = 2 + Math.random() * 3;
                this.alpha = 1;
                this.gravity = false;
                this.life = 500;
                this.maxLife = 500;
                this.color = config.color || '#ffffff';

                switch(config.type) {
                    case 'snow':
                        this.vx = (Math.random() - 0.5) * 0.5;
                        this.vy = 1 + Math.random() * 2;
                        this.size = 2 + Math.random() * 4;
                        this.life = 8000 + Math.random() * 4000;
                        this.maxLife = 12000;
                        break;
                    case 'jumpDust':
                    case 'landDust':
                        this.vx = (Math.random() - 0.5) * 3;
                        this.vy = -1 - Math.random() * 2;
                        this.color = '#aaaaaa';
                        this.life = 400 + Math.random() * 200;
                        this.maxLife = 600;
                        this.gravity = true;
                        break;
                    case 'hitSpark':
                        this.vx = (Math.random() - 0.5) * 6;
                        this.vy = (Math.random() - 0.5) * 6;
                        this.color = '#ffff00';
                        this.life = 300 + Math.random() * 200;
                        this.maxLife = 500;
                        break;
                    case 'deathExplosion':
                    case 'explosion':
                        this.vx = (Math.random() - 0.5) * 10;
                        this.vy = (Math.random() - 0.5) * 10;
                        this.color = (Math.random() > 0.5 ? COLOR_ACCENT_FIRE : COLOR_ACCENT_GOLD);
                        this.life = 800 + Math.random() * 400;
                        this.maxLife = 1200;
                        this.size = 3 + Math.random() * 5;
                        break;
                    case 'projectileTrail':
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = (Math.random() - 0.5) * 2;
                        this.color = COLOR_UMBRA;
                        this.life = 300 + Math.random() * 200;
                        this.maxLife = 500;
                        this.size = 1 + Math.random() * 2;
                        break;
                    case 'umbraFuria':
                        this.vx = (Math.random() - 0.5) * 5;
                        this.vy = (Math.random() - 0.5) * 5;
                        this.color = COLOR_ACCENT_GOLD;
                        this.life = 500 + Math.random() * 300;
                        this.maxLife = 800;
                        this.size = 3 + Math.random() * 4;
                        this.gravity = false;
                        break;
                    case 'bossIntro':
                        this.vx = (Math.random() - 0.5) * 8;
                        this.vy = (Math.random() - 0.5) * 8;
                        this.color = COLOR_ACCENT_FIRE;
                        this.life = 1000 + Math.random() * 500;
                        this.maxLife = 1500;
                        this.size = 4 + Math.random() * 6;
                        break;
                    case 'dashUmbra':
                        this.vx = (Math.random() - 0.5) * 8;
                        this.vy = (Math.random() - 0.5) * 4;
                        this.color = COLOR_UMBRA;
                        this.life = 400 + Math.random() * 300;
                        this.maxLife = 700;
                        break;
                    case 'prisonActivate':
                        this.vx = (Math.random() - 0.5) * 5;
                        this.vy = (Math.random() - 0.5) * 5;
                        this.color = COLOR_ACCENT_ICE;
                        this.life = 500 + Math.random() * 300;
                        this.maxLife = 800;
                        this.size = 2 + Math.random() * 4;
                        break;
                    case 'xpGain':
                        this.vx = (Math.random() - 0.5) * 3;
                        this.vy = -3 - Math.random() * 2;
                        this.color = COLOR_XP;
                        this.life = 800 + Math.random() * 400;
                        this.maxLife = 1200;
                        this.size = 2 + Math.random() * 3;
                        this.gravity = true;
                        break;
                    default:
                        this.color = '#ffffff';
                        this.life = 500;
                        this.maxLife = 500;
                }
                this.htmlElement.style.display = 'block';
                this.htmlElement.style.backgroundColor = this.color;
                this.htmlElement.style.width = `${this.size}px`;
                this.htmlElement.style.height = `${this.size}px`;
            }

            /**
             * Atualiza a l√≥gica da part√≠cula.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                if (!this.isActive) return;

                this.x += this.vx * (deltaTime / 16);
                this.y += this.vy * (deltaTime / 16);

                if (this.gravity) {
                    this.vy += CONFIG.GRAVITY * 0.3;
                }

                this.life -= deltaTime;

                if (this.life < this.maxLife * 0.3) {
                    this.alpha = this.life / (this.maxLife * 0.3);
                }

                if (this.life <= 0) {
                    this.deactivate(); // Retorna √† pool
                }
            }

            /**
             * Retorna a part√≠cula para a pool.
             */
            deactivate() {
                this.isActive = false;
                this.htmlElement.style.display = 'none'; // Esconder
                ObjectPooler.Instance.returnToPool(this.poolTag, this);
            }

            /**
             * Atualiza a posi√ß√£o e opacidade do elemento DOM da part√≠cula.
             */
            render() {
                if (!this.isActive) return;

                // N√£o renderiza se fora da tela (para part√≠culas de neve que v√£o embora)
                // Os valores aqui ser√£o relativos ao gameWorldElement
                // A posi√ß√£o x,y j√° √© o centro da part√≠cula
                const currentX = this.x - gameWorldElement.offsetLeft;
                const currentY = this.y - gameWorldElement.offsetTop;

                if (currentX < -20 || currentX > gameWorldElement.offsetWidth + 20 || currentY < -20 || currentY > gameWorldElement.offsetHeight + 20) {
                    // Se a part√≠cula sair do viewport, desativ√°-la
                    this.deactivate();
                    return;
                }
                
                this.htmlElement.style.left = `${this.x}px`;
                this.htmlElement.style.top = `${this.y}px`;
                this.htmlElement.style.opacity = `${this.alpha}`;
            }
        }

        /**
         * @class Platform
         * @description Representa uma plataforma no jogo.
         *              Agora cria e gerencia seu pr√≥prio elemento DOM.
         */
        class Platform {
            constructor(x, y, width, height, type = 'ground', slippery = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type; // 'ground', 'platform', 'spike'
                this.slippery = slippery; // Plataforma escorregadia

                this.htmlElement = document.createElement('div');
                this.htmlElement.className = `platform-entity platform-${this.type}`;
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.width = `${this.width}px`;
                this.htmlElement.style.height = `${this.height}px`;
                
                if (this.slippery) {
                    this.htmlElement.classList.add('slippery');
                }
                gameWorldElement.appendChild(this.htmlElement);

                // Para spikes, a renderiza√ß√£o √© mais complexa e pode precisar de um SVG interno ou CSS complexo.
                // Por simplicidade, adicionamos uma classe para o CSS ou um fallback visual.
                if (this.type === 'spike') {
                    this.htmlElement.style.backgroundColor = COLOR_SPIKE; // Fallback visual simples
                    this.htmlElement.style.clipPath = 'polygon(0% 100%, 50% 0%, 100% 100%)'; // Forma de tri√¢ngulo
                }
            }

            render() {
                // Atualiza a posi√ß√£o do elemento HTML
                this.htmlElement.style.left = `${this.x}px`;
                this.htmlElement.style.top = `${this.y}px`;
            }

            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }

        /**
         * @class FallingSpike
         * @description Representa um espinho que cai.
         *              Agora cria e gerencia seu pr√≥prio elemento DOM.
         */
        class FallingSpike {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.active = false;

                this.htmlElement = document.createElement('div');
                this.htmlElement.className = 'game-entity falling-spike-entity';
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.width = `${this.width}px`;
                this.htmlElement.style.height = `${this.height}px`;
                this.htmlElement.style.backgroundColor = COLOR_SPIKE; // Cor padr√£o para visualiza√ß√£o simples
                this.htmlElement.style.clipPath = 'polygon(0% 100%, 50% 0%, 100% 100%)'; // Forma de tri√¢ngulo
                this.htmlElement.style.display = 'none'; // Esconder por padr√£o
                gameWorldElement.appendChild(this.htmlElement);
            }

            update(deltaTime) {
                // Ativa quando o jogador est√° abaixo ou perto
                if (!this.active &&
                    gameState.player.position.x > this.x - 100 &&
                    gameState.player.position.x < this.x + this.width + 100 &&
                    gameState.player.position.y > this.y) {
                    this.active = true;
                    this.htmlElement.style.display = 'block';
                }

                if (this.active) {
                    this.y += this.speed * (deltaTime / 1000);
                }
            }

            render() {
                if (!this.active) return;
                
                this.htmlElement.style.left = `${this.x}px`;
                this.htmlElement.style.top = `${this.y}px`;
            }

            checkCollisionWithPlayer() {
                if (!this.active || gameState.player.health.isInvincible) return false;

                const playerRect = {
                    x: gameState.player.position.x,
                    y: gameState.player.position.y,
                    width: CONFIG.PLAYER_WIDTH,
                    height: gameState.player.physics.height
                };
                const spikeRect = {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };

                if (gameState.player.physics._checkCollision(playerRect.x, playerRect.y, playerRect.width, playerRect.height, spikeRect)) {
                    gameState.player.health.takeDamage(15);
                    EventManager.emit('add_particles', { type: 'hitSpark', x: spikeRect.x + spikeRect.width/2, y: spikeRect.y + spikeRect.height/2, count: 10 });
                    return true;
                }
                return false;
            }

            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }

        /**
         * @class Checkpoint
         * @description Representa um ponto de salvamento.
         *              Cria e gerencia seu pr√≥prio elemento DOM invis√≠vel para detec√ß√£o de colis√£o.
         */
        class Checkpoint {
            constructor(x, y, width, height, name, description) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.name = name;
                this.description = description;
                this.triggered = false; // Para n√£o salvar m√∫ltiplas vezes

                this.htmlElement = document.createElement('div');
                this.htmlElement.className = 'checkpoint-entity';
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.width = `${this.width}px`;
                this.htmlElement.style.height = `${this.height}px`;
                this.htmlElement.style.left = `${this.x}px`;
                this.htmlElement.style.top = `${this.y}px`;
                this.htmlElement.style.backgroundColor = 'rgba(0, 255, 0, 0.2)'; // Para debug visual
                this.htmlElement.style.display = 'none'; // Esconder no jogo final
                gameWorldElement.appendChild(this.htmlElement);
            }

            checkCollisionWithPlayer() {
                if (this.triggered) return; // J√° foi ativado
                
                const playerRect = {
                    x: gameState.player.position.x,
                    y: gameState.player.position.y,
                    width: CONFIG.PLAYER_WIDTH,
                    height: CONFIG.PLAYER_HEIGHT // Usar altura total do jogador para colis√£o com checkpoint
                };
                const cpRect = {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };

                if (gameState.player.physics._checkCollision(playerRect.x, playerRect.y, playerRect.width, playerRect.height, cpRect)) {
                    GameManager.saveCheckpoint(this.name, this.description);
                    this.triggered = true;
                    this.htmlElement.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // Mudar cor ap√≥s trigger
                }
            }

            render() {
                // Nada a renderizar ativamente, apenas o elemento DOM √© para detec√ß√£o de colis√£o
                // Mas podemos usar para debug
                if (window.DEBUG_MODE) {
                    this.htmlElement.style.display = 'block';
                }
            }

            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }


        // =================================================================================================
        // ===== 6. OBJECT POOLER (Object Pooling Pattern) =================================================
        // =================================================================================================

        /**
         * @class ObjectPooler
         * @description Gerencia pools de objetos reutiliz√°veis para otimiza√ß√£o de performance.
         */
        class ObjectPooler {
            constructor() {
                if (ObjectPooler.Instance) {
                    return ObjectPooler.Instance;
                }
                ObjectPooler.Instance = this;

                this.pools = {
                    // Pool para proj√©teis do jogador
                    darkShotProjectile: [], 
                    etherealOrbProjectile: [], 
                    
                    // Pool para proj√©teis inimigos
                    enemyIceShot: [], 
                    bossSlash: [], 
                    bossIceOrb: [], 
                    bossPrison: [], 
                    bossDash: [], 

                    // Pool para part√≠culas
                    snowParticle: [],
                    jumpDustParticle: [],
                    landDustParticle: [],
                    hitSparkParticle: [],
                    deathExplosionParticle: [],
                    projectileTrailParticle: [],
                    umbraFuriaParticle: [],
                    bossIntroParticle: [],
                    dashIceParticle: [],
                    prisonActivateParticle: [],
                    xpGainParticle: []
                };

                // Configura√ß√µes de tamanho inicial das pools (ajustar conforme necessidade)
                this.poolSizes = {
                    darkShotProjectile: 5,
                    etherealOrbProjectile: 3,
                    enemyIceShot: 10,
                    bossSlash: 2,
                    bossIceOrb: 5,
                    bossPrison: 3,
                    bossDash: 1, 
                    
                    snowParticle: 300,
                    jumpDustParticle: 30,
                    landDustParticle: 30,
                    hitSparkParticle: 50,
                    deathExplosionParticle: 10,
                    projectileTrailParticle: 100,
                    umbraFuriaParticle: 20,
                    bossIntroParticle: 20,
                    dashIceParticle: 30,
                    prisonActivateParticle: 10,
                    xpGainParticle: 20
                };
            }

            /**
             * Inicializa todas as pools com o n√∫mero pr√©-definido de objetos.
             */
            initializePools() {
                for (const tag in this.poolSizes) {
                    const size = this.poolSizes[tag];
                    for (let i = 0; i < size; i++) {
                        if (tag.includes('Projectile')) {
                            this.pools[tag].push(new Projectile(tag));
                        } else if (tag.includes('Particle')) {
                            this.pools[tag].push(new Particle(tag));
                        }
                    }
                }
            }

            /**
             * Pega um objeto da pool. Se a pool estiver vazia, cria um novo (opcionalmente).
             * @param {string} tag - A tag da pool.
             * @param {object} config - Configura√ß√µes para inicializar o objeto.
             * @returns {object} - O objeto pronto para uso.
             */
            getFromPool(tag, config) {
                if (!this.pools[tag]) {
                    console.warn(`Pool com tag '${tag}' n√£o existe.`);
                    return null;
                }

                let obj = this.pools[tag].find(o => !o.isActive); // Encontra um objeto inativo
                
                if (!obj) {
                    // Se n√£o houver objetos inativos, cria um novo (expans√£o din√¢mica da pool)
                    if (tag.includes('Projectile')) {
                        obj = new Projectile(tag);
                    } else if (tag.includes('Particle')) {
                        obj = new Particle(tag);
                    }
                    this.pools[tag].push(obj);
                    // console.warn(`Pool '${tag}' expandida dinamicamente. Considere aumentar o tamanho inicial.`);
                }
                
                obj.initialize(config); // Re-inicializa o objeto
                return obj;
            }

            /**
             * Retorna um objeto para a pool, marcando-o como inativo.
             * @param {string} tag - A tag da pool.
             * @param {object} obj - O objeto a ser retornado.
             */
            returnToPool(tag, obj) {
                if (this.pools[tag] && this.pools[tag].includes(obj)) {
                    obj.isActive = false;
                    obj.htmlElement.style.display = 'none'; // Garante que o elemento DOM est√° escondido
                } else {
                    console.warn(`Tentou retornar objeto para pool '${tag}' que n√£o pertence ou n√£o existe.`);
                }
            }

            /**
             * Retorna todos os objetos ativos para suas respectivas pools.
             */
            returnAllActiveToPools() {
                for (const tag in this.pools) {
                    this.pools[tag].forEach(obj => {
                        if (obj.isActive) {
                            obj.deactivate(); // Chama o m√©todo deactivate do pr√≥prio objeto
                        }
                    });
                }
            }

            /**
             * Obt√©m uma lista de todos os objetos ativos de uma pool espec√≠fica.
             * @param {string} tag - A tag da pool.
             * @returns {Array} - Lista de objetos ativos.
             */
            getActiveObjects(tag) {
                return this.pools[tag] ? this.pools[tag].filter(obj => obj.isActive) : [];
            }
        }


        // =================================================================================================
        // ===== 7. CLASSES DE HABILIDADES (PlayerAbility) =================================================
        // =================================================================================================

        /**
         * @class PlayerAbility
         * @description Classe base abstrata para todas as habilidades do jogador.
         */
        class PlayerAbility {
            constructor(player, abilityData) {
                this.player = player;
                this.name = abilityData.name;
                this.description = abilityData.description;
                this.manaCost = abilityData.manaCost;
                this.cooldown = abilityData.cooldown * 1000; // Converte segundos para ms
                this.currentCooldown = 0; // Cooldown restante (em ms)
                this.damageModifier = abilityData.damageModifier || 1; // Modificador de dano se aplic√°vel
                this.animationKey = abilityData.animationKey; // Anima√ß√£o a ser tocada
                this.key = abilityData.key; // Tecla associada

                // Event Listeners para feedback visual
                EventManager.subscribe('player_mana_changed', (data) => {
                    // Atualiza a UI da habilidade se mana afetar
                });
            }

            /**
             * Tenta ativar a habilidade.
             * @returns {boolean} - True se a mana foi usada com sucesso e a habilidade ativada, false caso contr√°rio.
             */
            activate() {
                if (this.currentCooldown <= 0 && this.player.mana.useMana(this.manaCost)) {
                    this._execute();
                    this.currentCooldown = this.cooldown;
                    EventManager.emit('ability_used', { key: this.key, cooldown: this.cooldown });
                    return true;
                }
                return false;
            }

            /**
             * L√≥gica de execu√ß√£o espec√≠fica da habilidade (deve ser implementada pelas subclasses).
             * @protected
             */
            _execute() {
                throw new Error("M√©todo _execute() deve ser implementado pela subclasse.");
            }

            /**
             * Atualiza o cooldown da habilidade.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            updateCooldown(deltaTime) {
                if (this.currentCooldown > 0) {
                    this.currentCooldown -= deltaTime;
                    if (this.currentCooldown < 0) {
                        this.currentCooldown = 0;
                    }
                    EventManager.emit('ability_cooldown_update', { key: this.key, current: this.currentCooldown, max: this.cooldown });
                }
            }
        }

        /**
         * @class DarkShotAbility
         * @description Habilidade: Tiro Sombrio (U).
         */
        class DarkShotAbility extends PlayerAbility {
            constructor(player, abilityData) {
                super(player, abilityData);
                this.name = "Tiro Sombrio";
                this.description = "Dispara um proj√©til de energia sombria √† dist√¢ncia.";
                this.manaCost = 0;
                this.cooldown = 0.6 * 1000;
                this.animationKey = 'attack_u';
            }

            _execute() {
                EventManager.emit('sfx_play', 'sfx_attack_u');
                // Transiciona o jogador para o estado de habilidade de ataque
                this.player.transitionToState(new PlayerAbilityState(this.player, this.animationKey));

                // Calcula a posi√ß√£o de spawn do proj√©til baseada na dire√ß√£o do jogador
                const spawnX = this.player.position.x + (this.player.facing === 'right' ? CONFIG.PLAYER_WIDTH : -25);
                const spawnY = this.player.position.y + CONFIG.PLAYER_HEIGHT / 2 - 4; // Ajusta a altura

                EventManager.emit('spawn_projectile', {
                    type: 'darkShotProjectile',
                    x: spawnX,
                    y: spawnY,
                    width: 25,
                    height: 8,
                    duration: 1500,
                    damage: this.player.damage * this.damageModifier,
                    direction: this.player.facing === 'right' ? 1 : -1,
                    speed: 8,
                    origin: 'player',
                    piercing: false
                });
            }
        }

        /**
         * @class AgileShadowAbility
         * @description Habilidade: Sombra √Ågil (I).
         */
        class AgileShadowAbility extends PlayerAbility {
            constructor(player, abilityData) {
                super(player, abilityData);
                this.name = "Sombra √Ågil";
                this.description = "Deslocamento r√°pido que atravessa inimigos e concede invulnerabilidade tempor√°ria.";
                this.manaCost = 25;
                this.cooldown = 5 * 1000;
                this.animationKey = 'attack_i';
            }

            _execute() {
                EventManager.emit('sfx_play', 'sfx_ability_i');
                this.player.transitionToState(new PlayerAbilityState(this.player, this.animationKey));

                const dashForce = 12; // Velocidade do dash
                const invincibilityDuration = 300; // Dura√ß√£o da invencibilidade durante o dash

                // Aplica a for√ßa do dash
                this.player.physics.applyKnockback(
                    (this.player.facing === 'right' ? dashForce : -dashForce),
                    0 // N√£o altera a velocidade vertical
                );

                // Concede invencibilidade
                this.player.health.isInvincible = true;
                this.player.health.invincibilityTimer = invincibilityDuration;

                // Efeito de part√≠culas
                EventManager.emit('add_particles', { type: 'dashUmbra', x: this.player.position.x + CONFIG.PLAYER_WIDTH / 2, y: this.player.position.y + CONFIG.PLAYER_HEIGHT / 2, count: 20 });
            }
        }

        /**
         * @class EtherealOrbAbility
         * @description Habilidade: Orbe Et√©reo (O).
         */
        class EtherealOrbAbility extends PlayerAbility {
            constructor(player, abilityData) {
                super(player, abilityData);
                this.name = "Orbe Et√©reo";
                this.description = "Lan√ßa um orbe de energia sombria que perfura m√∫ltiplos inimigos.";
                this.manaCost = 35;
                this.cooldown = 4 * 1000;
                this.animationKey = 'attack_o';
            }

            _execute() {
                EventManager.emit('sfx_play', 'sfx_ability_o');
                this.player.transitionToState(new PlayerAbilityState(this.player, this.animationKey));

                const spawnX = this.player.position.x + (this.player.facing === 'right' ? CONFIG.PLAYER_WIDTH : -35);
                const spawnY = this.player.position.y + CONFIG.PLAYER_HEIGHT / 2 - 10;

                EventManager.emit('spawn_projectile', {
                    type: 'etherealOrbProjectile',
                    x: spawnX,
                    y: spawnY,
                    width: 35,
                    height: 35,
                    duration: 3000,
                    damage: this.player.damage * this.damageModifier * 1.8,
                    direction: this.player.facing === 'right' ? 1 : -1,
                    speed: 6,
                    origin: 'player',
                    piercing: true
                });
            }
        }

        /**
         * @class UmbraFuryAbility
         * @description Habilidade: F√∫ria de Umbra (P).
         */
        class UmbraFuryAbility extends PlayerAbility {
            constructor(player, abilityData) {
                super(player, abilityData);
                this.name = "F√∫ria de Umbra";
                this.description = "Canaliza a energia de Umbra para amplificar poder.";
                this.manaCost = 50;
                this.cooldown = 8 * 1000;
                this.animationKey = 'ultimate';
                this.isActive = false;
                this.duration = CONFIG.UMBRA_FURY_DURATION;
                this.currentDuration = 0;
            }

            _execute() {
                EventManager.emit('sfx_play', 'sfx_ability_p');
                this.player.transitionToState(new PlayerAbilityState(this.player, this.animationKey));

                this.isActive = true;
                this.currentDuration = this.duration;

                // Aplica buffs
                this.player.damage *= CONFIG.UMBRA_FURY_DAMAGE_BOOST;
                this.player.currentSpeed *= CONFIG.UMBRA_FURY_SPEED_BOOST;
                EventManager.emit('add_particles', { type: 'umbraFuria', x: this.player.position.x + CONFIG.PLAYER_WIDTH / 2, y: this.player.position.y + CONFIG.PLAYER_HEIGHT / 2, count: 30 });
            }

            updateCooldown(deltaTime) {
                super.updateCooldown(deltaTime); // Chama o update de cooldown da classe base

                if (this.isActive) {
                    this.currentDuration -= deltaTime;
                    if (this.currentDuration <= 0) {
                        this.deactivate();
                    }
                }
            }

            deactivate() {
                if (this.isActive) {
                    this.isActive = false;
                    // Remove buffs
                    this.player.damage /= CONFIG.UMBRA_FURY_DAMAGE_BOOST;
                    this.player.currentSpeed /= CONFIG.UMBRA_FURY_SPEED_BOOST;
                    // Se a anima√ß√£o de ultimate ainda estiver tocando, for√ßa transi√ß√£o para idle
                    if (this.player.currentState instanceof PlayerAbilityState && this.player.currentState.animationKey === this.animationKey) {
                        this.player.transitionToState(new PlayerIdleState(this.player));
                    }
                    EventManager.emit('umbra_fury_ended');
                }
            }
        }

        /**
         * @class PlayerAbilityFactory
         * @description F√°brica para criar inst√¢ncias de habilidades.
         */
        class PlayerAbilityFactory {
            static createAbility(abilityName) {
                switch (abilityName) {
                    case "Tiro Sombrio": return DarkShotAbility;
                    case "Sombra √Ågil": return AgileShadowAbility;
                    case "Orbe Et√©reo": return EtherealOrbAbility;
                    case "F√∫ria de Umbra": return UmbraFuryAbility;
                    default: return null;
                }
            }
        }


        // =================================================================================================
        // ===== 8. GERENCIADORES GLOBAIS (Singleton) ======================================================
        // =================================================================================================

        /**
         * @class GameManager
         * @description Gerencia o estado geral do jogo, fases, save/load, pausas e cutscenes.
         */
        class GameManager {
            constructor() {
                if (GameManager.Instance) {
                    return GameManager.Instance;
                }
                GameManager.Instance = this;

                this.gameSettings = {
                    volume: 0.7, sfxVolume: 0.8, musicVolume: 0.6,
                    showFPS: false, particleQuality: 'high', screenShake: true
                };
                this._loadSettings();

                // Listeners de eventos de jogo
                EventManager.subscribe('entity_died', (entity) => {
                    if (entity.isPlayer) {
                        this.gameOver();
                    }
                });
                EventManager.subscribe('enemy_defeated', (enemy) => {
                    if (enemy.type === 'boss') {
                        this.defeatBoss(enemy);
                    } else {
                        gameState.player.gainXP(enemy.xpValue);
                    }
                });
                EventManager.subscribe('level_up', (data) => {
                    this.togglePause(true); // Pausa o jogo para o menu de level up
                });
                EventManager.subscribe('ui_level_up_applied', () => {
                    this.togglePause(false); // Despausa ap√≥s aplicar upgrade
                });
                EventManager.subscribe('game_state_change', (stateName) => {
                    console.log(`Game State Changed to: ${stateName}`);
                });

                EventManager.emit('game_state_change', 'INITIALIZED');
            }

            /**
             * Inicia um novo jogo.
             * @param {string} playerName - Nome do jogador.
             */
            startGame(playerName) {
                gameState.playerName = playerName;
                gameState.inMenu = false;
                gameState.gameStarted = true;
                UIManager.Instance.hideMainMenu(); // CORRE√á√ÉO: UIManager.Instance.hideMainMenu()
                
                // Configura o jogador (com dados iniciais ou carregados)
                const defaultPlayerConfig = {
                    baseHealth: 100, baseMana: 100, baseSpeed: CONFIG.PLAYER_BASE_SPEED,
                    baseDamage: 15, manaRegenRate: CONFIG.MANA_REGEN_RATE,
                    abilities: [
                        { key: 'U', name: 'Tiro Sombrio', manaCost: 0, cooldown: 0.6, damageModifier: 1.2, animationKey: 'attack_u' },
                        { key: 'I', name: 'Sombra √Ågil', manaCost: 25, cooldown: 5, animationKey: 'attack_i' },
                        { key: 'O', name: 'Orbe Et√©reo', manaCost: 35, cooldown: 4, damageModifier: 1.8, animationKey: 'attack_o' },
                        { key: 'P', name: 'F√∫ria de Umbra', manaCost: 50, cooldown: 8, animationKey: 'ultimate' }
                    ]
                };
                gameState.player = new Player(playerName, defaultPlayerConfig);
                
                // Carrega progresso salvo se existir, mas sempre come√ßa do n√≠vel 1 por padr√£o no Ben 10-ish.
                const savedData = this._loadProgress();
                if (savedData) {
                    this._applySavedData(savedData);
                } else {
                    UIManager.Instance.updatePlayerStats(gameState.player.level, gameState.player.damage); // CORRE√á√ÉO: UIManager.Instance
                    UIManager.Instance.updateHealth({ current: gameState.player.health.currentHealth, max: gameState.player.health.maxHealth }); // CORRE√á√ÉO: UIManager.Instance
                    UIManager.Instance.updateMana({ current: gameState.player.mana.currentMana, max: gameState.player.mana.maxMana }); // CORRE√á√ÉO: UIManager.Instance
                    UIManager.Instance.updateXP({ current: gameState.player.xp, max: gameState.player.nextLevelXP }); // CORRE√á√ÉO: UIManager.Instance
                }

                AudioManager.Instance.stopMusic(); // CORRE√á√ÉO: AudioManager.Instance
                this.showIntroCutscene();

                EventManager.emit('game_state_change', 'STARTED');
            }

            /**
             * Carrega uma fase do jogo.
             * @param {number} phaseNumber - O n√∫mero da fase.
             * @param {string} checkpointName - Nome do checkpoint para posicionamento (opcional).
             */
            loadPhase(phaseNumber, checkpointName = null) {
                gameState.currentPhase = phaseNumber;
                
                // Limpa todas as entidades e efeitos anteriores do DOM
                if (gameState.player) gameState.player.destroy(); // Remove player do DOM antes de limpar
                enemies.forEach(enemy => enemy.destroy());
                platforms.forEach(platform => platform.destroy());
                fallingSpikes.forEach(spike => spike.destroy());
                checkpoints.forEach(cp => cp.destroy());
                
                enemies = [];
                platforms = [];
                fallingSpikes = [];
                checkpoints = [];

                ObjectPooler.Instance.returnAllActiveToPools(); // Retorna todos os objetos das pools
                
                // Recria o jogador se ele foi destru√≠do (ao reiniciar uma fase)
                if (!gameState.player) {
                    const savedData = this._loadProgress();
                    if (savedData) {
                        gameState.player = new Player(savedData.playerName, {
                            baseHealth: savedData.playerMaxHealth, baseMana: savedData.playerMaxMana, baseSpeed: savedData.playerSpeed,
                            baseDamage: savedData.playerDamage, manaRegenRate: CONFIG.MANA_REGEN_RATE,
                            abilities: [
                                { key: 'U', name: 'Tiro Sombrio', manaCost: 0, cooldown: 0.6, damageModifier: 1.2, animationKey: 'attack_u' },
                                { key: 'I', name: 'Sombra √Ågil', manaCost: 25, cooldown: 5, animationKey: 'attack_i' },
                                { key: 'O', name: 'Orbe Et√©reo', manaCost: 35, cooldown: 4, damageModifier: 1.8, animationKey: 'attack_o' },
                                { key: 'P', name: 'F√∫ria de Umbra', manaCost: 50, cooldown: 8, animationKey: 'ultimate' }
                            ]
                        });
                        this._applySavedData(savedData); // Reaplica dados salvos
                    }
                }

                // Reseta a posi√ß√£o do jogador para o in√≠cio da fase ou checkpoint
                if (checkpointName) {
                    const cp = Checkpoint.findByName(checkpoints, checkpointName); 
                    if (cp) {
                        gameState.player.position.x = cp.x;
                        gameState.player.position.y = cp.y;
                    }
                } else {
                    gameState.player.position.x = 100;
                    gameState.player.position.y = 300;
                }
                gameState.player.physics.velocity = { x: 0, y: 0 };
                gameState.player.health.heal(gameState.player.health.maxHealth); // Cura total
                gameState.player.mana.currentMana = gameState.player.mana.maxMana; // Mana total
                
                // Define a fase
                switch(phaseNumber) {
                    case 1:
                        this._setupPhase1_MuralhasAurora();
                        AudioManager.Instance.playMusic('music_platforming', true);
                        UIManager.Instance.hideBossBars();
                        break;
                    case 2:
                        this._setupPhase1_TarekEncounter();
                        break;
                    case 3:
                        this._setupPhase1_TarekBossFight();
                        AudioManager.Instance.playMusic('music_boss_tarek', true);
                        break;
                    default:
                        this._setupPhase1_MuralhasAurora();
                        AudioManager.Instance.playMusic('music_platforming', true);
                        UIManager.Instance.hideBossBars();
                }
                
                // Reinicia a c√¢mera (a posi√ß√£o inicial j√° foi definida)
                gameState.cameraOffset = { x: gameState.player.position.x - gameWorldElement.offsetWidth / 2, y: gameState.player.position.y - gameWorldElement.offsetHeight / 2 };
                gameState.targetCameraOffset = { x: gameState.player.position.x - gameWorldElement.offsetWidth / 2, y: gameState.player.position.y - gameWorldElement.offsetHeight / 2 };
                
                EventManager.emit('game_state_change', `PHASE_${phaseNumber}_LOADED`);
            }

            _setupPhase1_MuralhasAurora() {
                platforms = [
                    new Platform(0, 400, 6000, 50, 'ground'),
                    new Platform(200, 350, 80, 20, 'platform'),
                    new Platform(350, 300, 80, 20, 'platform', true), // Escorregadia
                    new Platform(500, 250, 100, 20, 'platform'),
                    new Platform(700, 320, 120, 20, 'platform'),
                    new Platform(900, 380, 50, 20, 'platform'),
                    
                    new Platform(1100, 400, 150, 50, 'ground'),
                    new Platform(1100, 350, 150, 50, 'spike'),
                    new Platform(1300, 400, 100, 50, 'ground'),
                    new Platform(1500, 300, 80, 20, 'platform'),
                    new Platform(1700, 250, 100, 20, 'platform'),
                    new Platform(2000, 350, 120, 20, 'platform'),
                    new Platform(2300, 400, 200, 50, 'ground'),
                    new Platform(2300, 350, 200, 50, 'spike'),
                    new Platform(2600, 300, 80, 20, 'platform'),
                    new Platform(2800, 250, 100, 20, 'platform'),
                    new Platform(3100, 400, 150, 50, 'ground'),
                    new Platform(3400, 350, 80, 20, 'platform'),
                    new Platform(3600, 300, 100, 20, 'platform'),
                    new Platform(3900, 400, 200, 50, 'ground'),
                    new Platform(4200, 350, 80, 20, 'platform'),
                    new Platform(4400, 300, 100, 20, 'platform'),
                    new Platform(4700, 250, 120, 20, 'platform'),
                    new Platform(5000, 400, 1000, 50, 'ground'),
                ];

                fallingSpikes = [
                    new FallingSpike(800, -50, 30, 30, 150),
                    new FallingSpike(1200, -50, 30, 30, 150),
                    new FallingSpike(1800, -50, 30, 30, 150),
                    new FallingSpike(2400, -50, 30, 30, 150),
                    new FallingSpike(3000, -50, 30, 30, 150),
                    new FallingSpike(3800, -50, 30, 30, 150),
                    new FallingSpike(4500, -50, 30, 30, 150),
                ];

                enemies = [
                    new Enemy('sentinel', 600, 300, { health: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 10 }),
                    new Enemy('sentinel', 1600, 250, { health: 50, damage: 10, speed: 1, patrolRange: 120, xpValue: 10 }),
                    new Enemy('sentinel', 2700, 250, { health: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 10 }),
                    new Enemy('sentinel', 3700, 300, { health: 50, damage: 10, speed: 1, patrolRange: 150, xpValue: 10 }),
                    new Enemy('sentinel', 4600, 250, { health: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 10 })
                ];

                checkpoints = [
                    new Checkpoint(1000, 350, 50, 50, 'checkpoint1', 'Primeiro Checkpoint'),
                    new Checkpoint(2500, 350, 50, 50, 'checkpoint2', 'Segundo Checkpoint'),
                    new Checkpoint(4000, 350, 50, 50, 'checkpoint3', 'Terceiro Checkpoint'),
                ];
                
                CONFIG.WORLD_WIDTH = 6000;
                
                gameState.inTarekEncounter = false;
                gameState.tarekDialogStep = 0;
                gameState.fixedCamera = false;
            }

            _setupPhase1_TarekEncounter() {
                platforms = [ new Platform(0, 400, gameWorldElement.offsetWidth, 50, 'ground') ]; // Usar gameWorldElement.offsetWidth
                enemies = [];
                checkpoints = [];
                
                // Configura fundo para encontro (imagem est√°tica)
                this._setBackgroundImage('tarek_background');

                gameState.fixedCamera = true;
                gameState.fixedCameraTarget = { x: 0, y: 0 };
                gameState.player.position.x = 150;
                gameState.player.position.y = 300;
                gameState.player.physics.velocity = { x: 0, y: 0 };

                // Inimigo de di√°logo (n√£o √© um inimigo combatente)
                enemies.push(new Enemy('boss_dialogue', 600, 300, { health: 1, damage: 0, speed: 0 }));
                enemies[0].animation.play('idle'); // Usa a anima√ß√£o do boss
                
                UIManager.Instance.hideBossBars(); // CORRE√á√ÉO: UIManager.Instance
                gameState.inTarekEncounter = true;

                this._startTarekDialogue();
            }

            _setupPhase1_TarekBossFight() {
                platforms = [ new Platform(0, 400, gameWorldElement.offsetWidth, 50, 'ground') ];
                enemies = [];
                checkpoints = [];
                
                this._setBackgroundImage('tarek_background');

                gameState.fixedCamera = true;
                gameState.fixedCameraTarget = { x: 0, y: 0 };
                gameState.player.position.x = 150;
                gameState.player.position.y = 300;
                
                gameState.player.health.heal(gameState.player.health.maxHealth);
                gameState.player.mana.currentMana = gameState.player.mana.maxMana;

                this.triggerBossFight();
            }

            _setBackgroundImage(assetKey) {
                // Define uma flag ou vari√°vel no GameManager para o renderizador de fundo usar
                GameManager.backgroundImageKey = assetKey;
                const imgAsset = CONFIG.ASSET_LOADED[assetKey];
                if (imgAsset && imgAsset.src) { // Garante que a imagem foi carregada
                     gameWorldElement.style.backgroundImage = `url('${imgAsset.src}')`;
                     gameWorldElement.style.backgroundSize = 'cover';
                     gameWorldElement.style.backgroundPosition = 'center';
                } else {
                    console.warn(`Background asset not loaded or invalid: ${assetKey}`);
                    gameWorldElement.style.backgroundImage = 'none'; // Fallback
                }
            }

            /**
             * Inicia a sequ√™ncia de di√°logo com Tarek.
             * @private
             */
            _startTarekDialogue() {
                gameState.tarekDialogStep = 0;
                const tarekDialogs = [
                    { speaker: "TAREK", text: `Ent√£o voc√™ √© ${gameState.playerName}, o tal Escolhido?` },
                    { speaker: "TAREK", text: "Estas muralhas n√£o s√£o lugar para forasteiros fracos." },
                    { speaker: "TAREK", text: "Prove que merece passar por aqui, ou volte de onde veio!" }
                ];

                const showNextTarekLine = () => {
                    if (gameState.tarekDialogStep < tarekDialogs.length) {
                        const line = tarekDialogs[gameState.tarekDialogStep];
                        this.showDialog(line.speaker, line.text, [{ text: "Continuar", action: () => {
                            gameState.tarekDialogStep++;
                            showNextTarekLine();
                        }}]);
                    } else {
                        gameState.tarekDialogCompleted = true;
                        gameState.inTarekEncounter = false;
                        this.loadPhase(3); // Inicia a fase da batalha com Tarek
                    }
                };
                showNextTarekLine();
            }

            /**
             * Inicia a luta contra o boss.
             */
            triggerBossFight() {
                gameState.inBossFight = true;
                gameState.fixedCamera = true;
                
                AudioManager.Instance.playSFX('sfx_boss_roar'); // CORRE√á√ÉO: AudioManager.Instance

                const tarek = new BossTarek(gameWorldElement.offsetWidth - 150, 300, { // Use gameWorldElement.offsetWidth
                    health: 500, damage: 25, speed: 1.5, xpValue: 250
                });
                enemies.push(tarek);
                
                UIManager.Instance.showBossBars(tarek.name, tarek.health.currentHealth, tarek.health.maxHealth); // CORRE√á√ÉO: UIManager.Instance
                
                this.saveCheckpoint('tarek_fight_start');
                
                EventManager.emit('screen_shake', { intensity: 8, duration: 500 });
                EventManager.emit('screen_flash', { color: COLOR_ACCENT_FIRE, duration: 300 });
                EventManager.emit('add_particles', { type: 'bossIntro', x: tarek.position.x + 35, y: tarek.position.y + 35, count: 40 });

                EventManager.emit('game_state_change', 'BOSS_FIGHT_STARTED');
            }

            /**
             * L√≥gica quando o boss √© derrotado.
             * @param {Enemy} boss - O objeto boss.
             */
            defeatBoss(boss) {
                gameState.bossDefeated = true;
                gameState.inBossFight = false;
                
                AudioManager.Instance.stopMusic(); // CORRE√á√ÉO: AudioManager.Instance
                UIManager.Instance.hideBossBars(); // CORRE√á√ÉO: UIManager.Instance
                
                EventManager.emit('screen_flash', { color: COLOR_ACCENT_GOLD, duration: 800 });
                EventManager.emit('screen_shake', { intensity: 10, duration: 1000 });
                EventManager.emit('add_particles', { type: 'victoryExplosion', x: boss.position.x + 35, y: boss.position.y + 35, count: 60 });
                
                gameState.player.gainXP(boss.xpValue); // Garante que o jogador receba XP do boss

                // Remove o boss da lista de inimigos (se ainda estiver l√°)
                enemies = enemies.filter(e => e !== boss);
                boss.destroy(); // Remove o elemento DOM do boss

                setTimeout(() => {
                    this.showDialog(
                        "TAREK",
                        `Impressionante, ${gameState.playerName}... Voc√™ realmente tem a for√ßa de um Escolhido. Pode passar, mas saiba que desafios ainda maiores o aguardam adiante.`,
                        [
                            {
                                text: "Obrigado pela luta honrosa, Tarek.",
                                action: () => {
                                    this.showDialog(
                                        "TAREK",
                                        "Que os ventos gelados guiem seus passos, Escolhido. E que voc√™ encontre o que procura antes que seja tarde demais.",
                                        [
                                            {
                                                text: "Fim da Primeira Jornada",
                                                action: () => {
                                                    this.saveCheckpoint('boss_defeated');
                                                    this.showDialog(
                                                        "NARRA√á√ÉO",
                                                        "Com Tarek derrotado, o caminho para o interior de Tup√£ry est√° aberto. Mas esta √© apenas a primeira de muitas prova√ß√µes que aguardam o Escolhido...",
                                                        [
                                                            {
                                                                text: "Fim da Demo (Avance para a Miss√£o 2 em breve)",
                                                                action: () => UIManager.Instance.showVictoryScreen(gameState.playerName, gameState.player.level, gameState.player.xp) // CORRE√á√ÉO: UIManager.Instance
                                                            }
                                                        ]
                                                    );
                                                }
                                            }
                                        ]
                                    );
                                }
                            }
                        ]
                    );
                }, 2000);

                EventManager.emit('game_state_change', 'BOSS_DEFEATED');
            }

            /**
             * Pausa ou despausa o jogo.
             * @param {boolean} forceState - Opcional, for√ßa o estado (true para pausar, false para despausar).
             */
            togglePause(forceState = null) {
                if (gameState.inMenu || gameState.inCutscene || gameState.inDialog) return;
                
                gameState.gamePaused = forceState !== null ? forceState : !gameState.gamePaused;
                
                if (gameState.gamePaused) {
                    UIManager.Instance.showPauseMenu(); // CORRE√á√ÉO: UIManager.Instance
                    AudioManager.Instance.stopMusic(); // CORRE√á√ÉO: AudioManager.Instance
                } else {
                    UIManager.Instance.hidePauseMenu(); // CORRE√á√ÉO: UIManager.Instance
                    if (gameState.inBossFight) {
                        AudioManager.Instance.playMusic('music_boss_tarek', true); // CORRE√á√ÉO: AudioManager.Instance
                    } else {
                        AudioManager.Instance.playMusic('music_platforming', true); // CORRE√á√ÉO: AudioManager.Instance
                    }
                }
                EventManager.emit('game_state_change', gameState.gamePaused ? 'PAUSED' : 'RESUMED');
            }

            /**
             * L√≥gica de Game Over.
             */
            gameOver() {
                this.togglePause(true); // Garante que o jogo esteja pausado
                AudioManager.Instance.stopMusic(); // CORRE√á√ÉO: AudioManager.Instance
                
                EventManager.emit('screen_flash', { color: 'rgba(0, 0, 0, 0.8)', duration: 1000 });
                
                setTimeout(() => {
                    UIManager.Instance.hideAllOverlays(); // CORRE√á√ÉO: UIManager.Instance
                    this.showDialog(
                        "SISTEMA",
                        `${gameState.playerName} foi derrotado... Mas a jornada n√£o termina aqui. O destino de todos os reinos ainda depende de suas escolhas.`,
                        [
                            {
                                text: "Voltar ao √∫ltimo checkpoint",
                                action: () => {
                                    this.restartFromCheckpoint();
                                }
                            },
                            {
                                text: "Reiniciar fase atual",
                                action: () => {
                                    this.loadPhase(gameState.currentPhase);
                                    this.togglePause(false);
                                }
                            },
                            {
                                text: "Voltar ao menu principal",
                                action: () => {
                                    this.exitToMenu();
                                }
                            }
                        ]
                    );
                }, 1500);
                EventManager.emit('game_state_change', 'GAME_OVER');
            }

            /**
             * Exibe uma tela de vit√≥ria.
             */
            showVictoryScreen(playerName, level, xp) {
                UIManager.Instance.showVictoryScreen(playerName, level, xp); // CORRE√á√ÉO: UIManager.Instance
                EventManager.emit('game_state_change', 'VICTORY');
            }

            /**
             * Exibe uma caixa de di√°logo.
             * @param {string} speaker - Quem est√° falando.
             * @param {string} text - O texto do di√°logo.
             * @param {Array<object>} options - Op√ß√µes de resposta (cada uma com text e action).
             */
            showDialog(speaker, text, options = null) {
                gameState.inDialog = true;
                this.togglePause(true); // Pausa o jogo quando o di√°logo est√° ativo
                UIManager.Instance.showDialog(speaker, text, options); // CORRE√á√ÉO: UIManager.Instance
                EventManager.emit('game_state_change', 'IN_DIALOG');
            }

            /**
             * Esconde a caixa de di√°logo.
             */
            hideDialog() {
                gameState.inDialog = false;
                this.togglePause(false); // Despausa o jogo ao sair do di√°logo
                UIManager.Instance.hideDialog(); // CORRE√á√ÉO: UIManager.Instance
                EventManager.emit('game_state_change', 'OUT_OF_DIALOG');
            }

            /**
             * Exibe a cutscene inicial.
             */
            showIntroCutscene() {
                gameState.inCutscene = true;
                UIManager.Instance.showCutscene(); // CORRE√á√ÉO: UIManager.Instance
                AudioManager.Instance.playMusic('music_menu', true); // CORRE√á√ÉO: AudioManager.Instance

                const introSequence = [
                    {
                        title: "O DESEQUIL√çBRIO",
                        text: "O mundo treme sob o peso do desequil√≠brio. Ignys, o Reino do Fogo, deseja guerra e j√° move suas tropas em dire√ß√£o aos reinos vizinhos.",
                        gif: null
                    },
                    {
                        title: "O CORA√á√ÉO DE GELO",
                        text: "Em Tup√£ry, o Cora√ß√£o de Gelo guarda a metade maligna de Anhang√°, o esp√≠rito que traz caos.",
                        gif: CONFIG.ASSET_LOADED.cutscene_gif_1 // Este GIF √© para a tag <img>, ent√£o funciona.
                    },
                    {
                        title: "A CONVOCA√á√ÉO",
                        text: `Umbra convoca voc√™, ${gameState.playerName}, o Escolhido: recuperar o Cora√ß√£o de Gelo e impedir que Ignys obtenha poder suficiente para dominar todos os reinos.`,
                        gif: null
                    },
                    {
                        title: "O DESTINO",
                        text: "Cada passo, cada luta, cada escolha ser√° decisiva para a sobreviv√™ncia de todos.",
                        gif: null
                    }
                ];
                UIManager.Instance.playCutsceneSequence(introSequence, () => { // CORRE√á√ÉO: UIManager.Instance
                    this.endIntroCutscene();
                });
                EventManager.emit('game_state_change', 'IN_CUTSCENE');
            }

            /**
             * Finaliza a cutscene inicial.
             */
            endIntroCutscene() {
                gameState.inCutscene = false;
                UIManager.Instance.hideCutscene(); // CORRE√á√ÉO: UIManager.Instance
                this.loadPhase(1); // Inicia a primeira fase do jogo
                EventManager.emit('game_state_change', 'OUT_OF_CUTSCENE');
            }

            /**
             * Salva o progresso do jogo em cookies.
             */
            saveProgress() {
                const saveData = {
                    playerName: gameState.playerName,
                    playerLevel: gameState.player.level,
                    playerXP: gameState.player.xp,
                    playerNextLevelXP: gameState.player.nextLevelXP,
                    playerMaxHealth: gameState.player.health.maxHealth,
                    playerMaxMana: gameState.player.mana.maxMana,
                    playerDamage: gameState.player.damage,
                    playerSpeed: gameState.player.baseSpeed,
                    currentPhase: gameState.currentPhase,
                    currentCheckpoint: gameState.currentCheckpoint,
                    bossDefeated: gameState.bossDefeated,
                    tarekDialogCompleted: gameState.tarekDialogCompleted,
                    abilitiesMaxCooldown: {} // Salva cooldowns m√°ximos para cada habilidade
                };

                for (const key in gameState.player.abilities) {
                    saveData.abilitiesMaxCooldown[key] = gameState.player.abilities[key].cooldown;
                }
                
                this._setCookie('tupary_save', JSON.stringify(saveData));
                UIManager.Instance.showCheckpointNotification('Progresso Salvo', 'Seu progresso foi salvo com sucesso!'); // CORRE√á√ÉO: UIManager.Instance
                EventManager.emit('game_saved');
            }

            /**
             * Carrega o progresso do jogo de cookies.
             * @returns {object|null} Dados do jogo salvos.
             * @private
             */
            _loadProgress() {
                const saveData = this._getCookie('tupary_save');
                if (saveData) {
                    try {
                        return JSON.parse(saveData);
                    } catch (e) {
                        console.error('Erro ao carregar save:', e);
                    }
                }
                return null;
            }

            /**
             * Aplica os dados salvos ao estado do jogo.
             * @param {object} data - Dados a serem aplicados.
             * @private
             */
            _applySavedData(data) {
                gameState.playerName = data.playerName;
                gameState.player.level = data.playerLevel;
                gameState.player.xp = data.playerXP;
                gameState.player.nextLevelXP = data.playerNextLevelXP;
                gameState.player.health.maxHealth = data.playerMaxHealth;
                gameState.player.health.currentHealth = data.playerMaxHealth; // Garante vida cheia ao carregar
                gameState.player.mana.maxMana = data.playerMaxMana;
                gameState.player.mana.currentMana = data.playerMaxMana; // Garante mana cheia
                gameState.player.damage = data.playerDamage;
                gameState.player.baseSpeed = data.playerSpeed;
                gameState.player.currentSpeed = data.playerSpeed;
                gameState.currentPhase = data.currentPhase;
                gameState.currentCheckpoint = data.currentCheckpoint;
                gameState.bossDefeated = data.bossDefeated;
                gameState.tarekDialogCompleted = data.tarekDialogCompleted;

                for (const key in data.abilitiesMaxCooldown) {
                    if (gameState.player.abilities[key]) {
                        gameState.player.abilities[key].cooldown = data.abilitiesMaxCooldown[key];
                    }
                }

                // For√ßa atualiza√ß√£o da UI com os valores carregados
                UIManager.Instance.updatePlayerStats(gameState.player.level, gameState.player.damage); // CORRE√á√ÉO: UIManager.Instance
                UIManager.Instance.updateHealth({ current: gameState.player.health.currentHealth, max: gameState.player.health.maxHealth }); // CORRE√á√ÉO: UIManager.Instance
                UIManager.Instance.updateMana({ current: gameState.player.mana.currentMana, max: gameState.player.mana.maxMana }); // CORRE√á√ÉO: UIManager.Instance
                UIManager.Instance.updateXP({ current: gameState.player.xp, max: gameState.player.nextLevelXP }); // CORRE√á√ÉO: UIManager.Instance
            }

            /**
             * Salva um checkpoint no jogo.
             * @param {string} checkpointName - Nome do checkpoint.
             * @param {string} description - Descri√ß√£o para a notifica√ß√£o.
             */
            saveCheckpoint(checkpointName, description) {
                gameState.currentCheckpoint = checkpointName;
                const checkpointData = {
                    name: checkpointName,
                    phase: gameState.currentPhase,
                    playerPosition: { x: gameState.player.position.x, y: gameState.player.position.y },
                    playerHealth: gameState.player.health.currentHealth,
                    playerMana: gameState.player.mana.currentMana,
                    playerXP: gameState.player.xp,
                    playerLevel: gameState.player.level,
                    playerNextLevelXP: gameState.player.nextLevelXP,
                    playerMaxHealth: gameState.player.health.maxHealth,
                    playerMaxMana: gameState.player.mana.maxMana,
                    playerDamage: gameState.player.damage,
                    playerSpeed: gameState.player.baseSpeed,
                    tarekDialogCompleted: gameState.tarekDialogCompleted,
                    abilitiesMaxCooldown: {}
                };
                for (const key in gameState.player.abilities) {
                    checkpointData.abilitiesMaxCooldown[key] = gameState.player.abilities[key].cooldown;
                }
                
                this._setCookie('tupary_checkpoint', JSON.stringify(checkpointData));
                UIManager.Instance.showCheckpointNotification('Checkpoint Salvo', `Progresso salvo em: ${description}`); // CORRE√á√ÉO: UIManager.Instance
                EventManager.emit('checkpoint_saved', checkpointName);
            }

            /**
             * Carrega o √∫ltimo checkpoint salvo.
             */
            restartFromCheckpoint() {
                this.togglePause(false); // Despausa o jogo
                const checkpointData = this._getCookie('tupary_checkpoint');
                if (checkpointData) {
                    try {
                        const data = JSON.parse(checkpointData);
                        
                        // Restaura o estado do jogo e do jogador
                        gameState.currentPhase = data.phase;
                        gameState.currentCheckpoint = data.name;
                        
                        // Se o jogador j√° existe, atualiza as propriedades, sen√£o, recria.
                        if (gameState.player) {
                            gameState.player.position = { x: data.playerPosition.x, y: data.playerPosition.y };
                            gameState.player.health.currentHealth = data.playerHealth;
                            gameState.player.health.maxHealth = data.playerMaxHealth; 
                            gameState.player.mana.currentMana = data.playerMana;
                            gameState.player.mana.maxMana = data.playerMaxMana; 
                            gameState.player.xp = data.playerXP;
                            gameState.player.level = data.playerLevel;
                            gameState.player.nextLevelXP = data.playerNextLevelXP;
                            gameState.player.damage = data.playerDamage;
                            gameState.player.baseSpeed = data.playerSpeed;
                            gameState.player.currentSpeed = data.playerSpeed;
                            gameState.tarekDialogCompleted = data.tarekDialogCompleted;

                            for (const key in data.abilitiesMaxCooldown) {
                                if (gameState.player.abilities[key]) {
                                    gameState.player.abilities[key].cooldown = data.abilitiesMaxCooldown[key];
                                }
                            }
                        } else {
                            // Este caso s√≥ deve ocorrer se o jogador foi limpo por algum motivo (ex: exitToMenu)
                            // e estamos tentando reiniciar um checkpoint. Isso recriaria o jogador.
                            console.warn("Player was null, recreating player from checkpoint data.");
                             gameState.player = new Player(data.playerName, {
                                baseHealth: data.playerMaxHealth, baseMana: data.playerMaxMana, baseSpeed: data.playerSpeed,
                                baseDamage: data.playerDamage, manaRegenRate: CONFIG.MANA_REGEN_RATE, // Using default regen rate
                                abilities: [ // Default abilities, would need to store/load specific ability data if they changed
                                    { key: 'U', name: 'Tiro Sombrio', manaCost: 0, cooldown: 0.6, damageModifier: 1.2, animationKey: 'attack_u' },
                                    { key: 'I', name: 'Sombra √Ågil', manaCost: 25, cooldown: 5, animationKey: 'attack_i' },
                                    { key: 'O', name: 'Orbe Et√©reo', manaCost: 35, cooldown: 4, damageModifier: 1.8, animationKey: 'attack_o' },
                                    { key: 'P', name: 'F√∫ria de Umbra', manaCost: 50, cooldown: 8, animationKey: 'ultimate' }
                                ]
                            });
                             this._applySavedData(data); // Aplica o resto dos dados
                        }
                        
                        this.loadPhase(data.phase, data.name); // Recarrega a fase e posiciona no checkpoint
                        UIManager.Instance.showCheckpointNotification('Checkpoint Carregado', 'Retornando ao √∫ltimo checkpoint salvo...'); // CORRE√á√ÉO: UIManager.Instance
                        EventManager.emit('checkpoint_loaded', data.name);
                    } catch (e) {
                        console.error('Erro ao carregar checkpoint:', e);
                        // Se houver erro, apenas reinicia a fase atual
                        this.loadPhase(gameState.currentPhase);
                        UIManager.Instance.showCheckpointNotification('Erro!', 'N√£o foi poss√≠vel carregar o checkpoint. Reiniciando a fase atual.'); // CORRE√á√ÉO: UIManager.Instance
                    }
                } else {
                    // Se n√£o houver checkpoint, apenas reinicia a fase atual
                    this.loadPhase(gameState.currentPhase);
                    UIManager.Instance.showCheckpointNotification('Nenhum Checkpoint', 'Nenhum checkpoint encontrado. Reiniciando a fase atual.'); // CORRE√á√ÉO: UIManager.Instance
                }
            }

            /**
             * Volta para o menu principal, limpando o estado do jogo.
             */
            exitToMenu() {
                this.saveProgress(); // Salva antes de sair
                
                // Reinicia o estado global do jogo para o menu principal
                gameState = {
                    playerName: '',
                    player: null,
                    currentPhase: 0,
                    currentCheckpoint: 'start',
                    gamePaused: false, inDialog: false, inCutscene: false,
                    inMenu: true, gameStarted: false,
                    cameraOffset: { x: 0, y: 0 }, targetCameraOffset: { x: 0, y: 0 },
                    inBossFight: false, bossDefeated: false,
                    inTarekEncounter: false, tarekDialogStep: 0, tarekDialogCompleted: false,
                    tarekEncounterTriggerX: 5500,
                    fixedCamera: false, fixedCameraTarget: { x: 0, y: 0 }
                };

                // Limpa todos os elementos DOM das entidades
                if (gameWorldElement) {
                    while (gameWorldElement.firstChild) {
                        gameWorldElement.removeChild(gameWorldElement.firstChild);
                    }
                }

                // Limpa todas as entidades
                platforms = []; enemies = []; 
                fallingSpikes = []; checkpoints = [];
                ObjectPooler.Instance.returnAllActiveToPools(); // Garante que pools estejam limpas
                
                UIManager.Instance.hideAllOverlays(); // CORRE√á√ÉO: UIManager.Instance
                UIManager.Instance.showMainMenu(); // CORRE√á√ÉO: UIManager.Instance
                UIManager.Instance.resetMainMenuInputs(); // CORRE√á√ÉO: UIManager.Instance

                AudioManager.Instance.stopMusic(); // CORRE√á√ÉO: AudioManager.Instance
                AudioManager.Instance.playMusic('music_menu', true); // CORRE√á√ÉO: AudioManager.Instance

                // Limpa o canvas (se ainda estiver em uso para algo)
                if (canvas && ctx) { // Check if ctx exists before trying to clear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }

                EventManager.emit('game_state_change', 'EXIT_TO_MENU');
            }

            /**
             * Define um cookie.
             * @param {string} name - Nome do cookie.
             * @param {string} value - Valor do cookie.
             * @param {number} days - Dias de expira√ß√£o.
             * @private
             */
            _setCookie(name, value, days = 30) {
                const expires = new Date();
                expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
                document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
            }

            /**
             * Obt√©m o valor de um cookie.
             * @param {string} name - Nome do cookie.
             * @returns {string|null} - Valor do cookie ou null.
             * @private
             */
            _getCookie(name) {
                const nameEQ = name + "=";
                const ca = document.cookie.split(';');
                for (let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                }
                return null;
            }

            /**
             * Carrega as configura√ß√µes do jogo de cookies.
             * @private
             */
            _loadSettings() {
                const saved = this._getCookie('tupary_settings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        Object.assign(this.gameSettings, settings);
                    } catch (e) {
                        console.error('Erro ao carregar configura√ß√µes:', e);
                    }
                }
            }

            /**
             * Salva as configura√ß√µes do jogo em cookies.
             * @private
             */
            _saveSettings() {
                this._setCookie('tupary_settings', JSON.stringify(this.gameSettings));
            }
        }

        /**
         * @class UIManager
         * @description Gerencia todas as intera√ß√µes e atualiza√ß√µes da interface do usu√°rio (UI).
         */
        class UIManager {
            constructor() {
                if (UIManager.Instance) {
                    return UIManager.Instance;
                }
                UIManager.Instance = this;

                // Refer√™ncias aos elementos HTML da UI
                this.elements = {
                    mainMenu: document.getElementById('main-menu'),
                    playerNameInput: document.getElementById('player-name'),
                    startGameBtn: document.getElementById('start-game-btn'),
                    
                    healthFill: document.getElementById('health-fill'),
                    healthText: document.getElementById('health-text'),
                    manaFill: document.getElementById('mana-fill'),
                    manaText: document.getElementById('mana-text'),
                    xpFill: document.getElementById('xp-fill'),
                    xpText: document.getElementById('xp-text'),
                    playerLevel: document.getElementById('player-level'),
                    playerClass: document.getElementById('player-class'),
                    playerDamage: document.getElementById('player-damage'),

                    bossName: document.getElementById('boss-name'),
                    bossHealthBar: document.getElementById('boss-health-bar'),
                    bossHealthFill: document.getElementById('boss-health-fill'),

                    abilityBtns: document.querySelectorAll('.ability-btn'),
                    pauseBtn: document.getElementById('pause-btn'),
                    pauseMenu: document.getElementById('pause-menu'),
                    resumeBtn: document.getElementById('resume-btn'),
                    restartBtn: document.getElementById('restart-btn'),
                    saveBtn: document.getElementById('save-btn'),
                    exitBtn: document.getElementById('exit-btn'),

                    mobileControls: document.getElementById('mobile-controls'),
                    
                    dialogContainer: document.getElementById('dialog-container'),
                    dialogSpeaker: document.getElementById('dialog-speaker'),
                    dialogText: document.getElementById('dialog-text'),
                    dialogOptions: document.getElementById('dialog-options'),

                    cinematicOverlay: document.getElementById('cinematic-overlay'),
                    cinematicTitle: document.getElementById('cinematic-title'),
                    cinematicGif: document.getElementById('cutscene-gif'),
                    cinematicText: document.getElementById('cinematic-text'),
                    skipBtn: document.getElementById('skip-btn'),

                    levelUpMenu: document.getElementById('level-up'),
                    upgradeOptions: document.querySelectorAll('.upgrade-option'),

                    checkpointNotification: document.getElementById('checkpoint-notification'),
                    checkpointText: document.getElementById('checkpoint-text'),
                    checkpointDescription: document.getElementById('checkpoint-description'),

                    screenFlash: document.getElementById('screen-flash'),
                    particleContainer: document.getElementById('particle-container'),
                    orientationWarning: document.getElementById('orientation-warning')
                };

                // Debugging element acquisition for critical elements
                if (!this.elements.playerNameInput) console.error("UIManager Error: 'player-name' input element not found!");
                if (!this.elements.startGameBtn) console.error("UIManager Error: 'start-game-btn' button element not found!");
                
                this._initEventListeners();
            }

            _initEventListeners() {
                // Menu Principal
                // CORRE√á√ÉO: Garante que o evento 'input' √© ouvido para validar o bot√£o
                this.elements.playerNameInput.addEventListener('input', this.validateMainMenuInputs.bind(this));
                this.elements.startGameBtn.addEventListener('click', () => {
                    GameManager.Instance.startGame(this.elements.playerNameInput.value.trim());
                });

                // Bot√µes de Pausa
                this.elements.pauseBtn.addEventListener('click', () => GameManager.Instance.togglePause());
                this.elements.resumeBtn.addEventListener('click', () => GameManager.Instance.togglePause());
                this.elements.restartBtn.addEventListener('click', () => GameManager.Instance.restartFromCheckpoint());
                this.elements.saveBtn.addEventListener('click', () => GameManager.Instance.saveProgress());
                this.elements.exitBtn.addEventListener('click', () => GameManager.Instance.exitToMenu());

                // Bot√µes de Habilidade
                this.elements.abilityBtns.forEach(btn => {
                    const key = btn.dataset.key;
                    btn.addEventListener('click', () => {
                        if (gameState.player) {
                            gameState.player.abilities[key].activate(); // Ativa a habilidade
                        }
                    });
                });

                // Bot√£o de pular cutscene
                this.elements.skipBtn.addEventListener('click', () => {
                    // No contexto da cutscene inicial, 'skip' significa 'avan√ßar para o pr√≥ximo passo'
                    // ou 'pular toda a cutscene' se for o √∫ltimo passo.
                    this._advanceCutsceneSequence();
                });

                // Op√ß√µes de Level Up
                this.elements.upgradeOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        const upgradeType = e.currentTarget.dataset.upgrade;
                        this._applyUpgrade(upgradeType);
                    });
                });
            }

            /**
             * Valida os inputs do menu principal (nome do jogador).
             */
            validateMainMenuInputs() {
                const name = this.elements.playerNameInput.value.trim();
                console.log(`DEBUG: Nome no input: '${name}', Comprimento: ${name.length}`); // Log de depura√ß√£o
                this.elements.startGameBtn.disabled = name.length < 2;
                console.log(`DEBUG: Bot√£o 'Iniciar Jornada' desabilitado: ${this.elements.startGameBtn.disabled}`); // Log de depura√ß√£o
            }

            /**
             * Reseta os inputs do menu principal.
             */
            resetMainMenuInputs() {
                if (this.elements.playerNameInput) this.elements.playerNameInput.value = '';
                if (this.elements.startGameBtn) this.elements.startGameBtn.disabled = true;
            }

            /**
             * Mostra o menu principal.
             */
            showMainMenu() {
                if (this.elements.mainMenu) {
                    this.elements.mainMenu.style.display = 'flex';
                    this.elements.mainMenu.style.pointerEvents = 'auto';
                }
            }

            /**
             * Esconde o menu principal.
             */
            hideMainMenu() {
                if (this.elements.mainMenu) {
                    this.elements.mainMenu.style.display = 'none';
                    this.elements.mainMenu.style.pointerEvents = 'none';
                }
            }

            /**
             * Mostra/esconde um overlay de UI.
             * @param {HTMLElement} element - O elemento HTML do overlay.
             * @param {boolean} show - True para mostrar, false para esconder.
             * @param {string} displayType - Tipo de display (flex, block, etc.).
             */
            _toggleOverlay(element, show, displayType = 'flex') {
                if (element) {
                    element.style.display = show ? displayType : 'none';
                    element.style.pointerEvents = show ? 'auto' : 'none';
                }
            }

            /**
             * Esconde todos os overlays de UI.
             */
            hideAllOverlays() {
                this._toggleOverlay(this.elements.pauseMenu, false);
                this._toggleOverlay(this.elements.levelUpMenu, false);
                this._toggleOverlay(this.elements.dialogContainer, false);
                this._toggleOverlay(this.elements.cinematicOverlay, false);
                // Outros overlays que podem estar ativos
            }

            /**
             * Atualiza a barra de sa√∫de.
             * @param {object} data - { current, max }.
             */
            updateHealth(data) {
                if (!this.elements.healthFill || !this.elements.healthText) return;
                const percentage = (data.current / data.max) * 100;
                this.elements.healthFill.style.width = percentage + '%';
                this.elements.healthText.textContent = `${Math.round(data.current)}/${Math.round(data.max)}`;
            }

            /**
             * Atualiza a barra de mana.
             * @param {object} data - { current, max }.
             */
            updateMana(data) {
                if (!this.elements.manaFill || !this.elements.manaText) return;
                const percentage = (data.current / data.max) * 100;
                this.elements.manaFill.style.width = percentage + '%';
                this.elements.manaText.textContent = `${Math.round(data.current)}/${Math.round(data.max)}`;
            }

            /**
             * Atualiza a barra de XP.
             * @param {object} data - { current, max }.
             */
            updateXP(data) {
                if (!this.elements.xpFill || !this.elements.xpText) return;
                const percentage = (data.current / data.max) * 100;
                this.elements.xpFill.style.width = percentage + '%';
                this.elements.xpText.textContent = `${Math.round(data.current)}/${Math.round(data.max)}`;
            }

            /**
             * Atualiza as estat√≠sticas do jogador na UI.
             * @param {number} level - N√≠vel do jogador.
             * @param {number} damage - Dano do jogador.
             */
            updatePlayerStats(level, damage) {
                if (this.elements.playerLevel) this.elements.playerLevel.textContent = level;
                if (this.elements.playerDamage) this.elements.playerDamage.textContent = Math.round(damage);
            }

            /**
             * Atualiza a barra de vida do boss.
             * @param {string} name - Nome do boss.
             * @param {number} current - Vida atual.
             * @param {number} max - Vida m√°xima.
             */
            updateBossHealth(name, current, max) {
                if (!this.elements.bossName || !this.elements.bossHealthFill) return;
                this.elements.bossName.textContent = name;
                const percentage = (current / max) * 100;
                this.elements.bossHealthFill.style.width = percentage + '%';

                if (percentage > 60) {
                    this.elements.bossHealthFill.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
                } else if (percentage > 30) {
                    this.elements.bossHealthFill.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
                } else {
                    this.elements.bossHealthFill.style.background = 'linear-gradient(90deg, #f44336, #e53935)';
                }
            }

            /**
             * Mostra as barras de vida do boss.
             * @param {string} name - Nome do boss.
             * @param {number} current - Vida atual.
             * @param {number} max - Vida m√°xima.
             */
            showBossBars(name, current, max) {
                if (this.elements.bossName) this.elements.bossName.style.display = 'block';
                if (this.elements.bossHealthBar) this.elements.bossHealthBar.style.display = 'block';
                this.updateBossHealth(name, current, max);
            }

            /**
             * Esconde as barras de vida do boss.
             */
            hideBossBars() {
                if (this.elements.bossName) this.elements.bossName.style.display = 'none';
                if (this.elements.bossHealthBar) this.elements.bossHealthBar.style.display = 'none';
            }

            /**
             * Atualiza o visual do cooldown de uma habilidade.
             * @param {object} data - { key, current, max }.
             */
            updateAbilityCooldown(data) {
                const btn = document.getElementById(`ability-${data.key.toLowerCase()}`);
                const overlay = btn?.querySelector('.cooldown-overlay');
                
                if (btn && overlay) {
                    const cooldownRatio = data.current / data.max;
                    if (cooldownRatio > 0) {
                        btn.classList.add('cooldown');
                        const angle = 360 * (1 - cooldownRatio);
                        overlay.style.background = `conic-gradient(from 0deg, transparent ${angle}deg, rgba(0, 0, 0, 0.8) ${angle}deg)`;
                    } else {
                        btn.classList.remove('cooldown');
                        overlay.style.background = '';
                    }
                }
            }

            /**
             * Exibe o menu de pausa.
             */
            showPauseMenu() {
                this._toggleOverlay(this.elements.pauseMenu, true);
            }

            /**
             * Esconde o menu de pausa.
             */
            hidePauseMenu() {
                this._toggleOverlay(this.elements.pauseMenu, false);
            }

            /**
             * Exibe a caixa de di√°logo.
             * @param {string} speaker - Quem est√° falando.
             * @param {string} text - O texto do di√°logo.
             * @param {Array<object>} options - Op√ß√µes de resposta (cada uma com text e action).
             */
            showDialog(speaker, text, options = null) {
                this._toggleOverlay(this.elements.dialogContainer, true);
                if (this.elements.dialogSpeaker) this.elements.dialogSpeaker.textContent = speaker;
                if (this.elements.dialogText) this.elements.dialogText.textContent = text;
                if (this.elements.dialogOptions) this.elements.dialogOptions.innerHTML = ''; // Limpa op√ß√µes anteriores

                if (options && options.length > 0) {
                    options.forEach((option) => {
                        const button = document.createElement('div');
                        button.className = 'dialog-option';
                        button.textContent = option.text;
                        button.addEventListener('click', () => {
                            GameManager.Instance.hideDialog(); // Esconde o di√°logo
                            if (option.action) option.action(); // Executa a a√ß√£o da op√ß√£o
                        });
                        this.elements.dialogOptions.appendChild(button);
                    });
                } else {
                    // Op√ß√£o padr√£o "Continuar"
                    const button = document.createElement('div');
                    button.className = 'dialog-option';
                    button.textContent = 'Continuar';
                    button.addEventListener('click', () => GameManager.Instance.hideDialog());
                    this.elements.dialogOptions.appendChild(button);
                }
            }

            /**
             * Esconde a caixa de di√°logo.
             */
            hideDialog() {
                this._toggleOverlay(this.elements.dialogContainer, false);
            }

            /**
             * Controla a sequ√™ncia de cutscene.
             */
            _currentCutsceneSequence = null;
            _currentSequenceIndex = 0;
            _cutsceneFinishCallback = null;

            playCutsceneSequence(sequence, onFinishCallback) {
                this._currentCutsceneSequence = sequence;
                this._currentSequenceIndex = 0;
                this._cutsceneFinishCallback = onFinishCallback;
                this._advanceCutsceneSequence();
            }

            _advanceCutsceneSequence() {
                if (this._currentSequenceIndex < this._currentCutsceneSequence.length) {
                    const sequenceItem = this._currentCutsceneSequence[this._currentSequenceIndex];
                    
                    if (this.elements.cinematicTitle) this.elements.cinematicTitle.textContent = sequenceItem.title;
                    if (this.elements.cinematicText) this.elements.cinematicText.textContent = sequenceItem.text;
                    
                    // Reinicia anima√ß√µes CSS para garantir o efeito fadeIn
                    if (this.elements.cinematicTitle) this.elements.cinematicTitle.style.animation = 'none';
                    if (this.elements.cinematicText) this.elements.cinematicText.style.animation = 'none';
                    void this.elements.cinematicTitle.offsetWidth; // For√ßa reflow
                    void this.elements.cinematicText.offsetWidth;
                    if (this.elements.cinematicTitle) this.elements.cinematicTitle.style.animation = 'fadeInText 2s forwards';
                    if (this.elements.cinematicText) this.elements.cinematicText.style.animation = 'fadeInText 3s forwards 0.5s';

                    // Gerencia a exibi√ß√£o do GIF (elemento <img> HTML pode exibir GIFs animados)
                    if (this.elements.cinematicGif) {
                        if (sequenceItem.gif) {
                            this.elements.cinematicGif.src = sequenceItem.gif.src;
                            this.elements.cinematicGif.style.display = 'block';
                        } else {
                            this.elements.cinematicGif.style.display = 'none';
                            this.elements.cinematicGif.src = ''; // Limpa a URL
                        }
                    }
                    
                    this._currentSequenceIndex++;
                } else {
                    if (this._cutsceneFinishCallback) {
                        this._cutsceneFinishCallback(); // Chama o callback de t√©rmino
                    }
                    this._currentCutsceneSequence = null;
                    this._currentSequenceIndex = 0;
                    this._cutsceneFinishCallback = null;
                }
            }

            /**
             * Mostra o overlay de cutscene.
             */
            showCutscene() {
                this._toggleOverlay(this.elements.cinematicOverlay, true);
                if (this.elements.skipBtn) this.elements.skipBtn.textContent = 'Pr√≥ximo';
            }

            /**
             * Esconde o overlay de cutscene.
             */
            hideCutscene() {
                this._toggleOverlay(this.elements.cinematicOverlay, false);
                if (this.elements.cinematicGif) {
                    this.elements.cinematicGif.style.display = 'none'; // Garante que o GIF seja escondido
                    this.elements.cinematicGif.src = '';
                }
            }

            /**
             * Mostra o menu de level up.
             */
            showLevelUpMenu() {
                this._toggleOverlay(this.elements.levelUpMenu, true);
                if (this.elements.levelUpMenu) this.elements.levelUpMenu.style.animation = 'levelUpAnimation 0.8s forwards'; // Adiciona anima√ß√£o de entrada
            }

            /**
             * Aplica o upgrade escolhido no menu de level up.
             * @param {string} upgradeType - Tipo de upgrade.
             */
            _applyUpgrade(upgradeType) {
                if (!gameState.player) return;

                switch(upgradeType) {
                    case 'health':
                        gameState.player.health.maxHealth += 25;
                        gameState.player.health.heal(gameState.player.health.maxHealth); // Cura total
                        break;
                    case 'mana':
                        gameState.player.mana.maxMana += 35;
                        gameState.player.mana.currentMana = gameState.player.mana.maxMana; // Mana total
                        gameState.player.mana.regenRate *= 1.5; // Acelera regenera√ß√£o
                        break;
                    case 'damage':
                        gameState.player.damage += 8;
                        break;
                    case 'speed':
                        gameState.player.baseSpeed += 0.8;
                        gameState.player.currentSpeed = gameState.player.baseSpeed; // Update current speed after base speed increase
                        // Reduz cooldowns das habilidades
                        for (const key in gameState.player.abilities) {
                            if (gameState.player.abilities[key]) { // Check if ability exists
                                gameState.player.abilities[key].cooldown *= 0.85;
                            }
                        }
                        break;
                }
                this._toggleOverlay(this.elements.levelUpMenu, false);
                if (this.elements.levelUpMenu) this.elements.levelUpMenu.style.animation = ''; // Remove a anima√ß√£o
                EventManager.emit('ui_level_up_applied'); // Notifica que o upgrade foi aplicado
                EventManager.emit('player_level_up_stats', { level: gameState.player.level, damage: gameState.player.damage }); // Atualiza a UI de stats
            }

            /**
             * Exibe uma notifica√ß√£o de checkpoint salvo.
             * @param {string} title - T√≠tulo da notifica√ß√£o.
             * @param {string} description - Descri√ß√£o da notifica√ß√£o.
             */
            showCheckpointNotification(title, description) {
                if (!this.elements.checkpointText || !this.elements.checkpointDescription || !this.elements.checkpointNotification) return;
                this.elements.checkpointText.textContent = title;
                this.elements.checkpointDescription.textContent = description;
                this.elements.checkpointNotification.style.display = 'block';
                this.elements.checkpointNotification.style.animation = 'checkpointPulse 2s ease-in-out';
                setTimeout(() => {
                    if (this.elements.checkpointNotification) this.elements.checkpointNotification.style.display = 'none';
                }, 2000);
            }

            /**
             * Efeito de flash na tela.
             * @param {object} data - { color, duration }.
             */
            flashScreen(data) {
                if (!this.elements.screenFlash) return;
                this.elements.screenFlash.style.background = data.color;
                this.elements.screenFlash.classList.add('active');
                setTimeout(() => {
                    if (this.elements.screenFlash) this.elements.screenFlash.classList.remove('active');
                }, data.duration);
            }

            /**
             * Efeito de "tremor" na tela.
             * @param {object} data - { intensity, duration }.
             */
            screenShake(data) {
                if (!GameManager.Instance.gameSettings.screenShake || !document.getElementById('game-container')) return;
                const gameContainer = document.getElementById('game-container');
                const originalTransform = gameContainer.style.transform;
                const startTime = performance.now();
                
                const shake = () => {
                    const elapsed = performance.now() - startTime;
                    if (elapsed < data.duration) {
                        const progress = elapsed / data.duration;
                        const currentIntensity = data.intensity * (1 - progress);
                        
                        const offsetX = (Math.random() - 0.5) * currentIntensity;
                        const offsetY = (Math.random() - 0.5) * currentIntensity;
                        
                        gameContainer.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                        requestAnimationFrame(shake);
                    } else {
                        gameContainer.style.transform = originalTransform;
                    }
                };
                shake();
            }

            /**
             * Atualiza a visibilidade dos controles mobile.
             * @param {boolean} isMobile - Se o dispositivo √© mobile.
             * @param {boolean} isLandscape - Se a orienta√ß√£o √© paisagem.
             */
            updateMobileControlsVisibility(isMobile, isLandscape) {
                if (this.elements.mobileControls) {
                    this.elements.mobileControls.style.display = (isMobile && isLandscape) ? 'grid' : 'none';
                }
            }

            /**
             * Mostra a tela de vit√≥ria.
             * @param {string} playerName - Nome do jogador.
             * @param {number} level - N√≠vel final.
             * @param {number} xp - XP total.
             */
            showVictoryScreen(playerName, level, xp) {
                if (this.elements.cinematicGif) {
                    this.elements.cinematicGif.style.display = 'none';
                    this.elements.cinematicGif.src = '';
                }
                
                this._toggleOverlay(this.elements.cinematicOverlay, true);
                
                if (this.elements.cinematicTitle) this.elements.cinematicTitle.textContent = "VIT√ìRIA!";
                if (this.elements.cinematicText) {
                    this.elements.cinematicText.innerHTML = `
                        <p>Parab√©ns, ${playerName}!</p>
                        <br>
                        <p>Voc√™ completou a primeira parte da jornada em Tup√£ry. Tarek foi derrotado e o caminho para o interior do reino gelado est√° aberto.</p>
                        <br>
                        <p>Mas esta √© apenas a primeira de muitas prova√ß√µes. O Cora√ß√£o de Gelo ainda aguarda, e Ignys se aproxima...</p>
                        <br>
                        <p><strong>Estat√≠sticas Finais:</strong></p>
                        <p>N√≠vel Alcan√ßado: ${level}</p>
                        <p>Classe: Escolhido</p>
                        <p>XP Total: ${xp}</p>
                        <br>
                        <p><em>Obrigado por jogar Tup√£ry: O Reino Congelado!</em></p>
                        <p><em>Mais cap√≠tulos em breve...</em></p>
                    `;
                }
                
                if (this.elements.cinematicTitle) this.elements.cinematicTitle.style.animation = 'none';
                if (this.elements.cinematicText) this.elements.cinematicText.style.animation = 'none';
                if (this.elements.cinematicTitle) void this.elements.cinematicTitle.offsetWidth;
                if (this.elements.cinematicText) void this.elements.cinematicText.offsetWidth;
                if (this.elements.cinematicTitle) this.elements.cinematicTitle.style.animation = 'fadeInText 2s forwards';
                if (this.elements.cinematicText) this.elements.cinematicText.style.animation = 'fadeInText 3s forwards 1s';
                
                if (this.elements.skipBtn) {
                    this.elements.skipBtn.textContent = 'Voltar ao Menu';
                    this.elements.skipBtn.onclick = () => {
                        // Limpa cookies de save e checkpoint ao finalizar o jogo
                        GameManager.Instance._setCookie('tupary_save', '', -1);
                        GameManager.Instance._setCookie('tupary_checkpoint', '', -1);
                        GameManager.Instance.exitToMenu();
                    };
                }
            }
        }

        /**
         * @class AudioManager
         * @description Gerencia a reprodu√ß√£o de √°udios (m√∫sica e efeitos sonoros).
         */
        class AudioManager {
            constructor() {
                if (AudioManager.Instance) {
                    return AudioManager.Instance;
                }
                AudioManager.Instance = this;

                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.audioSources = {}; // Armazena AudioBuffers
                this.currentMusicSource = null; // Source node da m√∫sica atual
                this.musicGainNode = this.audioContext.createGain(); // N√≥ de ganho para m√∫sica
                this.sfxGainNode = this.audioContext.createGain(); // N√≥ de ganho para SFX

                // Conecta os n√≥s de ganho ao destino de √°udio
                this.musicGainNode.connect(this.audioContext.destination);
                this.sfxGainNode.connect(this.audioContext.destination);

                this.setMusicVolume(GameManager.Instance.gameSettings.musicVolume);
                this.setSfxVolume(GameManager.Instance.gameSettings.sfxVolume);

                // Listeners para reproduzir SFX e m√∫sica
                EventManager.subscribe('sfx_play', this.playSFX.bind(this));
                EventManager.subscribe('music_play', (data) => this.playMusic(data.name, data.loop, data.volume));
                EventManager.subscribe('music_stop', this.stopMusic.bind(this));
            }

            /**
             * Carrega um arquivo de √°udio.
             * @param {string} name - Nome para identificar o √°udio.
             * @param {string} url - URL do arquivo de √°udio.
             */
            async loadSound(name, url) {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.audioSources[name] = audioBuffer;
                    console.log(`√Åudio carregado: ${url}`);
                    return audioBuffer; // Retorna o buffer carregado
                } catch (error) {
                    console.error(`Erro ao carregar o √°udio '${name}' de '${url}':`, error);
                    // Retorna um buffer vazio para evitar erros futuros
                    return this.audioContext.createBuffer(2, 22050, 44100);
                }
            }

            /**
             * Reproduz um efeito sonoro.
             * @param {string} name - Nome do SFX.
             * @param {number} volume - Volume (0.0 a 1.0).
             */
            playSFX(name, volume = 1.0) {
                if (!this.audioSources[name]) {
                    console.warn(`√Åudio SFX '${name}' n√£o carregado ou inv√°lido.`);
                    return;
                }
                try {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = this.audioSources[name];
                    source.connect(this.sfxGainNode);
                    source.start(0);
                } catch (error) {
                    console.error("Erro ao reproduzir SFX:", error);
                }
            }

            /**
             * Reproduz uma m√∫sica.
             * @param {string} name - Nome da m√∫sica.
             * @param {boolean} loop - Se a m√∫sica deve repetir.
             * @param {number} volume - Volume (0.0 a 1.0).
             */
            playMusic(name, loop = true, volume = 0.7) {
                this.stopMusic(); // Para qualquer m√∫sica tocando

                if (!this.audioSources[name]) {
                    console.warn(`M√∫sica '${name}' n√£o carregada ou inv√°lida.`);
                    return;
                }

                try {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = this.audioSources[name];
                    source.loop = loop;
                    source.connect(this.musicGainNode);
                    source.start(0);
                    this.currentMusicSource = source;
                } catch (error) {
                    console.error("Erro ao reproduzir m√∫sica:", error);
                }
            }

            /**
             * Para a m√∫sica atual.
             */
            stopMusic() {
                if (this.currentMusicSource) {
                    try {
                        this.currentMusicSource.stop();
                        this.currentMusicSource.disconnect(); // Desconecta o n√≥ para liberar recursos
                    } catch (error) {
                        console.error("Erro ao parar m√∫sica:", error);
                    }
                    this.currentMusicSource = null;
                }
            }

            /**
             * Define o volume da m√∫sica.
             * @param {number} volume - Volume (0.0 a 1.0).
             */
            setMusicVolume(volume) {
                this.musicGainNode.gain.value = volume;
            }

            /**
             * Define o volume dos efeitos sonoros.
             * @param {number} volume - Volume (0.0 a 1.0).
             */
            setSfxVolume(volume) {
                this.sfxGainNode.gain.value = volume;
            }
        }

        /**
         * @class AssetLoader
         * @description Gerencia o carregamento de todos os assets do jogo.
         */
        class AssetLoader {
            constructor() {
                if (AssetLoader.Instance) {
                    return AssetLoader.Instance;
                }
                AssetLoader.Instance = this;

                this.totalAssetsToLoad = 0;
                this.assetsLoadedCount = 0;
            }

            /**
             * Carrega todos os assets definidos no CONFIG.ASSET_PATHS.
             * @returns {Promise<void>}
             */
            async loadAllAssets() {
                const assetPromises = [];
                for (const [key, path] of Object.entries(CONFIG.ASSET_PATHS)) {
                    if (Array.isArray(path)) { // Se o caminho √© um array de frames (para anima√ß√µes)
                        this.totalAssetsToLoad += path.length;
                        const framePromises = path.map(framePath => this._loadImage(framePath));
                        assetPromises.push(Promise.all(framePromises).then(images => { CONFIG.ASSET_LOADED[key] = images; }));
                    } else if (typeof path === 'string' && (path.endsWith('.gif') || path.endsWith('.png') || path.endsWith('.jpg') || path.endsWith('.jpeg'))) {
                        this.totalAssetsToLoad++;
                        assetPromises.push(this._loadImage(path).then(img => { CONFIG.ASSET_LOADED[key] = img; }));
                    } else if (typeof path === 'string' && (path.endsWith('.mp3') || path.endsWith('.wav'))) {
                        this.totalAssetsToLoad++;
                        assetPromises.push(AudioManager.Instance.loadSound(key, path));
                    }
                }
                await Promise.all(assetPromises);
                console.log("Todos os assets carregados.");
            }

            /**
             * Carrega uma imagem e retorna o objeto Image.
             * @param {string} path - Caminho da imagem.
             * @returns {Promise<Image>}
             * @private
             */
            _loadImage(path) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = path;
                    img.onload = () => {
                        this.assetsLoadedCount++;
                        console.log(`Imagem carregada: ${path} (${this.assetsLoadedCount}/${this.totalAssetsToLoad})`);
                        resolve(img);
                    };
                    img.onerror = (e) => {
                        console.error(`Erro ao carregar imagem '${path}':`, e);
                        // Fallback para uma imagem transparente 1x1 em caso de erro
                        const placeholder = new Image();
                        placeholder.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='; 
                        this.assetsLoadedCount++;
                        resolve(placeholder); // Resolve mesmo com erro para n√£o travar o carregamento
                    };
                });
            }
        }


        // =================================================================================================
        // ===== 9. L√ìGICA DO JOGO (init, gameLoop, update, render, setupPhases) ===========================
        // =================================================================================================

        let GameManagerInstance;
        let UIManagerInstance;
        let AudioManagerInstance;
        let ObjectPoolerInstance;
        let AssetLoaderInstance;

        /**
         * Inicializa o jogo.
         */
        async function init() {
            // Obter o elemento game-world para injetar entidades DOM
            gameWorldElement = document.getElementById('game-world');

            // Inicializa as inst√¢ncias dos Singletons
            GameManagerInstance = new GameManager();
            UIManagerInstance = new UIManager();
            AudioManagerInstance = new AudioManager();
            ObjectPoolerInstance = new ObjectPooler();
            AssetLoaderInstance = new AssetLoader();

            // Detecta dispositivo e orienta√ß√£o
            detectDevice();
            
            // Canvas agora √© opcional, mas mantido para compatibilidade se precisar de drawing espec√≠fico
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas(); // Ajusta o tamanho do game-container e game-world
            window.addEventListener('resize', resizeCanvas);
            
            // Carrega assets (aguarda para continuar)
            await AssetLoader.Instance.loadAllAssets();
            
            // Inicializa pools de objetos ap√≥s assets carregados
            ObjectPooler.Instance.initializePools();

            // Inicializa cores CSS para uso no DOM e l√≥gica
            initGlobalColors();
            
            // Tenta carregar progresso salvo para preencher o menu
            const savedData = GameManager.Instance._loadProgress();
            if (savedData) {
                UIManager.Instance.elements.playerNameInput.value = savedData.playerName || ''; // CORRE√á√ÉO: UIManager.Instance
                UIManager.Instance.validateMainMenuInputs(); // Chamada inicial para validar o bot√£o // CORRE√á√ÉO: UIManager.Instance
            } else {
                AudioManager.Instance.playMusic('music_menu', true); // CORRE√á√ÉO: AudioManager.Instance
            }
            
            // Inicia o loop do jogo
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * O loop principal do jogo.
         * @param {DOMHighResTimeStamp} timestamp - Tempo atual em milissegundos.
         */
        function gameLoop(timestamp) {
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Limita o deltaTime para evitar "pulos" durante lags
            deltaTime = Math.min(deltaTime, CONFIG.DELTA_TIME_CAP);
            
            if (!gameState.gamePaused && gameState.gameStarted) {
                if (!gameState.inCutscene && !gameState.inDialog) {
                    update(deltaTime);
                }
                render(deltaTime);
            } else if (gameState.inMenu) {
                // N√£o precisa de renderMenu, pois o menu √© um elemento HTML est√°tico
            } else {
                render(deltaTime); // Renderiza mesmo pausado para UI, etc. (atualiza posi√ß√µes de elementos j√° criados)
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Atualiza a l√≥gica do jogo.
         * @param {number} deltaTime - Tempo decorrido (em ms).
         */
        function update(deltaTime) {
            // Atualiza o jogador
            if (gameState.player) {
                gameState.player.update(deltaTime);
            }

            // Atualiza inimigos
            enemies = enemies.filter(enemy => enemy.health.currentHealth > 0); // Remove inimigos mortos
            enemies.forEach(enemy => enemy.update(deltaTime));

            // Atualiza proj√©teis e part√≠culas (Object Pooling)
            ObjectPooler.Instance.getActiveObjects('darkShotProjectile').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('etherealOrbProjectile').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('enemyIceShot').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossSlash').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossIceOrb').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossPrison').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossDash').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('snowParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('jumpDustParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('landDustParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('hitSparkParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('deathExplosionParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('projectileTrailParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('umbraFuriaParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossIntroParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('dashIceParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('prisonActivateParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('xpGainParticle').forEach(p => p.update(deltaTime));


            // Atualiza espinhos que caem
            fallingSpikes.forEach(spike => spike.update(deltaTime));

            // L√≥gica de f√≠sica (separada para FixedUpdate)
            fixedUpdate(deltaTime);

            // Atualiza a c√¢mera
            updateCamera(deltaTime);

            // Verifica checkpoints
            checkpoints.forEach(cp => cp.checkCollisionWithPlayer());

            // Verifica colis√£o de espinhos com o jogador
            fallingSpikes.forEach((spike) => { 
                if (spike.checkCollisionWithPlayer()) {
                    // Implementar remo√ß√£o do spike ou reset se for um uso √∫nico ap√≥s colis√£o
                }
            });

            // Otimiza√ß√£o de part√≠culas (limita o n√∫mero total)
            _limitParticles();
            
            // Gera part√≠culas de neve (se estiver em uma fase normal e n√£o no menu)
            if (!gameState.inMenu && !gameState.gamePaused && GameManager.backgroundImageKey === null) {
                if (Math.random() < CONFIG.SNOW_SPAWN_RATE) {
                    EventManager.emit('add_particles', { type: 'snow', x: gameState.player.position.x + Math.random() * gameWorldElement.offsetWidth, y: -10 + gameState.cameraOffset.y, count: 1 });
                }
            }

            // Limpa inputs de toque √∫nicos
            if (gameState.player) {
                gameState.player.input.clearOneShotInputs();
            }
        }

        /**
         * Atualiza a l√≥gica de f√≠sica em intervalos fixos.
         * Separado do `update` para garantir consist√™ncia f√≠sica.
         * @param {number} deltaTime - Tempo decorrido (em ms).
         */
        function fixedUpdate(deltaTime) {
            // Atualiza o jogador
            if (gameState.player) {
                gameState.player.fixedUpdate(deltaTime);
            }

            // Atualiza inimigos
            enemies.forEach(enemy => enemy.fixedUpdate(deltaTime));
        }

        /**
         * Renderiza todos os elementos do jogo no DOM.
         * N√£o desenha no Canvas diretamente.
         * @param {number} deltaTime - Tempo decorrido (em ms).
         */
        function render(deltaTime) {
            // A posi√ß√£o do gameWorldElement √© ajustada para simular a c√¢mera
            gameWorldElement.style.transform = `translate(${-gameState.cameraOffset.x}px, ${-gameState.cameraOffset.y}px)`;
            
            // Renderiza o jogador e inimigos (atualiza as posi√ß√µes de seus elementos DOM)
            if (gameState.player) gameState.player.render();
            enemies.forEach(e => e.render());

            // Renderiza proj√©teis e part√≠culas (atualiza as posi√ß√µes de seus elementos DOM)
            ObjectPooler.Instance.getActiveObjects('darkShotProjectile').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('etherealOrbProjectile').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('enemyIceShot').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossSlash').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossIceOrb').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossPrison').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossDash').forEach(p => p.render());
            
            ObjectPooler.Instance.getActiveObjects('snowParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('jumpDustParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('landDustParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('hitSparkParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('deathExplosionParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('projectileTrailParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('umbraFuriaParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossIntroParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('dashIceParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('prisonActivateParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('xpGainParticle').forEach(p => p.render());

            // Renderiza plataformas e checkpoints (j√° que s√£o elementos DOM, a posi√ß√£o √© setada uma vez na cria√ß√£o e atualizada aqui pelo transform do gameWorldElement)
            platforms.forEach(p => p.render());
            fallingSpikes.forEach(s => s.render());
            checkpoints.forEach(cp => cp.render()); // Para exibir em DEBUG_MODE

            // Remove n√∫meros de dano/xp expirados do DOM.
            _removeExpiredDamageNumbers();

            if (window.DEBUG_MODE) {
                // Info de debug agora vai para o console, n√£o para o Canvas
                // Para info na tela, seria necess√°rio criar elementos DOM para isso
                renderDebugInfo(); // Chamada para mostrar o console.log com DEBUG INFO
            }
        }

        /**
         * Renderiza o plano de fundo.
         * Agora manipula o background-image do gameWorldElement.
         */
        function renderBackground() {
            if (GameManager.backgroundImageKey) {
                const imgAsset = CONFIG.ASSET_LOADED[GameManager.backgroundImageKey];
                if (imgAsset && imgAsset.src) { // Garante que a imagem foi carregada e tem src
                    gameWorldElement.style.backgroundImage = `url('${imgAsset.src}')`;
                    gameWorldElement.style.backgroundSize = 'cover';
                    gameWorldElement.style.backgroundPosition = 'center';
                } else {
                    console.warn(`Background asset not loaded or invalid: ${GameManager.backgroundImageKey}`);
                    gameWorldElement.style.backgroundImage = 'none'; // Fallback
                }
            } else {
                gameWorldElement.style.backgroundImage = 'none'; // Limpa imagem se n√£o for para ter
            }
            gameWorldElement.style.backgroundColor = 'var(--primary-dark)'; // Fallback para cor s√≥lida
            // Para parallax com DOM, manipular background-position ou criar divs para cada camada.
            // Aqui, mantemos simples com cor s√≥lida.
        }

        /**
         * Atualiza a posi√ß√£o da c√¢mera.
         * @param {number} deltaTime - Tempo decorrido (em ms).
         */
        function updateCamera(deltaTime) {
            if (gameState.fixedCamera) {
                gameState.cameraOffset.x = gameState.fixedCameraTarget.x;
                gameState.cameraOffset.y = gameState.fixedCameraTarget.y;
                return;
            }

            if (!gameState.player) return; // N√£o atualiza c√¢mera se o jogador n√£o existe

            // O tamanho do "viewport" do jogo √© o tamanho do game-container
            const viewportWidth = document.getElementById('game-container').offsetWidth;
            const viewportHeight = document.getElementById('game-container').offsetHeight;

            gameState.targetCameraOffset.x = gameState.player.position.x - viewportWidth / 2;
            gameState.targetCameraOffset.y = gameState.player.position.y - viewportHeight / 2;
            
            // Limita a c√¢mera aos limites do mundo
            gameState.targetCameraOffset.x = Math.max(0, Math.min(gameState.targetCameraOffset.x, CONFIG.WORLD_WIDTH - viewportWidth));
            gameState.targetCameraOffset.y = Math.max(0, Math.min(gameState.targetCameraOffset.y, CONFIG.WORLD_HEIGHT - viewportHeight)); // Usar 0 para Y para n√£o mostrar "acima do mundo"
            
            // Suaviza o movimento da c√¢mera
            gameState.cameraOffset.x += (gameState.targetCameraOffset.x - gameState.cameraOffset.x) * CONFIG.CAMERA_SMOOTHING;
            gameState.cameraOffset.y += (gameState.targetCameraOffset.y - gameState.cameraOffset.y) * CONFIG.CAMERA_SMOOTHING;
        }

        /**
         * Limita o n√∫mero de part√≠culas ativas.
         * @private
         */
        function _limitParticles() {
            const allParticles = ObjectPooler.Instance.getActiveObjects('snowParticle')
                .concat(ObjectPooler.Instance.getActiveObjects('jumpDustParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('landDustParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('hitSparkParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('deathExplosionParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('projectileTrailParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('umbraFuriaParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('bossIntroParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('dashIceParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('prisonActivateParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('xpGainParticle'));
            
            if (allParticles.length > CONFIG.MAX_PARTICLES) {
                // Remove as part√≠culas mais antigas (as primeiras da lista)
                for (let i = 0; i < allParticles.length - CONFIG.MAX_PARTICLES; i++) {
                    allParticles[i].deactivate();
                }
            }
        }

        /**
         * Remove n√∫meros de dano/XP expirados do DOM.
         * @private
         */
        function _removeExpiredDamageNumbers() {
            const existingNumbers = document.querySelectorAll('.damage-number, .xp-number'); // Query global
            const currentTime = performance.now();
            existingNumbers.forEach(number => {
                const startTime = parseFloat(number.dataset.startTime);
                const duration = parseFloat(number.dataset.duration);
                // Usar offsetTop e offsetLeft para verificar se est√° vis√≠vel
                const isOffscreen = number.offsetTop < -50 || number.offsetLeft < -50 || 
                                    number.offsetTop > window.innerHeight + 50 || number.offsetLeft > window.innerWidth + 50;

                if (currentTime - startTime >= duration || isOffscreen) {
                    if (number.parentNode) { // Verifica se ainda est√° no DOM
                        number.parentNode.removeChild(number);
                    }
                }
            });
        }


        // =================================================================================================
        // ===== 10. FUN√á√ïES UTILIT√ÅRIAS ===================================================================
        // =================================================================================================

        /**
         * Detecta o tipo de dispositivo (mobile/desktop).
         */
        function detectDevice() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      window.innerWidth <= 800 || 
                      'ontouchstart' in window;
            
            if (isMobile) {
                checkOrientation();
                window.addEventListener('orientationchange', () => {
                    setTimeout(checkOrientation, 100);
                });
                window.addEventListener('resize', checkOrientation);
            }
        }

        /**
         * Verifica a orienta√ß√£o do dispositivo m√≥vel.
         */
        function checkOrientation() {
            if (!isMobile) return;
            
            isLandscape = window.innerWidth > window.innerHeight;
            
            if (!isLandscape) {
                UIManager.Instance.elements.orientationWarning.style.display = 'flex'; // CORRE√á√ÉO: UIManager.Instance
                if (gameState.gameStarted && !gameState.gamePaused && !gameState.inMenu) {
                    GameManager.Instance.togglePause(true);
                }
            } else {
                UIManager.Instance.elements.orientationWarning.style.display = 'none'; // CORRE√á√ÉO: UIManager.Instance
                if (gameState.gameStarted && gameState.gamePaused && !gameState.inMenu && !gameState.inCutscene) {
                    GameManager.Instance.togglePause(false);
                }
            }
            UIManager.Instance.updateMobileControlsVisibility(isMobile, isLandscape); // CORRE√á√ÉO: UIManager.Instance
        }

        /**
         * Redimensiona o game-container para se ajustar ao viewport.
         * O game-world ser√° ajustado para o WORLD_WIDTH e WORLD_HEIGHT do jogo.
         */
        function resizeCanvas() { // Renomeado de resizeCanvas para melhor clareza no contexto DOM
            const gameContainer = document.getElementById('game-container');
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Mant√©m a propor√ß√£o do jogo (16:9, ou o que for definido por max-width/height no CSS)
            // Adapta o game-container para o viewport
            let scale = Math.min(viewportWidth / 1600, viewportHeight / 770);
            gameContainer.style.width = `${1600 * scale}px`;
            gameContainer.style.height = `${770 * scale}px`;
            gameContainer.style.transform = `scale(1)`; // Garante que n√£o haja escala externa

            // Ajusta o game-world para o tamanho total do mundo (para parallax)
            if (gameWorldElement) { // Verifica se o elemento j√° foi inicializado
                gameWorldElement.style.width = `${CONFIG.WORLD_WIDTH}px`;
                gameWorldElement.style.height = `${CONFIG.WORLD_HEIGHT}px`;
            }

            // Opcional: ajustar o canvas (se usado para efeitos)
            if (canvas) {
                canvas.width = 1600; // Ou o tamanho ideal para efeitos
                canvas.height = 770;
            }
            
            if (isMobile) {
                UIManager.Instance.updateMobileControlsVisibility(isMobile, isLandscape); // CORRE√á√ÉO: UIManager.Instance
            }
        }

        /**
         * Inicializa as vari√°veis de cor global a partir do CSS.
         */
        function initGlobalColors() {
            const rootStyle = getComputedStyle(document.documentElement);
            COLOR_HEALTH = rootStyle.getPropertyValue('--health-color').trim();
            COLOR_MANA = rootStyle.getPropertyValue('--mana-color').trim();
            COLOR_XP = rootStyle.getPropertyValue('--xp-color').trim();
            COLOR_ACCENT_FIRE = rootStyle.getPropertyValue('--accent-fire').trim();
            COLOR_ACCENT_GOLD = rootStyle.getPropertyValue('--accent-gold').trim();
            COLOR_ACCENT_BLUE = rootStyle.getPropertyValue('--accent-blue').trim();
            COLOR_ACCENT_ICE = rootStyle.getPropertyValue('--accent-ice').trim();
            COLOR_TEXT_LIGHT = rootStyle.getPropertyValue('--text-light').trim();
            COLOR_UMBRA = rootStyle.getPropertyValue('--umbra-color').trim();
            COLOR_PLAYER_COLOR = rootStyle.getPropertyValue('--player-color').trim(); 
            COLOR_SPIKE = rootStyle.getPropertyValue('--spike-color').trim();
        }

        /**
         * Exibe informa√ß√µes de debug no console.
         */
        function renderDebugInfo() {
            if (!window.DEBUG_MODE || !gameState.player) return;

            // Em um sistema DOM-based, infos de debug s√£o melhores no console ou em um overlay de UI espec√≠fico.
            console.groupCollapsed("DEBUG INFO (Pressione F12 para console)");
            console.log(`FPS: ${Math.round(1000 / (performance.now() - lastTime))}`);
            console.log(`Player Pos: (${Math.round(gameState.player.position.x)}, ${Math.round(gameState.player.position.y)})`);
            console.log(`Player Vel: (${Math.round(gameState.player.physics.velocity.x)}, ${Math.round(gameState.player.physics.velocity.y)})`);
            console.log(`Camera Offset: (${Math.round(gameState.cameraOffset.x)}, ${Math.round(gameState.cameraOffset.y)})`);
            console.log(`Enemies: ${enemies.length}`);
            console.log(`Active Particles: ${ObjectPooler.Instance.getActiveObjects('snowParticle').length + ObjectPooler.Instance.getActiveObjects('hitSparkParticle').length + ObjectPooler.Instance.getActiveObjects('deathExplosionParticle').length + ObjectPooler.Instance.getActiveObjects('projectileTrailParticle').length}`);
            console.log(`Active Projectiles: ${ObjectPooler.Instance.getActiveObjects('darkShotProjectile').length + ObjectPooler.Instance.getActiveObjects('enemyIceShot').length}`);
            console.log(`Grounded: ${gameState.player.physics.isGrounded}`);
            console.log(`Current State: ${gameState.player.currentState.constructor.name}`);
            console.groupEnd();
        }

        // Event listener para adicionar part√≠culas
        EventManager.subscribe('add_particles', (data) => {
            const particle = ObjectPooler.Instance.getFromPool(data.type + 'Particle', data);
            // Part√≠culas n√£o precisam ser adicionadas a uma lista global, pois ObjectPooler j√° as gerencia
        });

        // Event listener para spawnar proj√©teis
        EventManager.subscribe('spawn_projectile', (data) => {
            const projectile = ObjectPooler.Instance.getFromPool(data.type + 'Projectile', data);
            // Proj√©teis n√£o precisam ser adicionados a uma lista global, ObjectPooler j√° as gerencia
        });

        // Event listener para mostrar n√∫meros de dano/XP
        EventManager.subscribe('show_damage_number', (data) => {
            const damageNumberDiv = document.createElement('div');
            damageNumberDiv.className = data.isPlayerDamage ? 'damage-number' : 'xp-number'; 
            damageNumberDiv.textContent = data.value;
            // Posi√ß√£o ajustada para ser relativa ao elemento DOM do jogador
            damageNumberDiv.style.left = `${data.x}px`;
            damageNumberDiv.style.top = `${data.y}px`;
            
            // Adiciona metadados para controle de tempo pelo JS
            damageNumberDiv.dataset.startTime = performance.now();
            damageNumberDiv.dataset.duration = data.isPlayerDamage ? 1000 : 1500; // Dura√ß√£o da anima√ß√£o CSS

            gameWorldElement.appendChild(damageNumberDiv); // Adiciona ao game-world para que siga a c√¢mera
        });

        // Player XP e Level Up (integrado com EventBus)
        if (Player.prototype.gainXP === undefined) { // Garante que a fun√ß√£o s√≥ √© definida uma vez
            Player.prototype.gainXP = function(amount) {
                this.xp += amount;
                EventManager.emit('show_damage_number', {
                    value: `+${amount} XP`,
                    x: this.position.x + CONFIG.PLAYER_WIDTH / 2,
                    y: this.position.y - 10,
                    isPlayerDamage: false // N√£o √© dano
                });
                EventManager.emit('add_particles', { type: 'xpGain', x: this.position.x + CONFIG.PLAYER_WIDTH / 2, y: this.position.y + CONFIG.PLAYER_HEIGHT / 2, count: 8, color: COLOR_XP });

                if (this.xp >= this.nextLevelXP) {
                    this.levelUp();
                }
                EventManager.emit('xp_gained', { current: this.xp, max: this.nextLevelXP });
            };

            Player.prototype.levelUp = function() {
                this.level++;
                this.xp -= this.nextLevelXP;
                this.nextLevelXP = Math.floor(this.nextLevelXP * 1.8);
                
                // Buffs padr√£o ao level up (ajustar conforme Ben 10-ish)
                this.health.maxHealth += 10;
                this.health.heal(this.health.maxHealth);
                this.mana.maxMana += 15;
                this.mana.currentMana = this.mana.maxMana;
                this.damage += 3;
                this.baseSpeed += 0.2;
                this.currentSpeed = this.baseSpeed; // Garante que a velocidade atual tamb√©m seja atualizada

                EventManager.emit('sfx_play', 'sfx_level_up');
                EventManager.emit('screen_flash', { color: COLOR_XP, duration: 500 });
                EventManager.emit('add_particles', { type: 'umbraFuria', x: this.position.x + CONFIG.PLAYER_WIDTH / 2, y: this.position.y + CONFIG.PLAYER_HEIGHT / 2, count: 30 });
                EventManager.emit('player_level_up', { level: this.level, damage: this.damage }); // Notifica que o jogador subiu de n√≠vel.
            };

             // Adiciona propriedades de XP e N√≠vel no construtor do Player
             // (Esta √© uma forma de "monkey patch" o construtor para adicionar propriedades)
            const originalPlayerConstructor = Player;
            Player = function(...args) {
                originalPlayerConstructor.apply(this, args);
                this.level = 1;
                this.xp = 0;
                this.nextLevelXP = 100;
            };
            // Restaura o prototype para n√£o perder m√©todos da classe original
            Player.prototype = originalPlayerConstructor.prototype;
            Player.prototype.constructor = Player;
        }

        // Adiciona um m√©todo est√°tico para o Checkpoint para busca
        if (Checkpoint.findByName === undefined) {
            Checkpoint.findByName = function(checkpointsArray, name) {
                return checkpointsArray.find(cp => cp.name === name);
            };
        }


        // Define o modo de debug se a URL tiver #debug
        if (window.location.hash === '#debug') {
            window.DEBUG_MODE = true;
            console.log('Modo DEBUG ativado!');
        }


        // ===== INICIALIZA√á√ÉO FINAL =====
        // Evento DOMContentLoaded garante que todo o HTML foi carregado antes de inicializar o jogo
        window.addEventListener('DOMContentLoaded', init);

        // Event listener para salvar progresso antes de fechar a aba/navegador
        window.addEventListener('beforeunload', (e) => {
            if (gameState.gameStarted && !gameState.inMenu) {
                GameManager.Instance.saveProgress();
            }
        });

        // Event listener para pausar o jogo quando a aba/janela n√£o est√° ativa
        window.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.gameStarted && !gameState.inMenu && !gameState.gamePaused) {
                GameManager.Instance.togglePause(true);
            }
        });

        // Exposi√ß√£o global para debug (apenas em modo DEBUG)
        // Permite acessar objetos do jogo diretamente pelo console do navegador para depura√ß√£o.
        if (window.DEBUG_MODE) {
            window.gameState = gameState;
            window.CONFIG = CONFIG;
            window.enemies = enemies;
            window.platforms = platforms;
            window.fallingSpikes = fallingSpikes;
            window.GameManager = GameManager.Instance;
            window.UIManager = UIManager.Instance;
            window.AudioManager = AudioManager.Instance;
            window.ObjectPooler = ObjectPooler.Instance;
            window.EventManager = EventManager;

            // Comandos de debug para facilitar testes no console
            window.debugCommands = {
                // Ativa o "modo deus" para o jogador (vida e mana infinitas)
                godMode: () => {
                    if (gameState.player) {
                        gameState.player.health.maxHealth = 9999;
                        gameState.player.health.currentHealth = 9999;
                        gameState.player.mana.maxMana = 9999;
                        gameState.player.mana.currentMana = 9999;
                        UIManager.Instance.updateHealth({ current: 9999, max: 9999 });
                        UIManager.Instance.updateMana({ current: 9999, max: 9999 });
                        console.log("God Mode ATIVADO!");
                    } else {
                        console.log("Jogador n√£o encontrado para ativar God Mode.");
                    }
                },
                
                // For√ßa o level up do jogador
                levelUp: () => {
                    if (gameState.player) {
                        gameState.player.gainXP(gameState.player.nextLevelXP); // Adiciona XP suficiente para o pr√≥ximo n√≠vel
                        console.log(`Jogador subiu para o n√≠vel ${gameState.player.level}!`);
                    } else {
                        console.log("Jogador n√£o encontrado para level up.");
                    }
                },
                
                // Teleporta o jogador para uma coordenada espec√≠fica (√∫til para pular se√ß√µes)
                teleport: (x = 4800, y = 300) => { // Valores padr√£o para um ponto mais avan√ßado na fase 1
                    if (gameState.player) {
                        gameState.player.position.x = x;
                        gameState.player.position.y = y;
                        gameState.player.physics.velocity = { x: 0, y: 0 }; // Reseta velocidade para evitar quedas
                        console.log(`Jogador teleportado para (${x}, ${y}).`);
                    } else {
                        console.log("Jogador n√£o encontrado para teleporte.");
                    }
                },
                
                // Inicia diretamente a luta contra o boss (fase 3)
                spawnBoss: () => {
                    GameManager.Instance.loadPhase(3);
                    console.log("Iniciando luta contra o Boss!");
                },
                
                // Remove todos os inimigos da tela
                clearEnemies: () => {
                    enemies.forEach(enemy => enemy.destroy()); // Garante que os elementos DOM sejam removidos
                    enemies = [];
                    console.log("Todos os inimigos removidos.");
                },
                
                // Adiciona part√≠culas na posi√ß√£o do jogador para testes visuais
                addParticles: (type = 'snow', count = 50) => {
                    if (gameState.player) {
                        EventManager.emit('add_particles', { 
                            type: type, 
                            x: gameState.player.position.x + CONFIG.PLAYER_WIDTH / 2, 
                            y: gameState.player.position.y + CONFIG.PLAYER_HEIGHT / 2, 
                            count: count 
                        });
                        console.log(`Adicionadas ${count} part√≠culas do tipo '${type}'.`);
                    } else {
                        console.log("Jogador n√£o encontrado para adicionar part√≠culas.");
                    }
                },

                // Simula o uso de uma habilidade pelo teclado (para testes)
                useAbilityDebug: (key) => {
                    if (gameState.player && gameState.player.abilities[key]) {
                        gameState.player.abilities[key].activate();
                        console.log(`Tentando ativar habilidade '${key}'.`);
                    } else {
                        console.log(`Habilidade '${key}' n√£o encontrada ou jogador ausente.`);
                    }
                }
            };
        }
    </script>
</body>
</html>