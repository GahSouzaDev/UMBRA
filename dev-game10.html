<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tupãry: O Reino Congelado - Refatorado (DOM)</title>
    <style>
        /* ===== VARIÁVEIS CSS ===== */
        :root {
            --primary-dark: #000000;
            --primary-medium: #0a0a0a;
            --primary-light: #1a1a1a;
            --accent-gold: #d4af37;
            --accent-gold-light: #f5d76e;
            --accent-blue: #3a86ff;
            --accent-ice: #90e0ef;
            --accent-fire: #ff6b6b;
            --accent-nature: #52b788;
            --text-light: #f0f0f0;
            --text-gray: #aaaaaa;
            --health-color: var(--accent-fire);
            --mana-color: var(--accent-blue);
            --xp-color: var(--accent-gold);
            --shadow-dark: rgba(0, 0, 0, 0.8);
            --spike-color: #666666;
            --umbra-color: #7b0099; /* Nova cor para Atirador(a) de Umbra */
            --player-color: #4CAF50; /* Cor para o Escolhido (Ben 10-ish) */
        }

        /* ===== RESET E BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* CORREÇÃO CRÍTICA: Permite seleção e digitação em campos de input */
        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }

        body {
            background: var(--primary-dark);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* ===== CONTAINER PRINCIPAL DO JOGO ===== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1600px;
            max-height: 770px;
            overflow: hidden;
            border: 3px solid var(--accent-gold);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4);
            background: linear-gradient(to bottom, #0f1419, #1a1a2e);
        }

        /* O Canvas agora é opcional, pode ser usado para efeitos seletivos ou removido */
        #game-canvas {
            display: none; /* Desabilitado por padrão no rendering DOM */
        }

        /* Container do Mundo do Jogo (será movido pelo JS para parallax e camera) */
        #game-world {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%; /* Será ajustado para o WORLD_WIDTH pelo JS */
            height: 100%;
            transform-origin: top left;
            z-index: 0; /* Abaixo da UI */
            /* Aqui pode ter um background padrão que será substituído por assets carregados */
            background-color: #1a1a1a;
            overflow: hidden; /* Garante que entidades fora dos limites não apareçam */
        }

        /* Sprites de Entidades (Player, Enemies, Projectiles) */
        .game-entity {
            position: absolute;
            transform-origin: center;
            image-rendering: pixelated; /* Para pixel art */
            overflow: hidden; /* Esconde partes da imagem se o sprite for maior que o elemento */
        }
        /* Para sprites com Imagem */
        .game-entity img {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Garante que a imagem se ajuste sem cortar */
        }

        /* Sprites Específicos */
        .player-sprite {
            /* Definir tamanho inicial no JS */
            background-color: var(--player-color); /* Fallback */
        }

        .enemy-sprite {
            background-color: #78909c; /* Fallback */
        }

        .projectile-sprite {
            background-color: var(--umbra-color); /* Fallback */
            border-radius: 50%; /* Para orbes */
        }

        /* Plataformas */
        .platform-entity {
            position: absolute;
            background-color: #4a4a4a; /* Cor padrão */
            border: 2px solid rgba(0, 0, 0, 0.5);
            border-radius: 4px;
        }
        .platform-entity.slippery {
            background: linear-gradient(to bottom, var(--accent-ice), #bbdefb, #90caf9);
        }
        .platform-entity.spike {
            background-color: transparent;
            /* Espinhos serão desenhados com clip-path */
        }
        .falling-spike-entity {
            background-color: var(--spike-color);
            clip-path: polygon(0% 100%, 50% 0%, 100% 100%); /* Forma de triângulo */
        }
        
        /* Barra de vida para inimigos (elementos DOM) */
        .entity-health-bar {
            position: absolute;
            width: 60px;
            height: 6px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #fff;
            border-radius: 3px;
            overflow: hidden;
            /* transform: translateX(-50%); /* Centraliza - ajustado pelo JS para o pai */
            z-index: 10;
        }
        .entity-health-fill {
            height: 100%;
            width: 100%; /* Será ajustado por JS */
            background: linear-gradient(90deg, #4caf50, #8bc34a);
        }
        /* Checkpoint visual apenas para debug */
        .checkpoint-entity {
            background-color: rgba(0, 255, 0, 0.2);
            border: 1px dashed green;
            z-index: -1; /* Abaixo das entidades de jogo */
        }

        /* ===== AVISO DE ORIENTAÇÃO MOBILE ===== */
        .orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--primary-dark);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }

        .orientation-warning h2 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            font-size: 24px;
        }

        .orientation-warning p {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
        }

        .rotate-icon {
            font-size: 48px;
            margin: 20px 0;
            animation: rotatePhone 2s infinite;
        }

        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        /* ===== TELA DE INÍCIO / MENU PRINCIPAL ===== */
        .main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.95) 100%);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-title {
            font-size: 42px;
            font-weight: bold;
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 20px;
            color: var(--accent-ice);
            text-align: center;
            margin-bottom: 40px;
            font-style: italic;
        }

        .character-selection {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            width: 100%;
            max-width: 700px;
        }

        .character-selection h3 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            text-align: center;
            font-size: 20px;
        }

        .name-input-group {
            margin-bottom: 25px;
            text-align: center;
        }

        .name-input-group label {
            display: block;
            color: var(--text-light);
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 18px;
        }

        .name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--accent-blue);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
            text-align: center;
        }

        .name-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold-light);
        }

        .start-game-btn {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
        }

        .start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.5);
        }

        .start-game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* ===== UI LAYER ===== */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Allows clicks to pass through by default */
        }

        /* ===== BARRAS DE STATUS ===== */
        .status-bars {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
        }

        .bar-container {
            width: 200px;
            height: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--text-light);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
        }

        .mana-fill {
            background: linear-gradient(90deg, #4dabf7, #3366ff);
        }

        .xp-fill {
            background: linear-gradient(90deg, var(--accent-gold-light), var(--accent-gold));
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        /* ===== STATS DO JOGADOR ===== */
        .player-stats {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 14px;
            text-align: right;
            min-width: 150px;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-line:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: var(--accent-ice);
            font-weight: bold;
        }

        .stat-value {
            color: var(--accent-gold);
            font-weight: bold;
        }

        /* ===== SISTEMA DE HABILIDADES (Desktop & Mobile) ===== */
        .abilities-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 12px;
            pointer-events: auto; /* Permite interação */
        }

        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
            border: 3px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .ability-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        .ability-btn:active {
            transform: scale(0.95);
        }

        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .ability-btn.cooldown:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(0, 0, 0, 0.8) 0deg);
            transition: background 0.1s linear;
        }

        .ability-tooltip {
            position: absolute;
            bottom: 70px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--accent-blue);
            border-radius: 8px;
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            width: 200px;
            text-align: center;
            z-index: 10;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        .ability-btn:hover .ability-tooltip {
            opacity: 1;
        }

        .tooltip-name {
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip-description {
            color: var(--text-light);
            font-size: 12px;
            line-height: 1.3;
            margin-bottom: 5px;
        }

        .tooltip-cost {
            color: var(--mana-color);
            font-size: 11px;
            font-style: italic;
        }

        /* ===== CONTROLES MOBILE (D-pad e Ações) ===== */
        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 5px;
            pointer-events: auto;
            z-index: 5;
            align-items: center;
        }
        .mobile-dpad {
            grid-column: 1 / 2;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 120px;
            height: 120px;
            position: relative;
            margin-left: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .dpad-btn {
            background: var(--primary-medium);
            border: 2px solid var(--accent-blue);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.1s;
            border-radius: 5px;
        }
        .dpad-btn:active {
            background: var(--accent-blue);
            transform: scale(0.95);
        }

        .dpad-up { grid-area: 1 / 2 / 2 / 3; }
        .dpad-left { grid-area: 2 / 1 / 3 / 2; }
        .dpad-center { grid-area: 2 / 2 / 3 / 3; opacity: 0.3; pointer-events: none;}
        .dpad-right { grid-area: 2 / 3 / 3 / 4; }
        .dpad-down { grid-area: 3 / 2 / 4 / 3; }

        /* ===== SISTEMA DE DIÁLOGO ===== */
        .dialog-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(10, 10, 10, 0.9));
            border: 3px solid var(--accent-blue);
            border-radius: 15px;
            padding: 20px;
            display: none;
            pointer-events: none; /* Controlled by JS now */
            z-index: 20;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .dialog-speaker {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dialog-text {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .dialog-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dialog-option {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(255, 107, 107, 0.2));
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-light);
            font-weight: bold;
        }

        .dialog-option:hover {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4), rgba(255, 107, 107, 0.4));
            transform: translateX(5px);
        }

        .dialog-option:active {
            transform: translateX(5px) scale(0.98);
        }

        /* ===== CUTSCENES ===== */
        .cinematic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            z-index: 30;
            display: none; /* Controlled by JS now */
            pointer-events: none; /* Controlled by JS now */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .cinematic-overlay img.cutscene-gif {
            display: none; /* Inicia oculto, será 'block' quando src é definido */
            max-width: 80%;
            max-height: 40vh;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            object-fit: contain; /* Garante que a imagem se ajuste sem cortar */
        }

        .cinematic-text {
            font-size: 20px;
            text-align: center;
            max-width: 80%;
            margin-bottom: 30px;
            color: var(--text-light);
            line-height: 1.6;
            opacity: 0;
            animation: fadeInText 3s forwards;
        }

        .cinematic-title {
            font-size: 32px;
            color: var(--accent-gold);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .skip-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto; /* Always clickable if parent allows */
            transition: all 0.3s;
            font-weight: bold;
        }

        .skip-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
        }

        /* ===== PAUSE MENU ===== */
        .pause-btn {
            position: absolute;
            top: 15px;
            right: 180px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-size: 16px;
        }

        .pause-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: scale(1.1);
        }

        .pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 40;
            display: none; /* Controlled by JS now */
            pointer-events: none; /* Controlled by JS now */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .pause-title {
            font-size: 36px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-option {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 200px;
        }

        .menu-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        /* ===== LEVEL UP (COM ESCOLHAS) ===== */
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            border: 3px solid var(--accent-gold);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            z-index: 35;
            display: none; /* Controlled by JS now */
            pointer-events: none; /* Controlled by JS now */
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .level-up-title {
            font-size: 28px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .level-up-subtitle {
            font-size: 16px;
            color: var(--text-light);
            margin-bottom: 25px;
        }

        .upgrade-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .upgrade-option {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: left;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .upgrade-option:hover {
            background: rgba(0, 0, 0, 0.6);
            transform: translateX(5px);
            box-shadow: 0 6px 15px rgba(212, 175, 55, 0.5);
        }

        .upgrade-name {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .upgrade-description {
            color: var(--text-light);
            font-size: 14px;
            line-height: 1.3;
        }

        /* ===== CHECKPOINT SYSTEM ===== */
        .checkpoint-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 25;
            display: none;
            animation: checkpointPulse 2s ease-in-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
        }

        @keyframes checkpointPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }

        .checkpoint-text {
            color: var(--accent-blue);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .checkpoint-description {
            color: var(--text-light);
            font-size: 14px;
        }

        /* ===== ANIMAÇÕES GERAIS ===== */
        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes levelUpAnimation {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* ===== EFEITOS ESPECIAIS ===== */
        .screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 15;
            opacity: 0;
            pointer-events: none;
        }

        .screen-flash.active {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .boss-health-bar {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-fire);
            border-radius: 10px;
            display: none; /* Controlled by JS */
            overflow: hidden;
            z-index: 10;
            box-shadow: 0 4px 20px rgba(255, 107, 107, 0.5);
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
            transition: width 0.5s ease;
            position: relative;
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        .boss-name {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--accent-fire);
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none; /* Controlled by JS */
            z-index: 10;
        }

        /* ===== PARTÍCULAS E NÚMEROS ===== */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .damage-number, .xp-number {
            position: absolute;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
            animation: damageNumber 1s ease-out forwards;
        }
        .damage-number { color: var(--accent-fire); }
        .xp-number { color: var(--xp-color); animation: xpNumber 1.5s ease-out forwards; }

        @keyframes damageNumber {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
        }

        @keyframes xpNumber {
            0% { opacity: 1; transform: translateY(0) scale(0.8); }
            100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
        }

        /* ===== RESPONSIVIDADE ===== */
        @media (max-width: 800px) {
            #game-container {
                width: 100vw;
                height: 100vh;
                max-width: none;
                max-height: none;
                border: none;
                border-radius: 0;
            }

            .main-menu {
                padding: 10px;
            }

            .game-title {
                font-size: 36px;
            }

            .game-subtitle {
                font-size: 18px;
                margin-bottom: 20px;
            }

            .character-selection {
                padding: 15px;
                margin-bottom: 15px;
            }

            /* Habilidades e controles móveis */
            .abilities-container {
                display: flex;
                bottom: 10px;
                right: 10px;
                gap: 8px;
            }

            .mobile-controls {
                display: grid;
            }

            .status-bars {
                top: 10px;
                left: 10px;
            }

            .bar-container {
                width: 150px;
                height: 12px;
            }

            .player-stats {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 12px;
                min-width: 120px;
            }

            .pause-btn {
                top: 10px;
                right: 140px;
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .dialog-container {
                width: 95%;
                padding: 15px;
                bottom: 15px;
            }

            .dialog-text {
                font-size: 14px;
                min-height: 50px;
            }

            .cinematic-text {
                font-size: 16px;
                max-width: 90%;
            }

            .cinematic-title {
                font-size: 24px;
            }

            .skip-btn {
                bottom: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 14px;
            }

            .level-up {
                min-width: 90%;
                padding: 20px;
            }

            .upgrade-option {
                padding: 12px;
            }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            .status-bars {
                top: 5px;
                left: 5px;
            }

            .bar-container {
                width: 120px;
                height: 10px;
            }

            .player-stats {
                top: 5px;
                right: 5px;
                padding: 5px 8px;
                font-size: 10px;
                min-width: 100px;
            }

            .mobile-dpad {
                bottom: 10px;
                left: 10px;
                width: 100px;
                height: 100px;
                margin-left: 10px;
            }

            .abilities-container {
                bottom: 10px;
                right: 10px;
                gap: 5px;
            }
            .ability-btn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- Aviso de Orientação Mobile -->
    <div class="orientation-warning" id="orientation-warning">
        <div class="rotate-icon">📱</div>
        <h2>Vire o Dispositivo</h2>
        <p>Para uma melhor experiência de jogo, por favor vire seu dispositivo para o modo paisagem (horizontal).</p>
    </div>

    <!-- Container Principal do Jogo -->
    <div id="game-container">
        <!-- Tela de Início / Menu Principal -->
        <div class="main-menu" id="main-menu">
            <h1 class="game-title">TUPÃRY</h1>
            <p class="game-subtitle">O Reino Congelado</p>
            
            <div class="character-selection">
                <h3>Desperte, Escolhido! Diga-me seu nome:</h3>
                <div class="name-input-group">
                    <label for="player-name">Nome do Escolhido:</label>
                    <input type="text" id="player-name" class="name-input" placeholder="Seu nome, para que o destino o chame..." maxlength="20">
                </div>
            </div>
            <button class="start-game-btn" id="start-game-btn" disabled>Iniciar Jornada</button>
        </div>

        <!-- game-world: Container para os elementos do jogo (personagens, plataformas, etc.) -->
        <div id="game-world">
            <!-- Os elementos do jogo serão injetados aqui pelo JavaScript -->
        </div>

        <!-- Canvas do Jogo (Opcional, para efeitos que se beneficiem do Canvas, mas não para entidades principais) -->
        <canvas id="game-canvas"></canvas>
        
        <!-- Flash de Tela -->
        <div class="screen-flash" id="screen-flash"></div>
        
        <!-- Container de Partículas (para DOM-based particles) -->
        <div class="particle-container" id="particle-container"></div>

        <!-- UI Layer -->
        <div class="ui-layer">
            <!-- Barras de Status -->
            <div class="status-bars">
                <div class="status-bar">
                    <div class="status-icon">❤️</div>
                    <div class="bar-container">
                        <div class="bar-fill health-fill" id="health-fill"></div>
                        <div class="bar-text" id="health-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">💙</div>
                    <div class="bar-container">
                        <div class="bar-fill mana-fill" id="mana-fill"></div>
                        <div class="bar-text" id="mana-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">⭐</div>
                    <div class="bar-container">
                        <div class="bar-fill xp-fill" id="xp-fill"></div>
                        <div class="bar-text" id="xp-text">0/100</div>
                    </div>
                </div>
            </div>
            
            <!-- Stats do Jogador -->
            <div class="player-stats" id="player-stats">
                <div class="stat-line">
                    <span class="stat-label">Nível:</span>
                    <span class="stat-value" id="player-level">1</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Classe:</span>
                    <span class="stat-value" id="player-class">Escolhido</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Dano:</span>
                    <span class="stat-value" id="player-damage">15</span>
                </div>
            </div>
            
            <!-- Barra de Vida do Boss -->
            <div class="boss-name" id="boss-name">TAREK, O GUERREIRO</div>
            <div class="boss-health-bar" id="boss-health-bar">
                <div class="boss-health-fill" id="boss-health-fill"></div>
            </div>
            
            <!-- Habilidades (Desktop & Mobile) -->
            <div class="abilities-container" id="abilities-container">
                <div class="ability-btn" id="ability-u" data-key="U">
                    U
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-u-name">Tiro Sombrio</div>
                        <div class="tooltip-description" id="tooltip-u-desc">Dispara um projétil de energia sombria.</div>
                        <div class="tooltip-cost" id="tooltip-u-cost">Custo: 0 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-i" data-key="I">
                    I
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-i-name">Sombra Ágil</div>
                        <div class="tooltip-description" id="tooltip-i-desc">Deslocamento rápido que atravessa inimigos.</div>
                        <div class="tooltip-cost" id="tooltip-i-cost">Custo: 25 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-o" data-key="O">
                    O
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-o-name">Orbe Etéreo</div>
                        <div class="tooltip-description" id="tooltip-o-desc">Lança um orbe de energia sombria que perfura.</div>
                        <div class="tooltip-cost" id="tooltip-o-cost">Custo: 35 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-p" data-key="P">
                    P
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-p-name">Fúria de Umbra</div>
                        <div class="tooltip-description" id="tooltip-p-desc">Canaliza a energia de Umbra para amplificar poder.</div>
                        <div class="tooltip-cost" id="tooltip-p-cost">Custo: 50 Mana</div>
                    </div>
                </div>
            </div>
            
            <!-- Botão de Pausa -->
            <div class="pause-btn" id="pause-btn">⏸️</div>
            
            <!-- Controles Mobile (D-pad e Ações) -->
            <div class="mobile-controls" id="mobile-controls">
                <div class="mobile-dpad">
                    <div class="dpad-btn dpad-up" id="mobile-up">▲</div>
                    <div class="dpad-btn dpad-left" id="mobile-left">◀</div>
                    <div class="dpad-btn dpad-center"></div>
                    <div class="dpad-btn dpad-right" id="mobile-right">▶</div>
                    <div class="dpad-btn dpad-down" id="mobile-down">▼</div>
                </div>
            </div>
            
            <!-- Sistema de Diálogo -->
            <div class="dialog-container" id="dialog-container">
                <div class="dialog-speaker" id="dialog-speaker"></div>
                <div class="dialog-text" id="dialog-text"></div>
                <div class="dialog-options" id="dialog-options"></div>
            </div>
            
            <!-- Overlay de Cutscene -->
            <div class="cinematic-overlay" id="cinematic-overlay">
                <div class="cinematic-title" id="cinematic-title"></div>
                <img id="cutscene-gif" class="cutscene-gif" src="" alt="Cena Animada">
                <div class="cinematic-text" id="cinematic-text"></div>
                <button class="skip-btn" id="skip-btn">Próximo</button>
            </div>
            
            <!-- Menu de Pausa -->
            <div class="pause-menu" id="pause-menu">
                <h2 class="pause-title">JOGO PAUSADO</h2>
                <button class="menu-option" id="resume-btn">Continuar</button>
                <button class="menu-option" id="restart-btn">Reiniciar Checkpoint</button>
                <button class="menu-option" id="save-btn">Salvar Progresso</button>
                <button class="menu-option" id="exit-btn">Voltar ao Menu</button>
            </div>
            
            <!-- Sistema de Level Up (Com Escolhas) -->
            <div class="level-up" id="level-up">
                <h2 class="level-up-title">NÍVEL AUMENTADO!</h2>
                <p class="level-up-subtitle">Escolha uma melhoria para fortalecer seu poder:</p>
                <div class="upgrade-options">
                    <div class="upgrade-option" data-upgrade="health">
                        <div class="upgrade-name">+ Vitalidade Aprimorada</div>
                        <div class="upgrade-description">Aumenta sua vida máxima em 25 pontos e restaura completamente sua saúde.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="mana">
                        <div class="upgrade-name">+ Reserva Mística</div>
                        <div class="upgrade-description">Aumenta sua mana máxima em 35 pontos e acelera a regeneração em 50%.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="damage">
                        <div class="upgrade-name">+ Poder Destrutivo</div>
                        <div class="upgrade-description">Aumenta o dano de todas suas habilidades em 8 pontos permanentemente.</div>
                    </div>
                    <div class="upgrade-option" data-upgrade="speed">
                        <div class="upgrade-name">+ Agilidade de Umbra</div>
                        <div class="upgrade-description">Aumenta velocidade de movimento em 20% e reduz cooldowns em 15%.</div>
                    </div>
                </div>
            </div>
            
            <!-- Notificação de Checkpoint -->
            <div class="checkpoint-notification" id="checkpoint-notification">
                <div class="checkpoint-text">CHECKPOINT SALVO</div>
                <div class="checkpoint-description">Seu progresso foi salvo automaticamente</div>
            </div>
        </div>
    </div>

    <script>
        /**
         * =================================================================================================
         * ARQUITETURA DO JOGO E APLICAÇÃO DOS DESIGN PATTERNS
         * =================================================================================================
         *
         * Este jogo foi refatorado para utilizar os seguintes Design Patterns:
         *
         * 1.  State Pattern:
         *     - O jogador e os inimigos agora possuem um `currentState` que gerencia seu comportamento
         *       atual (ex: `PlayerIdleState`, `PlayerWalkState`, `EnemyPatrolState`).
         *     - Cada estado é uma classe separada com métodos `onEnter()`, `onUpdate()`, `onFixedUpdate()`,
         *       e `onExit()`.
         *     - A lógica para mudar de um estado para outro é encapsulada dentro dos próprios estados ou
         *       no objeto principal (Player/Enemy), usando um método `transitionToState()`.
         *     - Benefícios: Facilita a adição de novos comportamentos, evita "switch case hell",
         *       melhora a legibilidade e manutenção.
         *
         * 2.  Component Pattern (Simulado em JavaScript):
         *     - Embora não haja um motor de jogo como Unity com componentes nativos, simulamos o padrão
         *       separando responsabilidades em objetos/classes menores que são "compostos" pelo objeto principal.
         *     - Ex: `Player` agora tem um `PhysicsComponent` (para lidar com movimento e colisão),
         *       um `HealthComponent`, um `ManaComponent`, um `AnimationComponent` e um `InputComponent`.
         *     - Em vez de um único objeto `player` fazendo tudo, ele delega tarefas para esses "componentes".
         *     - Benefícios: Modularidade, reusabilidade (ex: `HealthComponent` pode ser usado por Player e inimigos),
         *       facilita a manutenção e teste de partes específicas do código.
         *
         * 3.  Observer Pattern:
         *     - Implementado via um `EventBus` global.
         *     - Eventos como `player_damaged`, `xp_gained`, `level_up`, `ability_used` são "emitidos".
         *     - Elementos da UI (barras de status), sistema de áudio, etc., "assinam" esses eventos
         *       para reagir a eles sem precisar de referências diretas ao objeto que os emitiu.
         *     - Benefícios: Desacoplamento forte entre emissores e receptores de eventos, flexibilidade,
         *       facilita a adição de novas funcionalidades que precisam reagir a eventos existentes.
         *
         * 4.  Object Pooling:
         *     - Implementado com uma classe `ObjectPooler`.
         *     - Utilizado para objetos que são criados e destruídos frequentemente, como projéteis de habilidades,
         *       partículas de efeitos visuais e, opcionalmente, inimigos.
         *     - Em vez de `new` e `delete` constantes, objetos são "emprestados" da pool e retornados após o uso,
         *       apenas sendo desativados e reativados.
         *     - Benefícios: Reduz o lixo da memória (garbage collection), otimiza a performance (especialmente em mobile),
         *       evita picos de CPU devido à criação/destruição de objetos.
         *
         * =================================================================================================
         */

        /**
         * =================================================================================================
         * ESTRUTURA GERAL DO JOGO
         * =================================================================================================
         *
         * 1.  Variáveis Globais e Configurações (CONFIG, gameState, COLOR_VARS)
         * 2.  EventBus (Observer Pattern)
         * 3.  Classes de Componentes (PlayerInput, HealthComponent, ManaComponent, PhysicsComponent, AnimationComponent)
         * 4.  Classes de Estados (PlayerState, PlayerIdleState, PlayerWalkState, etc.)
         * 5.  Classes de Entidades do Jogo (Player, Enemy, Projectile, Particle, Platform) - Composição dos Componentes
         * 6.  ObjectPooler (Object Pooling Pattern)
         * 7.  Classes de Habilidades (PlayerAbility, DarkShotAbility, etc.)
         * 8.  Gerenciadores Globais (GameManager, UIManager, AudioManager, AssetLoader)
         * 9.  Lógica do Jogo (init, gameLoop, update, render, setupPhases)
         * 10. Funções Utilitárias (flashScreen, screenShake, save/load cookies, etc.)
         *
         * =================================================================================================
         */


        // ===== 1. VARIÁVEIS GLOBAIS E CONFIGURAÇÕES =====
        const CONFIG = {
            // Física do jogo
            GRAVITY: 0.6,
            PLAYER_BASE_SPEED: 4,
            JUMP_FORCE: 14,
            PLAYER_WIDTH: 40,
            PLAYER_HEIGHT: 80,
            CROUCH_HEIGHT: 40,
            
            // Mundo
            WORLD_WIDTH: 5000,
            WORLD_HEIGHT: 450,
            CAMERA_SMOOTHING: 0.08,
            
            // Combate
            DAMAGE_FLASH_DURATION: 200,
            INVINCIBILITY_DURATION: 1000,
            
            // Regeneração
            MANA_REGEN_RATE: 1.5,
            HEALTH_REGEN_RATE: 0.05,
            
            // Partículas
            MAX_PARTICLES: 200, // Controlado pelo Object Pooling
            SNOW_SPAWN_RATE: 0.15,
            
            // Performance
            TARGET_FPS: 60,
            DELTA_TIME_CAP: 32, // Limite para deltaTime para evitar pulos em lags extremos

            // Habilidades do Escolhido
            UMBRA_FURY_DURATION: 7000,
            UMBRA_FURY_DAMAGE_BOOST: 1.5,
            UMBRA_FURY_SPEED_BOOST: 1.3,
            UMBRA_FURY_DAMAGE_REDUCTION: 0.5,

            // CAMINHOS DE RECURSOS (Imagens e Áudios)
            // IMPORTANTE: Para animações de sprites (personagens, inimigos),
            // os caminhos devem apontar para ARRAYS DE CAMINHOS DE IMAGENS (quadros/frames).
            // Ex: player_idle: ['path/to/frame0.png', 'path/to/frame1.png', ...]
            // Se for um único GIF (string) para um sprite animado, o AssetLoader ainda carregará
            // ele como um objeto Image, mas o AnimationManager só poderá usar o primeiro frame,
            // pois o DOM não anima GIFs como sprites (exceto o <img> de cutscene).
            // VOCÊ PRECISA FORNECER ESSES ARQUIVOS NAS PASTAS CORRETAS.
            ASSET_PATHS: {
                // Exemplo de como você deve estruturar seus assets para animação de sprites:
                // Crie subpastas para os frames PNGs extraídos dos seus GIFs.
                // player_idle: [
                //     'assets/personagens/Escolhido/idle/escolhido-parado01-frame0.png',
                //     'assets/personagens/Escolhido/idle/escolhido-parado01-frame1.png',
                //     'assets/personagens/Escolhido/idle/escolhido-parado01-frame2.png',
                // ],
                // Se você não fornecer arrays, apenas o primeiro frame do GIF será usado como estático.
                player_idle: 'assets/personagens/Escolhido/gifs/escolhido-parado01.gif', 
                player_walk: 'assets/personagens/Escolhido/gifs/escolhido-andando01.gif', 
                player_jump: 'assets/personagens/Escolhido/gifs/escolhido-salto01.gif', 
                player_crouch: 'assets/personagens/Escolhido/gifs/escolhido-abaixar.gif', 
                player_attack_u: 'assets/personagens/Escolhido/gifs/escolhido-ataque-u.gif', 
                player_attack_i: 'assets/personagens/Escolhido/gifs/escolhido-ataque-i.gif', 
                player_attack_o: 'assets/personagens/Escolhido/gifs/escolhido-ataque-o.gif', 
                player_ultimate: 'assets/personagens/Escolhido/gifs/escolhido-ultimate.gif', 
                player_damage: 'assets/personagens/Escolhido/gifs/escolhido-dano.gif', 

                sentinel_sprite: 'assets/inimigos/sentinela.gif', 
                tarek_sprite: 'assets/bosses/tarek.gif', 
                tarek_background: 'assets/fundos/gelo/muralhas-gelo.png', // Exemplo de imagem estática

                projectile_i: 'assets/sprites/effects/projectile_i.gif', 
                explosion_o: 'assets/sprites/effects/explosion_o.gif', 
                tarek_ice_orb: 'assets/sprites/effects/tarek_ice_orb.gif', 
                tarek_prison: 'assets/sprites/effects/tarek_prison.gif', 

                // Cutscene (pode ser GIF animado porque é um elemento <img> HTML)
                cutscene_gif_1: 'assets/animacoes/AislinsVsFayra.gif', 

                // Áudios - VERIFIQUE SE ESTÃO NA PASTA CORRETA E SÃO MP3s VÁLIDOS!
                music_menu: 'assets/audio/music/menu.mp3',
                music_platforming: 'assets/audio/music/platforming.mp3',
                music_boss_tarek: 'assets/audio/music/tarek_boss.mp3',
                sfx_jump: 'assets/audio/sfx/jump.mp3',
                sfx_attack_u: 'assets/audio/sfx/attack_u.mp3',
                sfx_ability_i: 'assets/audio/sfx/ability_i.mp3',
                sfx_ability_o: 'assets/audio/sfx/ability_o.mp3',
                sfx_ability_p: 'assets/audio/sfx/ability_p.mp3',
                sfx_damage_player: 'assets/audio/sfx/damage_player.mp3',
                sfx_damage_enemy: 'assets/audio/sfx/damage_enemy.mp3',
                sfx_level_up: 'assets/audio/sfx/level_up.mp3',
                sfx_boss_roar: 'assets/audio/sfx/boss_roar.mp3',
            },
            // Este objeto armazenará os recursos carregados (Image e AudioBuffer)
            ASSET_LOADED: {}
        };

        let gameState = {
            playerName: '',
            player: null, // Referência à instância do Player
            currentPhase: 0,
            currentCheckpoint: 'start',
            
            gamePaused: false,
            inDialog: false,
            inCutscene: false,
            inMenu: true,
            gameStarted: false,
            
            cameraOffset: { x: 0, y: 0 },
            targetCameraOffset: { x: 0, y: 0 },
            
            // Boss fight
            inBossFight: false,
            bossDefeated: false,
            inTarekEncounter: false,
            tarekDialogStep: 0,
            tarekDialogCompleted: false,
            tarekEncounterTriggerX: 5500, // Posição X para iniciar o encontro com Tarek
            fixedCamera: false,
            fixedCameraTarget: { x: 0, y: 0 }
        };

        // Arrays de entidades
        let platforms = [];
        let enemies = [];
        let fallingSpikes = [];
        let checkpoints = [];
        
        // DOM element para o mundo do jogo - Essencial para renderização via DOM
        let gameWorldElement;

        // Cores CSS pré-calculadas para performance
        let COLOR_HEALTH, COLOR_MANA, COLOR_XP, COLOR_ACCENT_FIRE, COLOR_ACCENT_GOLD, COLOR_ACCENT_BLUE, COLOR_ACCENT_ICE, COLOR_TEXT_LIGHT, COLOR_UMBRA, COLOR_PLAYER_COLOR, COLOR_SPIKE;

        // Variáveis de controle do jogo
        let canvas, ctx; // Canvas agora é opcional, pode ser usado para efeitos seletivos ou removido
        let isMobile = false;
        let isLandscape = true;
        let lastTime = 0;
        let animationFrameId = null;


        // =================================================================================================
        // ===== 2. EVENT BUS (OBSERVER PATTERN) =========================================================
        // =================================================================================================
        /**
         * @class EventBus
         * @description Implementa o padrão Observer para desacoplar a comunicação entre diferentes partes do jogo.
         *              Componentes podem emitir eventos e outros componentes podem ouvi-los sem ter referências diretas.
         */
        class EventBus {
            constructor() {
                this.listeners = {};
            }

            /**
             * Assina um evento.
             * @param {string} eventName - O nome do evento a ser ouvido.
             * @param {Function} callback - A função a ser chamada quando o evento é emitido.
             */
            subscribe(eventName, callback) {
                if (!this.listeners[eventName]) {
                    this.listeners[eventName] = [];
                }
                this.listeners[eventName].push(callback);
            }

            /**
             * Desassina um evento.
             * @param {string} eventName - O nome do evento.
             * @param {Function} callback - A função que foi originalmente assinada.
             */
            unsubscribe(eventName, callback) {
                if (this.listeners[eventName]) {
                    this.listeners[eventName] = this.listeners[eventName].filter(cb => cb !== callback);
                }
            }

            /**
             * Emite um evento, notificando todos os assinantes.
             * @param {string} eventName - O nome do evento a ser emitido.
             * @param {*} data - Dados opcionais a serem passados para os callbacks.
             */
            emit(eventName, data) {
                if (this.listeners[eventName]) {
                    this.listeners[eventName].forEach(callback => callback(data));
                }
            }
        }

        const EventManager = new EventBus();


        // =================================================================================================
        // ===== 3. CLASSES DE COMPONENTES (Component Pattern) =============================================
        // =================================================================================================
        /**
         * @class PlayerInput
         * @description Componente responsável por gerenciar todas as entradas do jogador (teclado e touch).
         *              Separa a lógica de input do PlayerController.
         */
        class PlayerInput {
            constructor() {
                this.keys = {}; // Estado atual das teclas pressionadas
                this.lastJumpInput = 0; // Para garantir que o pulo só ocorra uma vez por pressionar
                
                // Estados para controles mobile (d-pad)
                this.mobileLeft = false;
                this.mobileRight = false;
                this.mobileUp = false;
                this.mobileDown = false;

                // Bind de eventos de teclado
                window.addEventListener('keydown', this._handleKeyDown.bind(this));
                window.addEventListener('keyup', this._handleKeyUp.bind(this));
                
                // Bind de eventos touch para d-pad e habilidades
                this._initMobileControlsListeners();
            }

            _handleKeyDown(e) {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                    e.preventDefault(); // Previne scroll da página
                }
                this.keys[e.key.toLowerCase()] = true;
            }

            _handleKeyUp(e) {
                this.keys[e.key.toLowerCase()] = false;
            }

            _initMobileControlsListeners() {
                const addTouchListeners = (elementId, startCallback, endCallback) => {
                    const el = document.getElementById(elementId);
                    if (el) {
                        el.addEventListener('touchstart', (e) => { e.preventDefault(); startCallback(); });
                        el.addEventListener('touchend', (e) => { e.preventDefault(); endCallback(); });
                        el.addEventListener('touchcancel', (e) => { e.preventDefault(); endCallback(); }); // Em caso de interrupção
                    }
                };

                addTouchListeners('mobile-up', () => this.mobileUp = true, () => this.mobileUp = false);
                addTouchListeners('mobile-down', () => this.mobileDown = true, () => this.mobileDown = false);
                addTouchListeners('mobile-left', () => this.mobileLeft = true, () => this.mobileLeft = false);
                addTouchListeners('mobile-right', () => this.mobileRight = true, () => this.mobileRight = false);

                // Habilidades (U, I, O, P) - já estão sendo tratadas como clicks/touches no HTML
                // O PlayerAbilityManager vai ouvir esses eventos de clique/toque nos botões
            }

            /**
             * Retorna a direção de movimento horizontal (-1 para esquerda, 1 para direita, 0 para parado).
             * @returns {number}
             */
            getMoveDirection() {
                let moveX = 0;
                if (this.keys['a'] || this.keys['arrowleft'] || this.mobileLeft) moveX = -1;
                if (this.keys['d'] || this.keys['arrowright'] || this.mobileRight) moveX = 1;
                return moveX;
            }

            /**
             * Verifica se o input de pulo foi acionado.
             * @returns {boolean}
             */
            isJumpPressed() {
                const jumpKey = this.keys['w'] || this.keys['arrowup'] || this.keys[' '];
                const jumpMobile = this.mobileUp; // O d-pad up também é o pulo
                
                // Lógica para detectar o "down" do input, não o segurar
                const currentJumpInput = (jumpKey || jumpMobile) ? 1 : 0;
                const jumped = currentJumpInput === 1 && this.lastJumpInput === 0;
                this.lastJumpInput = currentJumpInput;
                return jumped;
            }

            /**
             * Verifica se o input de agachar está ativo.
             * @returns {boolean}
             */
            isCrouchActive() {
                return this.keys['s'] || this.keys['arrowdown'] || this.mobileDown;
            }

            /**
             * Verifica se uma tecla de habilidade específica foi pressionada.
             * @param {string} key - A letra da tecla (ex: 'u', 'i', 'o', 'p').
             * @returns {boolean}
             */
            isAbilityPressed(key) {
                return this.keys[key.toLowerCase()];
            }

            /**
             * Limpa os inputs que devem ser de "apenas um toque" (ex: pulo)
             * Chamado após o frame de update.
             */
            clearOneShotInputs() {
                // `isJumpPressed` já lida com isso internamente usando `lastJumpInput`
            }
        }

        /**
         * @class HealthComponent
         * @description Componente que gerencia a saúde e invencibilidade de uma entidade.
         */
        class HealthComponent {
            constructor(maxHealth, regenRate = 0) {
                this.maxHealth = maxHealth;
                this.currentHealth = maxHealth;
                this.regenRate = regenRate;
                this.isInvincible = false;
                this.invincibilityTimer = 0;
                this.flashActive = false; // Estado para o efeito de flash visual
            }

            /**
             * Causa dano à entidade.
             * @param {number} amount - Quantidade de dano.
             * @param {number} invincibilityDuration - Duração da invencibilidade após o dano.
             */
            takeDamage(amount, invincibilityDuration = CONFIG.INVINCIBILITY_DURATION) {
                if (this.isInvincible) return;

                this.currentHealth -= amount;
                this.currentHealth = Math.max(0, this.currentHealth);
                this.isInvincible = true;
                this.invincibilityTimer = invincibilityDuration;
                
                // Efeito visual de flash de tela ou sprite
                EventManager.emit('screen_flash', { color: COLOR_HEALTH, duration: CONFIG.DAMAGE_FLASH_DURATION });
                EventManager.emit('screen_shake', { intensity: 5, duration: 300 });
                EventManager.emit('sfx_play', 'sfx_damage_player');

                EventManager.emit('player_damaged', { current: this.currentHealth, max: this.maxHealth });

                if (this.currentHealth <= 0) {
                    EventManager.emit('entity_died', this); // Notifica que a entidade morreu
                }
            }

            /**
             * Cura a entidade.
             * @param {number} amount - Quantidade de cura.
             */
            heal(amount) {
                this.currentHealth += amount;
                this.currentHealth = Math.min(this.maxHealth, this.currentHealth);
                EventManager.emit('player_healed', { current: this.currentHealth, max: this.maxHealth });
            }

            /**
             * Atualiza a lógica de regeneração e invencibilidade.
             * @param {number} deltaTime - Tempo decorrido desde o último frame (em ms).
             */
            update(deltaTime) {
                // Regeneração
                if (this.currentHealth < this.maxHealth && this.regenRate > 0) {
                    this.currentHealth += this.regenRate * (deltaTime / 1000);
                    this.currentHealth = Math.min(this.maxHealth, this.currentHealth);
                    EventManager.emit('player_healed', { current: this.currentHealth, max: this.maxHealth }); // Usar o mesmo evento de cura
                }

                // Invencibilidade
                if (this.isInvincible) {
                    this.invincibilityTimer -= deltaTime;
                    if (this.invincibilityTimer <= 0) {
                        this.isInvincible = false;
                    }
                }
            }
        }

        /**
         * @class ManaComponent
         * @description Componente que gerencia a mana e sua regeneração para uma entidade.
         */
        class ManaComponent {
            constructor(maxMana, regenRate) {
                this.maxMana = maxMana;
                this.currentMana = maxMana;
                this.regenRate = regenRate;
            }

            /**
             * Tenta usar uma quantidade de mana.
             * @param {number} amount - Quantidade de mana a ser usada.
             * @returns {boolean} - True se a mana foi usada com sucesso, false caso contrário.
             */
            useMana(amount) {
                if (this.currentMana >= amount) {
                    this.currentMana -= amount;
                    EventManager.emit('player_mana_changed', { current: this.currentMana, max: this.maxMana });
                    return true;
                }
                EventManager.emit('screen_flash', { color: COLOR_MANA, duration: 200 }); // Sinal visual de mana insuficiente
                return false;
            }

            /**
             * Atualiza a regeneração de mana.
             * @param {number} deltaTime - Tempo decorrido desde o último frame (em ms).
             */
            update(deltaTime) {
                if (this.currentMana < this.maxMana) {
                    this.currentMana += this.regenRate * (deltaTime / 1000);
                    this.currentMana = Math.min(this.maxMana, this.currentMana);
                    EventManager.emit('player_mana_changed', { current: this.currentMana, max: this.maxMana });
                }
            }
        }

        /**
         * @class PhysicsComponent
         * @description Componente que lida com a física (movimento, gravidade, colisão) de uma entidade.
         */
        class PhysicsComponent {
            constructor(entity, width, height) {
                this.entity = entity; // Referência à entidade (Player ou Enemy)
                this.width = width;
                this.height = height;
                this.velocity = { x: 0, y: 0 };
                this.isGrounded = false;
                this.collisionOffset = 0.01; // Pequeno offset para evitar bugs de "encaixe" em colisões
            }

            /**
             * Aplica a gravidade e atualiza a posição baseada na velocidade.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                // Aplicar gravidade
                this.velocity.y += CONFIG.GRAVITY;

                // Limitar velocidade de queda para evitar quebras de colisão
                if (this.velocity.y > 15) {
                    this.velocity.y = 15;
                }

                // Atualizar posição tentativa
                let newX = this.entity.position.x + this.velocity.x * (deltaTime / 1000);
                let newY = this.entity.position.y + this.velocity.y * (deltaTime / 1000);

                // Resetar estado de chão
                this.isGrounded = false;

                // Checar colisões em X
                for (const platform of platforms) {
                    if (this._checkCollision(newX, this.entity.position.y, this.width, this.height, platform)) {
                        if (this.velocity.x > 0) { // Indo para a direita
                            newX = platform.x - this.width - this.collisionOffset;
                        } else if (this.velocity.x < 0) { // Indo para a esquerda
                            newX = platform.x + platform.width + this.collisionOffset;
                        }
                        this.velocity.x = 0;
                        break;
                    }
                }
                this.entity.position.x = newX;

                // Checar colisões em Y
                for (const platform of platforms) {
                    if (this._checkCollision(this.entity.position.x, newY, this.width, this.height, platform)) {
                        if (platform.type === 'spike') {
                            if (this.entity.isPlayer) { // Só o jogador toma dano de spike
                                this.entity.health.takeDamage(10);
                            }
                            // Não para a colisão para que ele caia, apenas causa dano
                            continue;
                        }

                        if (this.velocity.y > 0) { // Caindo (colisão com o chão/topo da plataforma)
                            newY = platform.y - this.height - this.collisionOffset;
                            this.isGrounded = true;
                            // Se a queda foi forte, emite partículas
                            if (this.velocity.y > 8) { 
                                EventManager.emit('add_particles', { type: 'landDust', x: this.entity.position.x + this.width / 2, y: this.entity.position.y + this.height, count: 12 });
                                EventManager.emit('screen_shake', { intensity: 3, duration: 150 });
                            }
                        } else if (this.velocity.y < 0) { // Subindo (colisão com o lado de baixo da plataforma)
                            newY = platform.y + platform.height + this.collisionOffset;
                        }
                        this.velocity.y = 0;
                        break;
                    }
                }
                this.entity.position.y = newY;

                // Colisão com o "chão do mundo" (se cair muito)
                if (this.entity.position.y > CONFIG.WORLD_HEIGHT - this.height) {
                    this.entity.position.y = CONFIG.WORLD_HEIGHT - this.height;
                    this.velocity.y = 0;
                    this.isGrounded = true;
                    // Se o jogador cair pra fora do mapa, ele "morre" ou toma muito dano
                    if (this.entity.isPlayer) {
                        this.entity.health.takeDamage(this.entity.health.maxHealth);
                    }
                }
            }

            /**
             * Checa colisão entre dois retângulos (AABB).
             * @param {number} x1, y1, w1, h1 - Posição e dimensões do primeiro retângulo.
             * @param {object} rect2 - Objeto com x, y, width, height do segundo retângulo.
             * @returns {boolean} - True se houver colisão.
             */
            _checkCollision(x1, y1, w1, h1, rect2) {
                return x1 < rect2.x + rect2.width &&
                       x1 + w1 > rect2.x &&
                       y1 < rect2.y + rect2.height &&
                       y1 + h1 > rect2.y;
            }

            /**
             * Aplica uma força de pulo.
             * @param {number} force - A força do pulo.
             */
            jump(force) {
                this.velocity.y = -force;
                this.isGrounded = false;
                EventManager.emit('sfx_play', 'sfx_jump');
                EventManager.emit('add_particles', { type: 'jumpDust', x: this.entity.position.x + this.width / 2, y: this.entity.position.y + this.height, count: 8 });
            }

            /**
             * Aplica uma força horizontal (movimento).
             * @param {number} direction - -1 para esquerda, 1 para direita, 0 para parado.
             * @param {number} speed - Velocidade de movimento.
             */
            moveX(direction, speed) {
                this.velocity.x = direction * speed;
            }

            /**
             * Aplica um empurrão (knockback).
             * @param {number} forceX - Força em X.
             * @param {number} forceY - Força em Y.
             */
            applyKnockback(forceX, forceY) {
                this.velocity.x = forceX;
                this.velocity.y = forceY;
            }
        }

        /**
         * @class AnimationManager
         * @description Componente responsável por gerenciar animações de sprite.
         *              Ele agora opera manipulando o `src` de um elemento `<img>` ou `background-image` de um `div`.
         *              IMPORTANTE: Para animações, `frames` deve ser um ARRAY DE OBJETOS Image (quadros).
         *              Se um único Image for passado, ele assumirá um sprite estático.
         */
        class AnimationManager {
            constructor(entity, animationsConfig) {
                this.entity = entity; // Referência à entidade (Player, Enemy)
                this.htmlElement = entity.htmlElement; // O elemento DOM que representa a entidade
                this.imageElement = null; // Para entidades que usam <img>
                
                // Se a entidade usa <img> dentro de sua div, crie-a
                if (this.htmlElement.tagName === 'DIV') {
                    this.imageElement = document.createElement('img');
                    this.imageElement.style.width = '100%';
                    this.imageElement.style.height = '100%';
                    this.htmlElement.appendChild(this.imageElement);
                } else if (this.htmlElement.tagName === 'IMG') {
                    this.imageElement = this.htmlElement;
                }

                this.animations = {}; // { "idle": { frames: [Image, Image], frameDelay: 100, loop: true, currentFrameIndex: 0, frameTimer: 0 } }
                this.currentAnimationKey = 'idle'; // Key da animação atual
                this.isPlaying = true;
                this.onFinishCallbacks = {}; // Callbacks para animações não-looping { "attack_u": callback }

                // Carrega as configurações de animação
                for (const key in animationsConfig) {
                    const config = animationsConfig[key];
                    // IMPORTANT: `frames` here should be an array of Image objects for animation
                    // If you provide a single Image, it will be treated as a static sprite.
                    this.animations[key] = {
                        frames: Array.isArray(config.frames) ? config.frames : [config.frames],
                        frameDelay: config.frameDelay || 100,
                        loop: config.loop !== undefined ? config.loop : true,
                        currentFrameIndex: 0,
                        frameTimer: 0
                    };
                }
            }

            /**
             * Define uma função de callback para quando uma animação não-looping terminar.
             * @param {string} animationKey - A chave da animação.
             * @param {Function} callback - A função a ser chamada.
             */
            onAnimationFinish(animationKey, callback) {
                this.onFinishCallbacks[animationKey] = callback;
            }

            /**
             * Muda para uma nova animação.
             * @param {string} animationKey - A chave da animação a ser tocada.
             * @param {boolean} forceRestart - Se true, reinicia a animação mesmo que já esteja tocando.
             */
            play(animationKey, forceRestart = false) {
                if (this.currentAnimationKey === animationKey && !forceRestart) {
                    return; // Já está tocando esta animação
                }
                if (!this.animations[animationKey]) {
                    console.warn(`Animação '${animationKey}' não encontrada.`);
                    return;
                }

                this.currentAnimationKey = animationKey;
                this.animations[animationKey].currentFrameIndex = 0; // Reinicia a animação
                this.animations[animationKey].frameTimer = 0;
                this.isPlaying = true;
            }

            /**
             * Atualiza o estado da animação (avança o quadro) e atualiza o sprite no DOM.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                if (!this.isPlaying || !this.htmlElement) return;

                const currentAnim = this.animations[this.currentAnimationKey];
                if (!currentAnim || currentAnim.frames.length === 0) {
                    if (this.imageElement) this.imageElement.src = ''; // Limpa a imagem se não houver frames
                    return;
                }

                // Avança o frame da animação
                if (currentAnim.frames.length > 1) { // Só anima se tiver mais de um frame
                    currentAnim.frameTimer += deltaTime;
                    if (currentAnim.frameTimer >= currentAnim.frameDelay) {
                        currentAnim.currentFrameIndex++;
                        currentAnim.frameTimer = 0;

                        if (currentAnim.currentFrameIndex >= currentAnim.frames.length) {
                            if (currentAnim.loop) {
                                currentAnim.currentFrameIndex = 0; // Volta para o início
                            } else {
                                currentAnim.currentFrameIndex = currentAnim.frames.length - 1; // Para no último quadro
                                this.isPlaying = false; // Para a animação
                                if (this.onFinishCallbacks[this.currentAnimationKey]) {
                                    this.onFinishCallbacks[this.currentAnimationKey](); // Chama o callback de término
                                }
                            }
                        }
                    }
                } else { // Se só tem 1 frame, só mostra ele e não anima
                    currentAnim.currentFrameIndex = 0;
                    this.isPlaying = false;
                }

                // Atualiza o src do <img> ou background-image do <div>
                const currentFrame = currentAnim.frames[currentAnim.currentFrameIndex];
                if (this.imageElement) { // Se usa <img> tag interna
                    this.imageElement.src = currentFrame.src;
                } else { // Se usa background-image na própria div
                    this.htmlElement.style.backgroundImage = `url('${currentFrame.src}')`;
                    this.htmlElement.style.backgroundSize = '100% 100%'; // Garante que a imagem preencha
                }
            }
        }

        // =================================================================================================
        // ===== 4. CLASSES DE ESTADOS (State Pattern) =====================================================
        // =================================================================================================

        /**
         * @class PlayerState
         * @description Classe base abstrata para todos os estados do jogador.
         */
        class PlayerState {
            constructor(player) {
                this.player = player;
            }

            onEnter() {}
            onUpdate(deltaTime) {}
            onFixedUpdate(deltaTime) {} // Para lógica de física
            onExit() {}
        }

        class PlayerIdleState extends PlayerState {
            onEnter() {
                this.player.animation.play('idle');
                this.player.physics.velocity.x = 0; // Para o movimento horizontal
            }
            onUpdate(deltaTime) {
                if (this.player.input.getMoveDirection() !== 0) {
                    this.player.transitionToState(new PlayerWalkState(this.player));
                } else if (this.player.input.isJumpPressed()) {
                    this.player.jump();
                    this.player.transitionToState(new PlayerJumpState(this.player)); // Transiciona para jump imediatamente
                } else if (this.player.input.isCrouchActive()) {
                    this.player.crouch(true);
                    this.player.transitionToState(new PlayerCrouchState(this.player));
                }
                // Habilidades são verificadas fora dos estados para que possam ser usadas em qualquer estado relevante
            }
        }

        class PlayerWalkState extends PlayerState {
            onEnter() {
                this.player.animation.play('walk');
            }
            onUpdate(deltaTime) {
                const moveDirection = this.player.input.getMoveDirection();
                if (moveDirection === 0) {
                    this.player.transitionToState(new PlayerIdleState(this.player));
                } else if (this.player.input.isJumpPressed()) {
                    this.player.jump();
                    this.player.transitionToState(new PlayerJumpState(this.player));
                } else if (this.player.input.isCrouchActive()) {
                    this.player.crouch(true);
                    this.player.transitionToState(new PlayerCrouchState(this.player));
                }
                this.player.move(moveDirection);
            }
            onFixedUpdate(deltaTime) {
                this.player.physics.moveX(this.player.input.getMoveDirection(), this.player.currentSpeed);
            }
            onExit() {
                this.player.physics.velocity.x = 0; // Para o movimento ao sair do estado de andar
            }
        }

        class PlayerJumpState extends PlayerState {
            onEnter() {
                this.player.animation.play('jump', true); // Force restart para garantir a animação de pulo
                this.player.animation.onAnimationFinish('jump', () => {
                    // Após a animação de pulo terminar, se ainda não estiver no chão, mantém o último frame
                    // ou transiciona para um estado de "caindo" se implementado.
                    // Para simplicidade, manteremos o controle de isGrounded para transição.
                });
            }
            onUpdate(deltaTime) {
                const moveDirection = this.player.input.getMoveDirection();
                this.player.move(moveDirection);

                // Se o jogador estiver no chão e o input de pulo não estiver mais ativo, retorna para Idle/Walk
                if (this.player.physics.isGrounded && !this.player.input.isJumpPressed()) {
                    if (moveDirection !== 0) {
                        this.player.transitionToState(new PlayerWalkState(this.player));
                    } else {
                        this.player.transitionToState(new PlayerIdleState(this.player));
                    }
                }
                // Se o input de agachar for pressionado no air, transiciona para agachado no ar (se aplicável)
                // ou simplesmente ajusta a altura de colisão.
            }
            onFixedUpdate(deltaTime) {
                this.player.physics.moveX(this.player.input.getMoveDirection(), this.player.currentSpeed);
            }
        }

        class PlayerCrouchState extends PlayerState {
            onEnter() {
                this.player.crouch(true);
                this.player.animation.play('crouch');
            }
            onUpdate(deltaTime) {
                if (!this.player.input.isCrouchActive()) {
                    // Tenta levantar
                    if (this.player.canStandUp()) {
                        this.player.crouch(false);
                        const moveDirection = this.player.input.getMoveDirection();
                        if (moveDirection !== 0) {
                            this.player.transitionToState(new PlayerWalkState(this.player));
                        } else {
                            this.player.transitionToState(new PlayerIdleState(this.player));
                        }
                    }
                }
                // Se pular enquanto agachado (salto baixo ou rolamento)
                else if (this.player.input.isJumpPressed()) {
                    this.player.crouch(false); // Levanta ao pular
                    this.player.jump(CONFIG.JUMP_FORCE * 0.7); // Pulo mais baixo
                    this.player.transitionToState(new PlayerJumpState(this.player));
                }
            }
            onExit() {
                this.player.crouch(false); // Garante que o jogador está em pé ao sair
            }
        }

        class PlayerAbilityState extends PlayerState {
            constructor(player, animationKey, nextStateIfFinished = null) {
                super(player);
                this.animationKey = animationKey;
                // Define o estado para o qual transicionar automaticamente após a animação da habilidade
                this.nextStateIfFinished = nextStateIfFinished || new PlayerIdleState(player);
            }

            onEnter() {
                this.player.animation.play(this.animationKey, true); // Força a animação da habilidade
                // Define um callback para quando a animação da habilidade terminar
                this.player.animation.onAnimationFinish(this.animationKey, () => {
                    this.player.transitionToState(this.nextStateIfFinished);
                });
            }

            onUpdate(deltaTime) {
                // Durante a animação da habilidade, o jogador pode ter movimento limitado ou nenhum.
                // Isso depende da habilidade. Por exemplo, um dash ainda pode ter movimento.
                // Para simplificar, o jogador não se move durante a animação de habilidade aqui.
            }
            onFixedUpdate(deltaTime) {
                 this.player.physics.velocity.x = 0; // Para garantir que o jogador não deslize durante a habilidade
            }
            onExit() {
                // Remove o callback para evitar que seja chamado novamente se o estado mudar antes da animação terminar
                this.player.animation.onAnimationFinish(this.animationKey, null);
            }
        }
        
        class PlayerDamageState extends PlayerState {
            constructor(player) {
                super(player);
                this.canExit = false;
            }

            onEnter() {
                this.player.animation.play('take_damage', true);
                this.player.animation.onAnimationFinish('take_damage', () => {
                    this.canExit = true; // Permite sair do estado após a animação de dano
                });
            }

            onUpdate(deltaTime) {
                // Se a invencibilidade acabou e a animação de dano terminou, volta para o estado normal.
                if (!this.player.health.isInvincible && this.canExit) {
                    // Volta para idle ou walk dependendo do input
                    const moveDirection = this.player.input.getMoveDirection();
                    if (moveDirection !== 0) {
                        this.player.transitionToState(new PlayerWalkState(this.player));
                    } else {
                        this.player.transitionToState(new PlayerIdleState(this.player));
                    }
                }
                // Permite algum controle de movimento leve enquanto toma dano
                // this.player.physics.moveX(this.player.input.getMoveDirection(), this.player.currentSpeed * 0.5);
            }

            onFixedUpdate(deltaTime) {
                // Não altera a velocidade de knockback enquanto estiver neste estado
            }

            onExit() {
                this.player.animation.onAnimationFinish('take_damage', null);
            }
        }


        /**
         * @class EnemyState
         * @description Classe base abstrata para todos os estados do inimigo.
         */
        class EnemyState {
            constructor(enemy) {
                this.enemy = enemy;
            }
            onEnter() {}
            onUpdate(deltaTime) {}
            onFixedUpdate(deltaTime) {}
            onExit() {}
        }

        class EnemyPatrolState extends EnemyState {
            onEnter() {
                this.enemy.animation.play('idle'); // Inimigos podem ter animações diferentes para patrulha
            }
            onUpdate(deltaTime) {
                // Verifica a proximidade do jogador para transicionar para o estado de ataque
                const distanceToPlayer = Math.abs(this.enemy.position.x - gameState.player.position.x);
                if (distanceToPlayer < 200) { // Raio de detecção
                    this.enemy.transitionToState(new EnemyAttackState(this.enemy));
                }
            }
            onFixedUpdate(deltaTime) {
                this.enemy._patrol(deltaTime);
            }
        }

        class EnemyAttackState extends EnemyState {
            onEnter() {
                this.enemy.animation.play('attack');
                this.enemy.attackCooldown = 0; // Reseta cooldown para poder atacar imediatamente
            }
            onUpdate(deltaTime) {
                const distanceToPlayer = Math.abs(this.enemy.position.x - gameState.player.position.x);
                if (distanceToPlayer > 250) { // Se o jogador se afastou muito
                    this.enemy.transitionToState(new EnemyPatrolState(this.enemy));
                } else {
                    this.enemy.attackCooldown -= deltaTime;
                    if (this.enemy.attackCooldown <= 0) {
                        this.enemy._attack();
                        this.enemy.attackCooldown = 2000 + Math.random() * 1000;
                    }
                }
            }
            onFixedUpdate(deltaTime) {
                // Inimigo pode se mover levemente enquanto ataca
                const directionToPlayer = gameState.player.position.x > this.enemy.position.x ? 1 : -1;
                this.enemy.physics.moveX(directionToPlayer, this.enemy.speed * 0.5);
            }
        }

        class EnemyBossState extends EnemyState {
            onEnter() {
                this.enemy.animation.play('idle'); // Bosses podem ter animações de combate específicas
            }
            onUpdate(deltaTime) {
                // Lógica de AI do boss
                this.enemy._updateBossAI(deltaTime);
            }
            onFixedUpdate(deltaTime) {
                // A movimentação do boss é controlada pela AI em _updateBossAI
            }
        }

        // =================================================================================================
        // ===== 5. CLASSES DE ENTIDADES DO JOGO (Composição de Componentes) ===============================
        // =================================================================================================

        /**
         * @class Player
         * @description Representa o personagem principal do jogo, usando composição de componentes e State Pattern.
         */
        class Player {
            constructor(name, playerConfig) {
                this.playerName = name;
                this.isPlayer = true; // Flag para identificar
                this.position = { x: 100, y: 300 }; // Posição inicial

                // Cria o elemento DOM para o jogador
                this.htmlElement = document.createElement('div');
                this.htmlElement.className = 'game-entity player-sprite';
                this.htmlElement.id = 'player-entity';
                gameWorldElement.appendChild(this.htmlElement);

                this.damage = playerConfig.baseDamage; // Dano base do jogador
                this.baseSpeed = playerConfig.baseSpeed;
                this.currentSpeed = this.baseSpeed; // Velocidade atual

                // Componentes
                this.input = new PlayerInput();
                this.health = new HealthComponent(playerConfig.baseHealth, CONFIG.HEALTH_REGEN_RATE);
                this.mana = new ManaComponent(playerConfig.baseMana, playerConfig.manaRegenRate);
                this.physics = new PhysicsComponent(this, CONFIG.PLAYER_WIDTH, CONFIG.PLAYER_HEIGHT);
                this.animation = new AnimationManager(this, {
                    // Para funcionar com GIFs ou sequências de frames, certifique-se que ASSET_LOADED
                    // contém o array de objetos Image para cada animação.
                    // Se apenas um único Image (do GIF) estiver em ASSET_LOADED, a animação será estática.
                    idle: { frames: CONFIG.ASSET_LOADED.player_idle, frameDelay: 150 },
                    walk: { frames: CONFIG.ASSET_LOADED.player_walk, frameDelay: 100 },
                    jump: { frames: CONFIG.ASSET_LOADED.player_jump, frameDelay: 100, loop: false },
                    crouch: { frames: CONFIG.ASSET_LOADED.player_crouch, frameDelay: 100 },
                    attack_u: { frames: CONFIG.ASSET_LOADED.player_attack_u, frameDelay: 80, loop: false },
                    attack_i: { frames: CONFIG.ASSET_LOADED.player_attack_i, frameDelay: 100, loop: false },
                    attack_o: { frames: CONFIG.ASSET_LOADED.player_attack_o, frameDelay: 120, loop: false },
                    ultimate: { frames: CONFIG.ASSET_LOADED.player_ultimate, frameDelay: 100, loop: true },
                    take_damage: { frames: CONFIG.ASSET_LOADED.player_damage, frameDelay: 200, loop: false }
                });

                // Estado (State Pattern)
                this.currentState = null;
                this.transitionToState(new PlayerIdleState(this));

                // Propriedades específicas do jogador
                this.isCrouching = false;
                this.facing = 'right'; // Direção para onde o jogador está olhando

                // Habilidades
                this.abilities = {};
                playerConfig.abilities.forEach(abilityData => {
                    const AbilityClass = PlayerAbilityFactory.createAbility(abilityData.name);
                    if (AbilityClass) {
                        this.abilities[abilityData.key] = new AbilityClass(this, abilityData);
                    }
                });
                
                // Event Listeners (Observer Pattern)
                EventManager.subscribe('player_damaged', (data) => {
                    UIManager.updateHealth(data);
                    // Transiciona para o estado de dano se não estiver invencível ou já em dano
                    if (this.health.isInvincible && !(this.currentState instanceof PlayerDamageState)) {
                        this.transitionToState(new PlayerDamageState(this));
                    }
                });
                EventManager.subscribe('player_healed', (data) => {
                    UIManager.updateHealth(data);
                });
                EventManager.subscribe('player_mana_changed', (data) => {
                    UIManager.updateMana(data);
                });
                EventManager.subscribe('xp_gained', (data) => {
                    UIManager.updateXP(data);
                });
                EventManager.subscribe('level_up', (data) => {
                    UIManager.showLevelUpMenu(data);
                });
                EventManager.subscribe('player_state_change', (newState) => {
                    // Lógica para debug ou reações globais a mudanças de estado
                });
            }

            /**
             * Transiciona o jogador para um novo estado.
             * @param {PlayerState} newState - A nova instância de estado.
             */
            transitionToState(newState) {
                if (this.currentState) {
                    this.currentState.onExit();
                }
                this.currentState = newState;
                this.currentState.onEnter();
                EventManager.emit('player_state_change', newState.constructor.name);
            }

            /**
             * Atualiza o jogador no loop de jogo.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                this.health.update(deltaTime);
                this.mana.update(deltaTime);

                // Atualiza o estado atual (movimento, ações específicas do estado)
                this.currentState.onUpdate(deltaTime);
                
                // Processa as habilidades (elas podem ser ativadas em vários estados)
                this._processAbilities(deltaTime);

                // Atualiza a animação
                this.animation.update(deltaTime);

                // Atualiza a direção do sprite baseado na física ou input
                const moveDir = this.input.getMoveDirection();
                if (moveDir > 0) {
                    this.facing = 'right';
                    this.htmlElement.style.transform = 'scaleX(1)'; // Não vira o sprite
                } else if (moveDir < 0) {
                    this.facing = 'left';
                    this.htmlElement.style.transform = 'scaleX(-1)'; // Vira o sprite horizontalmente
                }
            }
            
            /**
             * Atualiza a lógica de física do jogador no loop de jogo (chamado em FixedUpdate).
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            fixedUpdate(deltaTime) {
                this.currentState.onFixedUpdate(deltaTime);
                this.physics.update(deltaTime);
            }

            /**
             * Move o jogador horizontalmente.
             * @param {number} direction - -1 para esquerda, 1 para direita, 0 para parado.
             */
            move(direction) {
                this.physics.moveX(direction, this.currentSpeed);
            }

            /**
             * Faz o jogador pular.
             */
            jump(force = CONFIG.JUMP_FORCE) {
                if (this.physics.isGrounded) {
                    this.physics.jump(force);
                }
            }

            /**
             * Altera o estado de agachamento do jogador.
             * @param {boolean} crouch - True para agachar, false para levantar.
             */
            crouch(crouch) {
                this.isCrouching = crouch;
                this.physics.height = crouch ? CONFIG.CROUCH_HEIGHT : CONFIG.PLAYER_HEIGHT;
                // Ajusta a posição Y ao agachar para que o chão permaneça o mesmo
                if (crouch && this.physics.isGrounded) {
                    this.position.y += (CONFIG.PLAYER_HEIGHT - CONFIG.CROUCH_HEIGHT);
                } else if (!crouch && this.physics.isGrounded) {
                    this.position.y -= (CONFIG.PLAYER_HEIGHT - CONFIG.CROUCH_HEIGHT);
                }
                // Atualiza o estilo da altura do elemento HTML
                this.htmlElement.style.height = `${this.physics.height}px`;
            }

            /**
             * Verifica se o jogador pode levantar sem colidir com algo acima.
             * @returns {boolean}
             */
            canStandUp() {
                const newHeight = CONFIG.PLAYER_HEIGHT;
                const newY = this.position.y - (newHeight - CONFIG.CROUCH_HEIGHT);
                for (const platform of platforms) {
                    if (this.physics._checkCollision(this.position.x, newY, CONFIG.PLAYER_WIDTH, newHeight, platform)) {
                        return false;
                    }
                }
                return true;
            }

            /**
             * Gerencia o uso das habilidades.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            _processAbilities(deltaTime) {
                for (const key in this.abilities) {
                    const ability = this.abilities[key];
                    ability.updateCooldown(deltaTime); // Atualiza cooldown para todas as habilidades

                    if (this.input.isAbilityPressed(key.toLowerCase())) {
                        ability.activate(); // Tenta ativar a habilidade
                    }
                }
            }

            /**
             * Atualiza a posição do elemento DOM do jogador.
             */
            render() {
                // Atualiza a posição e tamanho do elemento HTML
                this.htmlElement.style.left = `${this.position.x}px`;
                this.htmlElement.style.top = `${this.position.y}px`;
                this.htmlElement.style.width = `${CONFIG.PLAYER_WIDTH}px`;
                this.htmlElement.style.height = `${this.physics.height}px`; // Altura pode mudar ao agachar

                // Efeito de piscar durante a invencibilidade
                if (this.health.isInvincible && Math.floor(performance.now() / 100) % 2) {
                    this.htmlElement.style.opacity = '0.5';
                } else {
                    this.htmlElement.style.opacity = '1';
                }
            }

            /**
             * Remove o elemento DOM do jogo.
             */
            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }

        /**
         * @class Enemy
         * @description Classe base para inimigos.
         */
        class Enemy {
            constructor(type, x, y, config) {
                this.type = type;
                this.isPlayer = false;
                this.position = { x: x, y: y };
                this.config = config;

                // Cria o elemento DOM para o inimigo
                this.htmlElement = document.createElement('div');
                this.htmlElement.className = `game-entity enemy-sprite enemy-${type}`;
                this.htmlElement.id = `enemy-${Date.now()}-${Math.random().toFixed(0)}`; // ID único
                gameWorldElement.appendChild(this.htmlElement);

                // Elemento da barra de vida (DOM)
                this.healthBarElement = document.createElement('div');
                this.healthBarElement.className = 'entity-health-bar';
                this.healthFillElement = document.createElement('div');
                this.healthFillElement.className = 'entity-health-fill';
                this.healthBarElement.appendChild(this.healthFillElement);
                this.htmlElement.appendChild(this.healthBarElement);
                this.healthBarElement.style.display = 'none'; // Esconder por padrão

                this.health = new HealthComponent(config.health);
                this.physics = new PhysicsComponent(this, 50, 50); // Assumindo tamanho padrão para inimigos
                this.damage = config.damage;
                this.speed = config.speed;
                this.xpValue = config.xpValue;

                this.animation = new AnimationManager(this, {
                    idle: { frames: CONFIG.ASSET_LOADED.sentinel_sprite, frameDelay: 150 },
                    attack: { frames: CONFIG.ASSET_LOADED.sentinel_sprite, frameDelay: 150 }, // Exemplo, pode ser um sprite diferente
                    // ... mais animações para inimigos
                });
                this.animation.play('idle');

                this.currentState = null;
                this.transitionToState(new EnemyPatrolState(this)); // Estado inicial

                // Propriedades de patrulha
                this.patrolStartX = x;
                this.patrolRange = config.patrolRange || 100;
                this.patrolDirection = 1;

                // Propriedades de ataque
                this.attackCooldown = 0;

                // Event Listeners
                EventManager.subscribe('entity_died', (entity) => {
                    if (entity === this) {
                        EventManager.emit('enemy_defeated', this);
                        this.destroy(); // Remove o elemento DOM quando morre
                    }
                });
                // Evento para mostrar barra de vida do inimigo quando atingido pelo jogador
                EventManager.subscribe('player_attack', (attackData) => {
                    // Simplificação: se o player ataca, mostramos a barra de vida de todos os inimigos.
                    // Em um jogo real, você passaria o inimigo atingido.
                    this.healthBarElement.style.display = 'block';
                });
            }

            transitionToState(newState) {
                if (this.currentState) {
                    this.currentState.onExit();
                }
                this.currentState = newState;
                this.currentState.onEnter();
            }

            update(deltaTime) {
                this.health.update(deltaTime);
                this.currentState.onUpdate(deltaTime);
                this.animation.update(deltaTime);
            }
            
            fixedUpdate(deltaTime) {
                this.currentState.onFixedUpdate(deltaTime);
                this.physics.update(deltaTime);
            }

            render() {
                // Atualiza a posição e tamanho do elemento HTML
                this.htmlElement.style.left = `${this.position.x}px`;
                this.htmlElement.style.top = `${this.position.y}px`;
                this.htmlElement.style.width = `${this.physics.width}px`;
                this.htmlElement.style.height = `${this.physics.height}px`;

                // Renderizar barra de vida se houver dano
                if (this.health.currentHealth < this.health.maxHealth) {
                    this.healthBarElement.style.display = 'block';
                    const healthPercent = this.health.currentHealth / this.health.maxHealth;
                    this.healthFillElement.style.width = `${healthPercent * 100}%`;
                    if (healthPercent > 0.5) {
                        this.healthFillElement.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
                    } else if (healthPercent > 0.25) {
                        this.healthFillElement.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
                    } else {
                        this.healthFillElement.style.background = 'linear-gradient(90deg, #f44336, #e53935)';
                    }
                    // Posiciona a barra de vida acima do inimigo
                    this.healthBarElement.style.left = `${(this.physics.width / 2) - (this.healthBarElement.offsetWidth / 2)}px`; // Centraliza no inimigo
                    this.healthBarElement.style.top = `-15px`;
                } else {
                    this.healthBarElement.style.display = 'none';
                }
            }

            takeDamage(amount) {
                this.health.takeDamage(amount, 0); // Inimigos não têm invencibilidade após dano por padrão
                EventManager.emit('add_particles', { type: 'hitSpark', x: this.position.x + this.physics.width / 2, y: this.position.y + this.physics.height / 2, count: 8 });
                EventManager.emit('sfx_play', 'sfx_damage_enemy');
                
                if (this.health.currentHealth <= 0) {
                    EventManager.emit('add_particles', { type: 'deathExplosion', x: this.position.x + this.physics.width / 2, y: this.position.y + this.physics.height / 2, count: 20 });
                    EventManager.emit('screen_shake', { intensity: 4, duration: 200 });
                }
            }

            _patrol(deltaTime) {
                this.physics.moveX(this.patrolDirection, this.speed);
                if (this.position.x > this.patrolStartX + this.patrolRange) {
                    this.patrolDirection = -1;
                    this.htmlElement.style.transform = 'scaleX(-1)'; // Vira o sprite
                } else if (this.position.x < this.patrolStartX - this.patrolRange) {
                    this.patrolDirection = 1;
                    this.htmlElement.style.transform = 'scaleX(1)'; // Vira o sprite
                }
            }

            _attack() {
                // Implementação padrão de ataque para sentinela
                const direction = gameState.player.position.x > this.position.x ? 1 : -1;
                EventManager.emit('spawn_projectile', {
                    type: 'enemyIceShot',
                    x: this.position.x + (direction > 0 ? this.physics.width : -25),
                    y: this.position.y + 15,
                    damage: this.damage,
                    direction: direction,
                    speed: 5,
                    origin: 'enemy'
                });
                EventManager.emit('add_particles', { type: 'enemyMuzzle', x: this.position.x + this.physics.width / 2, y: this.position.y + 15, count: 6 });
            }

            /**
             * Remove o elemento DOM do jogo.
             */
            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }

        /**
         * @class BossTarek
         * @description Classe específica para o boss Tarek, que estende Enemy.
         */
        class BossTarek extends Enemy {
            constructor(x, y, config) {
                super('boss', x, y, config);
                this.name = 'Tarek, o Guerreiro';
                // Adapta o elemento HTML para o sprite do Tarek (se houver um CSS específico)
                this.htmlElement.classList.add('boss-tarek-sprite');

                this.health = new HealthComponent(config.health); // Sobrescreve para usar o HealthComponent
                this.physics = new PhysicsComponent(this, 70, 70); // Tamanho específico para o boss
                // Ajusta o tamanho do elemento HTML
                this.htmlElement.style.width = `${this.physics.width}px`;
                this.htmlElement.style.height = `${this.physics.height}px`;

                this.animation = new AnimationManager(this, {
                    idle: { frames: CONFIG.ASSET_LOADED.tarek_sprite, frameDelay: 150 },
                    // ... outras animações do boss (ataque, habilidades)
                });
                this.animation.play('idle');

                this.abilities = [
                    { name: 'Golpe Devastador', cooldown: 3000, range: 80, damage: 35, lastUsed: 0 },
                    { name: 'Investida Gélida', cooldown: 6000, range: 300, damage: 45, lastUsed: 0 },
                    { name: 'Orbe Congelante', cooldown: 5000, range: 400, damage: 30, lastUsed: 0 },
                    { name: 'Prisão de Gelo', cooldown: 10000, range: 200, damage: 20, lastUsed: 0 }
                ];
                this.aiState = 'combat';
                this.aiTimer = 0;
                this.enraged = false; // Estado de fúria do boss

                this.transitionToState(new EnemyBossState(this)); // Estado inicial
            }

            _updateBossAI(deltaTime) {
                const distanceToPlayer = Math.abs(this.position.x - gameState.player.position.x);
                const currentTime = performance.now();

                // Lógica de Fúria
                if (this.health.currentHealth < this.health.maxHealth * 0.4 && !this.enraged) {
                    this.enraged = true;
                    this.speed *= 1.3;
                    this.damage *= 1.1;
                    this.abilities.forEach(ab => ab.cooldown *= 0.8);
                    EventManager.emit('screen_flash', { color: COLOR_ACCENT_FIRE, duration: 500 });
                    EventManager.emit('add_particles', { type: 'bossIntro', x: this.position.x + 35, y: this.position.y + 35, count: 50 });
                    GameManager.showDialog("TAREK", "Você... é mais forte do que pensei! Mas não vou cair facilmente!");
                }

                this.aiTimer += deltaTime;

                // Movimento para dentro da arena (fixo se câmera fixa)
                // A lógica de arena fixa com cameraOffset será tratada pela renderização global do gameWorldElement
                // mas o boss precisa respeitar limites.
                const arenaMinX = gameState.fixedCamera ? gameState.cameraOffset.x : 0;
                const arenaMaxX = gameState.fixedCamera ? gameState.cameraOffset.x + gameWorldElement.offsetWidth - this.physics.width : CONFIG.WORLD_WIDTH - this.physics.width;

                // Verifica qual habilidade usar
                let chosenAbility = null;
                this.abilities.forEach(ability => {
                    const ready = (currentTime - ability.lastUsed) >= ability.cooldown;
                    if (ready) {
                        if (ability.name === 'Golpe Devastador' && distanceToPlayer < ability.range) {
                            chosenAbility = ability;
                        } else if (ability.name === 'Investida Gélida' && distanceToPlayer > 100 && distanceToPlayer < ability.range) {
                            chosenAbility = ability;
                        } else if (ability.name === 'Orbe Congelante' && distanceToPlayer > 150) {
                            chosenAbility = ability;
                        } else if (ability.name === 'Prisão de Gelo' && Math.random() < 0.3) {
                            chosenAbility = ability;
                        }
                    }
                });
                
                if (chosenAbility && this.aiTimer > 500) {
                    this._executeBossAbility(chosenAbility);
                    this.aiTimer = 0;
                } else {
                    this._moveBossTowardsPlayer(distanceToPlayer);
                }
            }

            _moveBossTowardsPlayer(distance) {
                if (distance > 50) {
                    const direction = gameState.player.position.x > this.position.x ? 1 : -1;
                    this.physics.moveX(direction, this.speed);
                    // Lógica de pulo do boss se necessário
                    if (this.physics.isGrounded && gameState.player.position.y < this.position.y - 50) {
                         this.physics.jump(CONFIG.JUMP_FORCE * 0.8);
                    }
                } else {
                    this.physics.velocity.x = 0; // Para quando está perto
                }
            }

            _executeBossAbility(ability) {
                const direction = gameState.player.position.x > this.position.x ? 1 : -1;
                ability.lastUsed = performance.now();

                switch(ability.name) {
                    case 'Golpe Devastador':
                        EventManager.emit('spawn_projectile', {
                            type: 'bossSlash', x: this.position.x + (direction > 0 ? 70 : -50), y: this.position.y + 10,
                            width: 70, height: 30, duration: 300, damage: ability.damage, origin: 'enemy', knockback: 20
                        });
                        EventManager.emit('screen_shake', { intensity: 6, duration: 300 });
                        break;
                    case 'Investida Gélida':
                        this.physics.applyKnockback(direction * 10, 0); // Impulso para a investida
                        EventManager.emit('spawn_projectile', {
                            type: 'bossDash', x: this.position.x, y: this.position.y,
                            width: 70, height: 50, duration: 800, damage: ability.damage, origin: 'enemy', followBoss: this
                        });
                        EventManager.emit('add_particles', { type: 'dashIce', x: this.position.x + 35, y: this.position.y + 35, count: 30 });
                        EventManager.emit('screen_shake', { intensity: 8, duration: 400 });
                        break;
                    case 'Orbe Congelante':
                        EventManager.emit('spawn_projectile', {
                            type: 'bossIceOrb', x: this.position.x + (direction > 0 ? 80 : -30), y: this.position.y + 20,
                            width: 40, height: 40, duration: 3000, damage: ability.damage, direction: direction, speed: 4, origin: 'enemy'
                        });
                        break;
                    case 'Prisão de Gelo':
                        for (let i = 0; i < 3; i++) {
                            const offsetX = (i - 1) * 80;
                            EventManager.emit('spawn_projectile', {
                                type: 'bossPrison', x: gameState.player.position.x + offsetX - 15, y: gameState.player.position.y - 60,
                                width: 30, height: 120, duration: 5000, damage: ability.damage, origin: 'enemy', trapping: true, delay: i * 200, active: false
                            });
                        }
                        EventManager.emit('screen_shake', { intensity: 5, duration: 600 });
                        break;
                }
            }
        }


        /**
         * @class Projectile
         * @description Classe base para projéteis (habilidades, ataques inimigos), integrada com Object Pooling.
         */
        class Projectile {
            constructor(poolTag) {
                this.poolTag = poolTag;
                this.isActive = false;
                this.position = { x: 0, y: 0 };
                this.width = 0;
                this.height = 0;
                this.speed = 0;
                this.damage = 0;
                this.direction = { x: 0, y: 0 };
                this.originTag = ''; // "player" ou "enemy"
                this.lifetime = 0;
                this.currentLifetime = 0;
                this.piercing = false;
                this.hitTargets = []; // Para projéteis perfurantes
                this.followBoss = null; // Para habilidades que seguem o boss
                this.delay = 0; // Para armadilhas com delay de ativação
                this.trapping = false; // Para prisões que prendem o jogador

                // Elemento DOM para o projétil
                this.htmlElement = document.createElement('div');
                this.htmlElement.className = `game-entity projectile-sprite projectile-${poolTag}`;
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.display = 'none'; // Esconder por padrão
                gameWorldElement.appendChild(this.htmlElement);
            }

            /**
             * Inicializa o projétil ao ser retirado da pool.
             * @param {object} config - Configurações do projétil.
             */
            initialize(config) {
                this.isActive = true;
                this.position.x = config.x;
                this.position.y = config.y;
                this.width = config.width || 20;
                this.height = config.height || 20;
                this.speed = config.speed || 0;
                this.damage = config.damage || 0;
                this.direction.x = config.direction || 0;
                this.direction.y = config.directionY || 0; // Adicionado para direções Y
                this.originTag = config.origin || '';
                this.lifetime = config.duration || 1000;
                this.currentLifetime = this.lifetime;
                this.piercing = config.piercing || false;
                this.hitTargets = []; // Reseta hits para cada uso
                this.followBoss = config.followBoss || null;
                this.delay = config.delay || 0;
                this.trapping = config.trapping || false;

                this.htmlElement.style.display = 'block'; // Mostrar
                this.htmlElement.style.width = `${this.width}px`;
                this.htmlElement.style.height = `${this.height}px`;

                // Configura o visual do projétil baseado no tipo
                switch(this.poolTag) {
                    case 'darkShotProjectile':
                        this.htmlElement.style.backgroundColor = COLOR_UMBRA;
                        this.htmlElement.style.borderRadius = '0'; // Rectangular
                        break;
                    case 'etherealOrbProjectile':
                        this.htmlElement.style.borderRadius = '50%';
                        this.htmlElement.style.backgroundColor = COLOR_UMBRA;
                        this.htmlElement.style.boxShadow = `0 0 10px ${COLOR_UMBRA}`;
                        break;
                    case 'enemyIceShot':
                        this.htmlElement.style.backgroundColor = COLOR_ACCENT_ICE;
                        this.htmlElement.style.borderRadius = '0';
                        break;
                    case 'bossSlash':
                        this.htmlElement.style.backgroundColor = COLOR_ACCENT_FIRE;
                        this.htmlElement.style.borderRadius = '0';
                        break;
                    case 'bossIceOrb':
                        this.htmlElement.style.borderRadius = '50%';
                        this.htmlElement.style.backgroundColor = COLOR_ACCENT_ICE;
                        break;
                    case 'bossPrison':
                        this.htmlElement.style.backgroundColor = 'rgba(168, 208, 230, 0.7)';
                        this.htmlElement.style.border = `3px solid ${COLOR_ACCENT_ICE}`;
                        this.htmlElement.style.borderRadius = '0';
                        break;
                    case 'bossDash':
                        this.htmlElement.style.backgroundColor = 'rgba(255, 107, 107, 0.5)';
                        this.htmlElement.style.borderRadius = '0';
                        break;
                }
            }

            /**
             * Atualiza a lógica do projétil a cada frame.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                if (!this.isActive) return;

                if (this.delay > 0) {
                    this.delay -= deltaTime;
                    if (this.delay <= 0) {
                        // Ativa o projétil após o delay
                        this.isActive = true;
                        if (this.poolTag === 'bossPrison') { // type é para lógica, poolTag para o visual
                            EventManager.emit('add_particles', { type: 'prisonActivate', x: this.position.x + this.width / 2, y: this.position.y + this.height / 2, count: 20 });
                        }
                    } else {
                        this.htmlElement.style.display = 'none'; // Esconder durante o delay
                        return; // Não atualiza movimento ou colisão durante o delay
                    }
                } else {
                    this.htmlElement.style.display = 'block'; // Garantir visibilidade após delay
                }

                // Lógica de movimento e lifetime
                if (this.followBoss) {
                    this.position.x = this.followBoss.position.x;
                    this.position.y = this.followBoss.position.y;
                } else {
                    this.position.x += this.speed * this.direction.x * (deltaTime / 1000);
                    this.position.y += this.speed * this.direction.y * (deltaTime / 1000);
                }

                this.currentLifetime -= deltaTime;
                if (this.currentLifetime <= 0) {
                    this.deactivate(); // Retorna à pool
                    return;
                }

                this._checkCollisions();

                // Lógica específica para armadilhas (prisões)
                if (this.trapping && this.isActive) {
                    const playerRect = {
                        x: gameState.player.position.x,
                        y: gameState.player.position.y,
                        width: CONFIG.PLAYER_WIDTH,
                        height: gameState.player.physics.height
                    };
                    const prisonRect = {
                        x: this.position.x,
                        y: this.position.y,
                        width: this.width,
                        height: this.height
                    };

                    if (this._checkAABB(playerRect, prisonRect)) {
                        // Reduzir velocidade do jogador
                        gameState.player.physics.velocity.x *= 0.1;
                        gameState.player.physics.velocity.y *= 0.1;
                        // Dano contínuo
                        if (Math.random() < 0.05) { // 5% de chance de dano por frame
                            gameState.player.health.takeDamage(this.damage * (deltaTime / 1000), 0); // Sem invencibilidade
                        }
                    }
                }
            }

            _checkCollisions() {
                const targetRect = { x: this.position.x, y: this.position.y, width: this.width, height: this.height };

                if (this.originTag === 'player') {
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const enemy = enemies[i];
                        const enemyRect = { x: enemy.position.x, y: enemy.position.y, width: enemy.physics.width, height: enemy.physics.height };

                        if (!this.hitTargets.includes(enemy) && this._checkAABB(targetRect, enemyRect)) {
                            enemy.takeDamage(this.damage);
                            if (!this.piercing) {
                                this.deactivate();
                                return; // Atingiu um inimigo, desativa e sai
                            } else {
                                this.hitTargets.push(enemy); // Adiciona ao hitTargets para não atingir de novo
                            }
                        }
                    }
                } else if (this.originTag === 'enemy') {
                    const playerRect = { x: gameState.player.position.x, y: gameState.player.position.y, width: CONFIG.PLAYER_WIDTH, height: gameState.player.physics.height };
                    if (this._checkAABB(targetRect, playerRect)) {
                        gameState.player.health.takeDamage(this.damage);
                        this.deactivate(); // Atingiu o jogador, desativa
                        return;
                    }
                }

                // Colisão com plataformas (para projéteis que não atravessam paredes)
                if (this.poolTag !== 'bossDash' && this.poolTag !== 'bossPrison' && this.poolTag !== 'explosion') {
                    for (const platform of platforms) {
                        const platformRect = { x: platform.x, y: platform.y, width: platform.width, height: platform.height };
                        if (this._checkAABB(targetRect, platformRect)) {
                            this.deactivate(); // Colidiu com plataforma, desativa
                            return;
                        }
                    }
                }
            }

            _checkAABB(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            /**
             * Retorna o projétil para a pool.
             */
            deactivate() {
                this.isActive = false;
                this.htmlElement.style.display = 'none'; // Esconder
                ObjectPooler.Instance.returnToPool(this.poolTag, this);
            }

            /**
             * Atualiza a posição do elemento DOM do projétil.
             */
            render() {
                if (!this.isActive || this.delay > 0) return; // Não renderiza durante o delay

                this.htmlElement.style.left = `${this.position.x}px`;
                this.htmlElement.style.top = `${this.position.y}px`;

                // Transparência para bossDash
                if (this.poolTag === 'bossDash') {
                    const alpha = this.currentLifetime / this.lifetime;
                    this.htmlElement.style.opacity = `${alpha * 0.5}`;
                } else {
                    this.htmlElement.style.opacity = '1';
                }
            }
        }

        /**
         * @class Particle
         * @description Classe para partículas de efeitos visuais, integrada com Object Pooling.
         *              Renderiza no DOM como divs pequenas e coloridas.
         */
        class Particle {
            constructor(poolTag) {
                this.poolTag = poolTag;
                this.isActive = false;
                this.x = 0;
                this.y = 0;
                this.vx = 0;
                this.vy = 0;
                this.size = 0;
                this.alpha = 1;
                this.color = '';
                this.gravity = false;
                this.life = 0;
                this.maxLife = 0;

                this.htmlElement = document.createElement('div');
                this.htmlElement.className = `particle particle-${poolTag}`;
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.borderRadius = '50%';
                this.htmlElement.style.display = 'none';
                gameWorldElement.appendChild(this.htmlElement);
            }

            /**
             * Inicializa a partícula ao ser retirada da pool.
             * @param {object} config - Configurações da partícula.
             */
            initialize(config) {
                this.isActive = true;
                this.x = config.x + (Math.random() - 0.5) * 20;
                this.y = config.y + (Math.random() - 0.5) * 20;
                this.vx = (Math.random() - 0.5) * 4;
                this.vy = (Math.random() - 0.5) * 4;
                this.size = 2 + Math.random() * 3;
                this.alpha = 1;
                this.gravity = false;
                this.life = 500;
                this.maxLife = 500;
                this.color = config.color || '#ffffff';

                switch(config.type) {
                    case 'snow':
                        this.vx = (Math.random() - 0.5) * 0.5;
                        this.vy = 1 + Math.random() * 2;
                        this.size = 2 + Math.random() * 4;
                        this.life = 8000 + Math.random() * 4000;
                        this.maxLife = 12000;
                        break;
                    case 'jumpDust':
                    case 'landDust':
                        this.vx = (Math.random() - 0.5) * 3;
                        this.vy = -1 - Math.random() * 2;
                        this.color = '#aaaaaa';
                        this.life = 400 + Math.random() * 200;
                        this.maxLife = 600;
                        this.gravity = true;
                        break;
                    case 'hitSpark':
                        this.vx = (Math.random() - 0.5) * 6;
                        this.vy = (Math.random() - 0.5) * 6;
                        this.color = '#ffff00';
                        this.life = 300 + Math.random() * 200;
                        this.maxLife = 500;
                        break;
                    case 'deathExplosion':
                    case 'explosion':
                        this.vx = (Math.random() - 0.5) * 10;
                        this.vy = (Math.random() - 0.5) * 10;
                        this.color = (Math.random() > 0.5 ? COLOR_ACCENT_FIRE : COLOR_ACCENT_GOLD);
                        this.life = 800 + Math.random() * 400;
                        this.maxLife = 1200;
                        this.size = 3 + Math.random() * 5;
                        break;
                    case 'projectileTrail':
                        this.vx = (Math.random() - 0.5) * 2;
                        this.vy = (Math.random() - 0.5) * 2;
                        this.color = COLOR_UMBRA;
                        this.life = 300 + Math.random() * 200;
                        this.maxLife = 500;
                        this.size = 1 + Math.random() * 2;
                        break;
                    case 'umbraFuria':
                        this.vx = (Math.random() - 0.5) * 5;
                        this.vy = (Math.random() - 0.5) * 5;
                        this.color = COLOR_ACCENT_GOLD;
                        this.life = 500 + Math.random() * 300;
                        this.maxLife = 800;
                        this.size = 3 + Math.random() * 4;
                        this.gravity = false;
                        break;
                    case 'bossIntro':
                        this.vx = (Math.random() - 0.5) * 8;
                        this.vy = (Math.random() - 0.5) * 8;
                        this.color = COLOR_ACCENT_FIRE;
                        this.life = 1000 + Math.random() * 500;
                        this.maxLife = 1500;
                        this.size = 4 + Math.random() * 6;
                        break;
                    case 'dashUmbra':
                        this.vx = (Math.random() - 0.5) * 8;
                        this.vy = (Math.random() - 0.5) * 4;
                        this.color = COLOR_UMBRA;
                        this.life = 400 + Math.random() * 300;
                        this.maxLife = 700;
                        break;
                    case 'prisonActivate':
                        this.vx = (Math.random() - 0.5) * 5;
                        this.vy = (Math.random() - 0.5) * 5;
                        this.color = COLOR_ACCENT_ICE;
                        this.life = 500 + Math.random() * 300;
                        this.maxLife = 800;
                        this.size = 2 + Math.random() * 4;
                        break;
                    case 'xpGain':
                        this.vx = (Math.random() - 0.5) * 3;
                        this.vy = -3 - Math.random() * 2;
                        this.color = COLOR_XP;
                        this.life = 800 + Math.random() * 400;
                        this.maxLife = 1200;
                        this.size = 2 + Math.random() * 3;
                        this.gravity = true;
                        break;
                    default:
                        this.color = '#ffffff';
                        this.life = 500;
                        this.maxLife = 500;
                }
                this.htmlElement.style.display = 'block';
                this.htmlElement.style.backgroundColor = this.color;
                this.htmlElement.style.width = `${this.size}px`;
                this.htmlElement.style.height = `${this.size}px`;
            }

            /**
             * Atualiza a lógica da partícula.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            update(deltaTime) {
                if (!this.isActive) return;

                this.x += this.vx * (deltaTime / 16);
                this.y += this.vy * (deltaTime / 16);

                if (this.gravity) {
                    this.vy += CONFIG.GRAVITY * 0.3;
                }

                this.life -= deltaTime;

                if (this.life < this.maxLife * 0.3) {
                    this.alpha = this.life / (this.maxLife * 0.3);
                }

                if (this.life <= 0) {
                    this.deactivate(); // Retorna à pool
                }
            }

            /**
             * Retorna a partícula para a pool.
             */
            deactivate() {
                this.isActive = false;
                this.htmlElement.style.display = 'none'; // Esconder
                ObjectPooler.Instance.returnToPool(this.poolTag, this);
            }

            /**
             * Atualiza a posição e opacidade do elemento DOM da partícula.
             */
            render() {
                if (!this.isActive) return;

                // Não renderiza se fora da tela (para partículas de neve que vão embora)
                // Os valores aqui serão relativos ao gameWorldElement
                // A posição x,y já é o centro da partícula
                const currentX = this.x - gameWorldElement.offsetLeft;
                const currentY = this.y - gameWorldElement.offsetTop;

                if (currentX < -20 || currentX > gameWorldElement.offsetWidth + 20 || currentY < -20 || currentY > gameWorldElement.offsetHeight + 20) {
                    // Se a partícula sair do viewport, desativá-la
                    this.deactivate();
                    return;
                }
                
                this.htmlElement.style.left = `${this.x}px`;
                this.htmlElement.style.top = `${this.y}px`;
                this.htmlElement.style.opacity = `${this.alpha}`;
            }
        }

        /**
         * @class Platform
         * @description Representa uma plataforma no jogo.
         *              Agora cria e gerencia seu próprio elemento DOM.
         */
        class Platform {
            constructor(x, y, width, height, type = 'ground', slippery = false) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type; // 'ground', 'platform', 'spike'
                this.slippery = slippery; // Plataforma escorregadia

                this.htmlElement = document.createElement('div');
                this.htmlElement.className = `platform-entity platform-${this.type}`;
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.width = `${this.width}px`;
                this.htmlElement.style.height = `${this.height}px`;
                
                if (this.slippery) {
                    this.htmlElement.classList.add('slippery');
                }
                gameWorldElement.appendChild(this.htmlElement);

                // Para spikes, a renderização é mais complexa e pode precisar de um SVG interno ou CSS complexo.
                // Por simplicidade, adicionamos uma classe para o CSS ou um fallback visual.
                if (this.type === 'spike') {
                    this.htmlElement.style.backgroundColor = COLOR_SPIKE; // Fallback visual simples
                    this.htmlElement.style.clipPath = 'polygon(0% 100%, 50% 0%, 100% 100%)'; // Forma de triângulo
                }
            }

            render() {
                // Atualiza a posição do elemento HTML
                this.htmlElement.style.left = `${this.x}px`;
                this.htmlElement.style.top = `${this.y}px`;
            }

            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }

        /**
         * @class FallingSpike
         * @description Representa um espinho que cai.
         *              Agora cria e gerencia seu próprio elemento DOM.
         */
        class FallingSpike {
            constructor(x, y, width, height, speed) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.active = false;

                this.htmlElement = document.createElement('div');
                this.htmlElement.className = 'game-entity falling-spike-entity';
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.width = `${this.width}px`;
                this.htmlElement.style.height = `${this.height}px`;
                this.htmlElement.style.backgroundColor = COLOR_SPIKE; // Cor padrão para visualização simples
                this.htmlElement.style.clipPath = 'polygon(0% 100%, 50% 0%, 100% 100%)'; // Forma de triângulo
                this.htmlElement.style.display = 'none'; // Esconder por padrão
                gameWorldElement.appendChild(this.htmlElement);
            }

            update(deltaTime) {
                // Ativa quando o jogador está abaixo ou perto
                if (!this.active &&
                    gameState.player.position.x > this.x - 100 &&
                    gameState.player.position.x < this.x + this.width + 100 &&
                    gameState.player.position.y > this.y) {
                    this.active = true;
                    this.htmlElement.style.display = 'block';
                }

                if (this.active) {
                    this.y += this.speed * (deltaTime / 1000);
                }
            }

            render() {
                if (!this.active) return;
                
                this.htmlElement.style.left = `${this.x}px`;
                this.htmlElement.style.top = `${this.y}px`;
            }

            checkCollisionWithPlayer() {
                if (!this.active || gameState.player.health.isInvincible) return false;

                const playerRect = {
                    x: gameState.player.position.x,
                    y: gameState.player.position.y,
                    width: CONFIG.PLAYER_WIDTH,
                    height: gameState.player.physics.height
                };
                const spikeRect = {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };

                if (gameState.player.physics._checkCollision(playerRect.x, playerRect.y, playerRect.width, playerRect.height, spikeRect)) {
                    gameState.player.health.takeDamage(15);
                    EventManager.emit('add_particles', { type: 'hitSpark', x: spikeRect.x + spikeRect.width/2, y: spikeRect.y + spikeRect.height/2, count: 10 });
                    return true;
                }
                return false;
            }

            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }

        /**
         * @class Checkpoint
         * @description Representa um ponto de salvamento.
         *              Cria e gerencia seu próprio elemento DOM invisível para detecção de colisão.
         */
        class Checkpoint {
            constructor(x, y, width, height, name, description) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.name = name;
                this.description = description;
                this.triggered = false; // Para não salvar múltiplas vezes

                this.htmlElement = document.createElement('div');
                this.htmlElement.className = 'checkpoint-entity';
                this.htmlElement.style.position = 'absolute';
                this.htmlElement.style.width = `${this.width}px`;
                this.htmlElement.style.height = `${this.height}px`;
                this.htmlElement.style.left = `${this.x}px`;
                this.htmlElement.style.top = `${this.y}px`;
                this.htmlElement.style.backgroundColor = 'rgba(0, 255, 0, 0.2)'; // Para debug visual
                this.htmlElement.style.display = 'none'; // Esconder no jogo final
                gameWorldElement.appendChild(this.htmlElement);
            }

            checkCollisionWithPlayer() {
                if (this.triggered) return; // Já foi ativado
                
                const playerRect = {
                    x: gameState.player.position.x,
                    y: gameState.player.position.y,
                    width: CONFIG.PLAYER_WIDTH,
                    height: CONFIG.PLAYER_HEIGHT // Usar altura total do jogador para colisão com checkpoint
                };
                const cpRect = {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };

                if (gameState.player.physics._checkCollision(playerRect.x, playerRect.y, playerRect.width, playerRect.height, cpRect)) {
                    GameManager.saveCheckpoint(this.name, this.description);
                    this.triggered = true;
                    this.htmlElement.style.backgroundColor = 'rgba(255, 255, 0, 0.2)'; // Mudar cor após trigger
                }
            }

            render() {
                // Nada a renderizar ativamente, apenas o elemento DOM é para detecção de colisão
                // Mas podemos usar para debug
                if (window.DEBUG_MODE) {
                    this.htmlElement.style.display = 'block';
                }
            }

            destroy() {
                if (this.htmlElement && this.htmlElement.parentNode) {
                    this.htmlElement.parentNode.removeChild(this.htmlElement);
                }
            }
        }


        // =================================================================================================
        // ===== 6. OBJECT POOLER (Object Pooling Pattern) =================================================
        // =================================================================================================

        /**
         * @class ObjectPooler
         * @description Gerencia pools de objetos reutilizáveis para otimização de performance.
         */
        class ObjectPooler {
            constructor() {
                if (ObjectPooler.Instance) {
                    return ObjectPooler.Instance;
                }
                ObjectPooler.Instance = this;

                this.pools = {
                    // Pool para projéteis do jogador
                    darkShotProjectile: [], 
                    etherealOrbProjectile: [], 
                    
                    // Pool para projéteis inimigos
                    enemyIceShot: [], 
                    bossSlash: [], 
                    bossIceOrb: [], 
                    bossPrison: [], 
                    bossDash: [], 

                    // Pool para partículas
                    snowParticle: [],
                    jumpDustParticle: [],
                    landDustParticle: [],
                    hitSparkParticle: [],
                    deathExplosionParticle: [],
                    projectileTrailParticle: [],
                    umbraFuriaParticle: [],
                    bossIntroParticle: [],
                    dashIceParticle: [],
                    prisonActivateParticle: [],
                    xpGainParticle: []
                };

                // Configurações de tamanho inicial das pools (ajustar conforme necessidade)
                this.poolSizes = {
                    darkShotProjectile: 5,
                    etherealOrbProjectile: 3,
                    enemyIceShot: 10,
                    bossSlash: 2,
                    bossIceOrb: 5,
                    bossPrison: 3,
                    bossDash: 1, 
                    
                    snowParticle: 300,
                    jumpDustParticle: 30,
                    landDustParticle: 30,
                    hitSparkParticle: 50,
                    deathExplosionParticle: 10,
                    projectileTrailParticle: 100,
                    umbraFuriaParticle: 20,
                    bossIntroParticle: 20,
                    dashIceParticle: 30,
                    prisonActivateParticle: 10,
                    xpGainParticle: 20
                };
            }

            /**
             * Inicializa todas as pools com o número pré-definido de objetos.
             */
            initializePools() {
                for (const tag in this.poolSizes) {
                    const size = this.poolSizes[tag];
                    for (let i = 0; i < size; i++) {
                        if (tag.includes('Projectile')) {
                            this.pools[tag].push(new Projectile(tag));
                        } else if (tag.includes('Particle')) {
                            this.pools[tag].push(new Particle(tag));
                        }
                    }
                }
            }

            /**
             * Pega um objeto da pool. Se a pool estiver vazia, cria um novo (opcionalmente).
             * @param {string} tag - A tag da pool.
             * @param {object} config - Configurações para inicializar o objeto.
             * @returns {object} - O objeto pronto para uso.
             */
            getFromPool(tag, config) {
                if (!this.pools[tag]) {
                    console.warn(`Pool com tag '${tag}' não existe.`);
                    return null;
                }

                let obj = this.pools[tag].find(o => !o.isActive); // Encontra um objeto inativo
                
                if (!obj) {
                    // Se não houver objetos inativos, cria um novo (expansão dinâmica da pool)
                    if (tag.includes('Projectile')) {
                        obj = new Projectile(tag);
                    } else if (tag.includes('Particle')) {
                        obj = new Particle(tag);
                    }
                    this.pools[tag].push(obj);
                    // console.warn(`Pool '${tag}' expandida dinamicamente. Considere aumentar o tamanho inicial.`);
                }
                
                obj.initialize(config); // Re-inicializa o objeto
                return obj;
            }

            /**
             * Retorna um objeto para a pool, marcando-o como inativo.
             * @param {string} tag - A tag da pool.
             * @param {object} obj - O objeto a ser retornado.
             */
            returnToPool(tag, obj) {
                if (this.pools[tag] && this.pools[tag].includes(obj)) {
                    obj.isActive = false;
                    obj.htmlElement.style.display = 'none'; // Garante que o elemento DOM está escondido
                } else {
                    console.warn(`Tentou retornar objeto para pool '${tag}' que não pertence ou não existe.`);
                }
            }

            /**
             * Retorna todos os objetos ativos para suas respectivas pools.
             */
            returnAllActiveToPools() {
                for (const tag in this.pools) {
                    this.pools[tag].forEach(obj => {
                        if (obj.isActive) {
                            obj.deactivate(); // Chama o método deactivate do próprio objeto
                        }
                    });
                }
            }

            /**
             * Obtém uma lista de todos os objetos ativos de uma pool específica.
             * @param {string} tag - A tag da pool.
             * @returns {Array} - Lista de objetos ativos.
             */
            getActiveObjects(tag) {
                return this.pools[tag] ? this.pools[tag].filter(obj => obj.isActive) : [];
            }
        }


        // =================================================================================================
        // ===== 7. CLASSES DE HABILIDADES (PlayerAbility) =================================================
        // =================================================================================================

        /**
         * @class PlayerAbility
         * @description Classe base abstrata para todas as habilidades do jogador.
         */
        class PlayerAbility {
            constructor(player, abilityData) {
                this.player = player;
                this.name = abilityData.name;
                this.description = abilityData.description;
                this.manaCost = abilityData.manaCost;
                this.cooldown = abilityData.cooldown * 1000; // Converte segundos para ms
                this.currentCooldown = 0; // Cooldown restante (em ms)
                this.damageModifier = abilityData.damageModifier || 1; // Modificador de dano se aplicável
                this.animationKey = abilityData.animationKey; // Animação a ser tocada
                this.key = abilityData.key; // Tecla associada

                // Event Listeners para feedback visual
                EventManager.subscribe('player_mana_changed', (data) => {
                    // Atualiza a UI da habilidade se mana afetar
                });
            }

            /**
             * Tenta ativar a habilidade.
             * @returns {boolean} - True se a mana foi usada com sucesso e a habilidade ativada, false caso contrário.
             */
            activate() {
                if (this.currentCooldown <= 0 && this.player.mana.useMana(this.manaCost)) {
                    this._execute();
                    this.currentCooldown = this.cooldown;
                    EventManager.emit('ability_used', { key: this.key, cooldown: this.cooldown });
                    return true;
                }
                return false;
            }

            /**
             * Lógica de execução específica da habilidade (deve ser implementada pelas subclasses).
             * @protected
             */
            _execute() {
                throw new Error("Método _execute() deve ser implementado pela subclasse.");
            }

            /**
             * Atualiza o cooldown da habilidade.
             * @param {number} deltaTime - Tempo decorrido (em ms).
             */
            updateCooldown(deltaTime) {
                if (this.currentCooldown > 0) {
                    this.currentCooldown -= deltaTime;
                    if (this.currentCooldown < 0) {
                        this.currentCooldown = 0;
                    }
                    EventManager.emit('ability_cooldown_update', { key: this.key, current: this.currentCooldown, max: this.cooldown });
                }
            }
        }

        /**
         * @class DarkShotAbility
         * @description Habilidade: Tiro Sombrio (U).
         */
        class DarkShotAbility extends PlayerAbility {
            constructor(player, abilityData) {
                super(player, abilityData);
                this.name = "Tiro Sombrio";
                this.description = "Dispara um projétil de energia sombria à distância.";
                this.manaCost = 0;
                this.cooldown = 0.6 * 1000;
                this.animationKey = 'attack_u';
            }

            _execute() {
                EventManager.emit('sfx_play', 'sfx_attack_u');
                // Transiciona o jogador para o estado de habilidade de ataque
                this.player.transitionToState(new PlayerAbilityState(this.player, this.animationKey));

                // Calcula a posição de spawn do projétil baseada na direção do jogador
                const spawnX = this.player.position.x + (this.player.facing === 'right' ? CONFIG.PLAYER_WIDTH : -25);
                const spawnY = this.player.position.y + CONFIG.PLAYER_HEIGHT / 2 - 4; // Ajusta a altura

                EventManager.emit('spawn_projectile', {
                    type: 'darkShotProjectile',
                    x: spawnX,
                    y: spawnY,
                    width: 25,
                    height: 8,
                    duration: 1500,
                    damage: this.player.damage * this.damageModifier,
                    direction: this.player.facing === 'right' ? 1 : -1,
                    speed: 8,
                    origin: 'player',
                    piercing: false
                });
            }
        }

        /**
         * @class AgileShadowAbility
         * @description Habilidade: Sombra Ágil (I).
         */
        class AgileShadowAbility extends PlayerAbility {
            constructor(player, abilityData) {
                super(player, abilityData);
                this.name = "Sombra Ágil";
                this.description = "Deslocamento rápido que atravessa inimigos e concede invulnerabilidade temporária.";
                this.manaCost = 25;
                this.cooldown = 5 * 1000;
                this.animationKey = 'attack_i';
            }

            _execute() {
                EventManager.emit('sfx_play', 'sfx_ability_i');
                this.player.transitionToState(new PlayerAbilityState(this.player, this.animationKey));

                const dashForce = 12; // Velocidade do dash
                const invincibilityDuration = 300; // Duração da invencibilidade durante o dash

                // Aplica a força do dash
                this.player.physics.applyKnockback(
                    (this.player.facing === 'right' ? dashForce : -dashForce),
                    0 // Não altera a velocidade vertical
                );

                // Concede invencibilidade
                this.player.health.isInvincible = true;
                this.player.health.invincibilityTimer = invincibilityDuration;

                // Efeito de partículas
                EventManager.emit('add_particles', { type: 'dashUmbra', x: this.player.position.x + CONFIG.PLAYER_WIDTH / 2, y: this.player.position.y + CONFIG.PLAYER_HEIGHT / 2, count: 20 });
            }
        }

        /**
         * @class EtherealOrbAbility
         * @description Habilidade: Orbe Etéreo (O).
         */
        class EtherealOrbAbility extends PlayerAbility {
            constructor(player, abilityData) {
                super(player, abilityData);
                this.name = "Orbe Etéreo";
                this.description = "Lança um orbe de energia sombria que perfura múltiplos inimigos.";
                this.manaCost = 35;
                this.cooldown = 4 * 1000;
                this.animationKey = 'attack_o';
            }

            _execute() {
                EventManager.emit('sfx_play', 'sfx_ability_o');
                this.player.transitionToState(new PlayerAbilityState(this.player, this.animationKey));

                const spawnX = this.player.position.x + (this.player.facing === 'right' ? CONFIG.PLAYER_WIDTH : -35);
                const spawnY = this.player.position.y + CONFIG.PLAYER_HEIGHT / 2 - 10;

                EventManager.emit('spawn_projectile', {
                    type: 'etherealOrbProjectile',
                    x: spawnX,
                    y: spawnY,
                    width: 35,
                    height: 35,
                    duration: 3000,
                    damage: this.player.damage * this.damageModifier * 1.8,
                    direction: this.player.facing === 'right' ? 1 : -1,
                    speed: 6,
                    origin: 'player',
                    piercing: true
                });
            }
        }

        /**
         * @class UmbraFuryAbility
         * @description Habilidade: Fúria de Umbra (P).
         */
        class UmbraFuryAbility extends PlayerAbility {
            constructor(player, abilityData) {
                super(player, abilityData);
                this.name = "Fúria de Umbra";
                this.description = "Canaliza a energia de Umbra para amplificar poder.";
                this.manaCost = 50;
                this.cooldown = 8 * 1000;
                this.animationKey = 'ultimate';
                this.isActive = false;
                this.duration = CONFIG.UMBRA_FURY_DURATION;
                this.currentDuration = 0;
            }

            _execute() {
                EventManager.emit('sfx_play', 'sfx_ability_p');
                this.player.transitionToState(new PlayerAbilityState(this.player, this.animationKey));

                this.isActive = true;
                this.currentDuration = this.duration;

                // Aplica buffs
                this.player.damage *= CONFIG.UMBRA_FURY_DAMAGE_BOOST;
                this.player.currentSpeed *= CONFIG.UMBRA_FURY_SPEED_BOOST;
                EventManager.emit('add_particles', { type: 'umbraFuria', x: this.player.position.x + CONFIG.PLAYER_WIDTH / 2, y: this.player.position.y + CONFIG.PLAYER_HEIGHT / 2, count: 30 });
            }

            updateCooldown(deltaTime) {
                super.updateCooldown(deltaTime); // Chama o update de cooldown da classe base

                if (this.isActive) {
                    this.currentDuration -= deltaTime;
                    if (this.currentDuration <= 0) {
                        this.deactivate();
                    }
                }
            }

            deactivate() {
                if (this.isActive) {
                    this.isActive = false;
                    // Remove buffs
                    this.player.damage /= CONFIG.UMBRA_FURY_DAMAGE_BOOST;
                    this.player.currentSpeed /= CONFIG.UMBRA_FURY_SPEED_BOOST;
                    // Se a animação de ultimate ainda estiver tocando, força transição para idle
                    if (this.player.currentState instanceof PlayerAbilityState && this.player.currentState.animationKey === this.animationKey) {
                        this.player.transitionToState(new PlayerIdleState(this.player));
                    }
                    EventManager.emit('umbra_fury_ended');
                }
            }
        }

        /**
         * @class PlayerAbilityFactory
         * @description Fábrica para criar instâncias de habilidades.
         */
        class PlayerAbilityFactory {
            static createAbility(abilityName) {
                switch (abilityName) {
                    case "Tiro Sombrio": return DarkShotAbility;
                    case "Sombra Ágil": return AgileShadowAbility;
                    case "Orbe Etéreo": return EtherealOrbAbility;
                    case "Fúria de Umbra": return UmbraFuryAbility;
                    default: return null;
                }
            }
        }


        // =================================================================================================
        // ===== 8. GERENCIADORES GLOBAIS (Singleton) ======================================================
        // =================================================================================================

        /**
         * @class GameManager
         * @description Gerencia o estado geral do jogo, fases, save/load, pausas e cutscenes.
         */
        class GameManager {
            constructor() {
                if (GameManager.Instance) {
                    return GameManager.Instance;
                }
                GameManager.Instance = this;

                this.gameSettings = {
                    volume: 0.7, sfxVolume: 0.8, musicVolume: 0.6,
                    showFPS: false, particleQuality: 'high', screenShake: true
                };
                this._loadSettings();

                // Listeners de eventos de jogo
                EventManager.subscribe('entity_died', (entity) => {
                    if (entity.isPlayer) {
                        this.gameOver();
                    }
                });
                EventManager.subscribe('enemy_defeated', (enemy) => {
                    if (enemy.type === 'boss') {
                        this.defeatBoss(enemy);
                    } else {
                        gameState.player.gainXP(enemy.xpValue);
                    }
                });
                EventManager.subscribe('level_up', (data) => {
                    this.togglePause(true); // Pausa o jogo para o menu de level up
                });
                EventManager.subscribe('ui_level_up_applied', () => {
                    this.togglePause(false); // Despausa após aplicar upgrade
                });
                EventManager.subscribe('game_state_change', (stateName) => {
                    console.log(`Game State Changed to: ${stateName}`);
                });

                EventManager.emit('game_state_change', 'INITIALIZED');
            }

            /**
             * Inicia um novo jogo.
             * @param {string} playerName - Nome do jogador.
             */
            startGame(playerName) {
                gameState.playerName = playerName;
                gameState.inMenu = false;
                gameState.gameStarted = true;
                UIManager.Instance.hideMainMenu(); // CORREÇÃO: UIManager.Instance.hideMainMenu()
                
                // Configura o jogador (com dados iniciais ou carregados)
                const defaultPlayerConfig = {
                    baseHealth: 100, baseMana: 100, baseSpeed: CONFIG.PLAYER_BASE_SPEED,
                    baseDamage: 15, manaRegenRate: CONFIG.MANA_REGEN_RATE,
                    abilities: [
                        { key: 'U', name: 'Tiro Sombrio', manaCost: 0, cooldown: 0.6, damageModifier: 1.2, animationKey: 'attack_u' },
                        { key: 'I', name: 'Sombra Ágil', manaCost: 25, cooldown: 5, animationKey: 'attack_i' },
                        { key: 'O', name: 'Orbe Etéreo', manaCost: 35, cooldown: 4, damageModifier: 1.8, animationKey: 'attack_o' },
                        { key: 'P', name: 'Fúria de Umbra', manaCost: 50, cooldown: 8, animationKey: 'ultimate' }
                    ]
                };
                gameState.player = new Player(playerName, defaultPlayerConfig);
                
                // Carrega progresso salvo se existir, mas sempre começa do nível 1 por padrão no Ben 10-ish.
                const savedData = this._loadProgress();
                if (savedData) {
                    this._applySavedData(savedData);
                } else {
                    UIManager.Instance.updatePlayerStats(gameState.player.level, gameState.player.damage); // CORREÇÃO: UIManager.Instance
                    UIManager.Instance.updateHealth({ current: gameState.player.health.currentHealth, max: gameState.player.health.maxHealth }); // CORREÇÃO: UIManager.Instance
                    UIManager.Instance.updateMana({ current: gameState.player.mana.currentMana, max: gameState.player.mana.maxMana }); // CORREÇÃO: UIManager.Instance
                    UIManager.Instance.updateXP({ current: gameState.player.xp, max: gameState.player.nextLevelXP }); // CORREÇÃO: UIManager.Instance
                }

                AudioManager.Instance.stopMusic(); // CORREÇÃO: AudioManager.Instance
                this.showIntroCutscene();

                EventManager.emit('game_state_change', 'STARTED');
            }

            /**
             * Carrega uma fase do jogo.
             * @param {number} phaseNumber - O número da fase.
             * @param {string} checkpointName - Nome do checkpoint para posicionamento (opcional).
             */
            loadPhase(phaseNumber, checkpointName = null) {
                gameState.currentPhase = phaseNumber;
                
                // Limpa todas as entidades e efeitos anteriores do DOM
                if (gameState.player) gameState.player.destroy(); // Remove player do DOM antes de limpar
                enemies.forEach(enemy => enemy.destroy());
                platforms.forEach(platform => platform.destroy());
                fallingSpikes.forEach(spike => spike.destroy());
                checkpoints.forEach(cp => cp.destroy());
                
                enemies = [];
                platforms = [];
                fallingSpikes = [];
                checkpoints = [];

                ObjectPooler.Instance.returnAllActiveToPools(); // Retorna todos os objetos das pools
                
                // Recria o jogador se ele foi destruído (ao reiniciar uma fase)
                if (!gameState.player) {
                    const savedData = this._loadProgress();
                    if (savedData) {
                        gameState.player = new Player(savedData.playerName, {
                            baseHealth: savedData.playerMaxHealth, baseMana: savedData.playerMaxMana, baseSpeed: savedData.playerSpeed,
                            baseDamage: savedData.playerDamage, manaRegenRate: CONFIG.MANA_REGEN_RATE,
                            abilities: [
                                { key: 'U', name: 'Tiro Sombrio', manaCost: 0, cooldown: 0.6, damageModifier: 1.2, animationKey: 'attack_u' },
                                { key: 'I', name: 'Sombra Ágil', manaCost: 25, cooldown: 5, animationKey: 'attack_i' },
                                { key: 'O', name: 'Orbe Etéreo', manaCost: 35, cooldown: 4, damageModifier: 1.8, animationKey: 'attack_o' },
                                { key: 'P', name: 'Fúria de Umbra', manaCost: 50, cooldown: 8, animationKey: 'ultimate' }
                            ]
                        });
                        this._applySavedData(savedData); // Reaplica dados salvos
                    }
                }

                // Reseta a posição do jogador para o início da fase ou checkpoint
                if (checkpointName) {
                    const cp = Checkpoint.findByName(checkpoints, checkpointName); 
                    if (cp) {
                        gameState.player.position.x = cp.x;
                        gameState.player.position.y = cp.y;
                    }
                } else {
                    gameState.player.position.x = 100;
                    gameState.player.position.y = 300;
                }
                gameState.player.physics.velocity = { x: 0, y: 0 };
                gameState.player.health.heal(gameState.player.health.maxHealth); // Cura total
                gameState.player.mana.currentMana = gameState.player.mana.maxMana; // Mana total
                
                // Define a fase
                switch(phaseNumber) {
                    case 1:
                        this._setupPhase1_MuralhasAurora();
                        AudioManager.Instance.playMusic('music_platforming', true);
                        UIManager.Instance.hideBossBars();
                        break;
                    case 2:
                        this._setupPhase1_TarekEncounter();
                        break;
                    case 3:
                        this._setupPhase1_TarekBossFight();
                        AudioManager.Instance.playMusic('music_boss_tarek', true);
                        break;
                    default:
                        this._setupPhase1_MuralhasAurora();
                        AudioManager.Instance.playMusic('music_platforming', true);
                        UIManager.Instance.hideBossBars();
                }
                
                // Reinicia a câmera (a posição inicial já foi definida)
                gameState.cameraOffset = { x: gameState.player.position.x - gameWorldElement.offsetWidth / 2, y: gameState.player.position.y - gameWorldElement.offsetHeight / 2 };
                gameState.targetCameraOffset = { x: gameState.player.position.x - gameWorldElement.offsetWidth / 2, y: gameState.player.position.y - gameWorldElement.offsetHeight / 2 };
                
                EventManager.emit('game_state_change', `PHASE_${phaseNumber}_LOADED`);
            }

            _setupPhase1_MuralhasAurora() {
                platforms = [
                    new Platform(0, 400, 6000, 50, 'ground'),
                    new Platform(200, 350, 80, 20, 'platform'),
                    new Platform(350, 300, 80, 20, 'platform', true), // Escorregadia
                    new Platform(500, 250, 100, 20, 'platform'),
                    new Platform(700, 320, 120, 20, 'platform'),
                    new Platform(900, 380, 50, 20, 'platform'),
                    
                    new Platform(1100, 400, 150, 50, 'ground'),
                    new Platform(1100, 350, 150, 50, 'spike'),
                    new Platform(1300, 400, 100, 50, 'ground'),
                    new Platform(1500, 300, 80, 20, 'platform'),
                    new Platform(1700, 250, 100, 20, 'platform'),
                    new Platform(2000, 350, 120, 20, 'platform'),
                    new Platform(2300, 400, 200, 50, 'ground'),
                    new Platform(2300, 350, 200, 50, 'spike'),
                    new Platform(2600, 300, 80, 20, 'platform'),
                    new Platform(2800, 250, 100, 20, 'platform'),
                    new Platform(3100, 400, 150, 50, 'ground'),
                    new Platform(3400, 350, 80, 20, 'platform'),
                    new Platform(3600, 300, 100, 20, 'platform'),
                    new Platform(3900, 400, 200, 50, 'ground'),
                    new Platform(4200, 350, 80, 20, 'platform'),
                    new Platform(4400, 300, 100, 20, 'platform'),
                    new Platform(4700, 250, 120, 20, 'platform'),
                    new Platform(5000, 400, 1000, 50, 'ground'),
                ];

                fallingSpikes = [
                    new FallingSpike(800, -50, 30, 30, 150),
                    new FallingSpike(1200, -50, 30, 30, 150),
                    new FallingSpike(1800, -50, 30, 30, 150),
                    new FallingSpike(2400, -50, 30, 30, 150),
                    new FallingSpike(3000, -50, 30, 30, 150),
                    new FallingSpike(3800, -50, 30, 30, 150),
                    new FallingSpike(4500, -50, 30, 30, 150),
                ];

                enemies = [
                    new Enemy('sentinel', 600, 300, { health: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 10 }),
                    new Enemy('sentinel', 1600, 250, { health: 50, damage: 10, speed: 1, patrolRange: 120, xpValue: 10 }),
                    new Enemy('sentinel', 2700, 250, { health: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 10 }),
                    new Enemy('sentinel', 3700, 300, { health: 50, damage: 10, speed: 1, patrolRange: 150, xpValue: 10 }),
                    new Enemy('sentinel', 4600, 250, { health: 50, damage: 10, speed: 1, patrolRange: 100, xpValue: 10 })
                ];

                checkpoints = [
                    new Checkpoint(1000, 350, 50, 50, 'checkpoint1', 'Primeiro Checkpoint'),
                    new Checkpoint(2500, 350, 50, 50, 'checkpoint2', 'Segundo Checkpoint'),
                    new Checkpoint(4000, 350, 50, 50, 'checkpoint3', 'Terceiro Checkpoint'),
                ];
                
                CONFIG.WORLD_WIDTH = 6000;
                
                gameState.inTarekEncounter = false;
                gameState.tarekDialogStep = 0;
                gameState.fixedCamera = false;
            }

            _setupPhase1_TarekEncounter() {
                platforms = [ new Platform(0, 400, gameWorldElement.offsetWidth, 50, 'ground') ]; // Usar gameWorldElement.offsetWidth
                enemies = [];
                checkpoints = [];
                
                // Configura fundo para encontro (imagem estática)
                this._setBackgroundImage('tarek_background');

                gameState.fixedCamera = true;
                gameState.fixedCameraTarget = { x: 0, y: 0 };
                gameState.player.position.x = 150;
                gameState.player.position.y = 300;
                gameState.player.physics.velocity = { x: 0, y: 0 };

                // Inimigo de diálogo (não é um inimigo combatente)
                enemies.push(new Enemy('boss_dialogue', 600, 300, { health: 1, damage: 0, speed: 0 }));
                enemies[0].animation.play('idle'); // Usa a animação do boss
                
                UIManager.Instance.hideBossBars(); // CORREÇÃO: UIManager.Instance
                gameState.inTarekEncounter = true;

                this._startTarekDialogue();
            }

            _setupPhase1_TarekBossFight() {
                platforms = [ new Platform(0, 400, gameWorldElement.offsetWidth, 50, 'ground') ];
                enemies = [];
                checkpoints = [];
                
                this._setBackgroundImage('tarek_background');

                gameState.fixedCamera = true;
                gameState.fixedCameraTarget = { x: 0, y: 0 };
                gameState.player.position.x = 150;
                gameState.player.position.y = 300;
                
                gameState.player.health.heal(gameState.player.health.maxHealth);
                gameState.player.mana.currentMana = gameState.player.mana.maxMana;

                this.triggerBossFight();
            }

            _setBackgroundImage(assetKey) {
                // Define uma flag ou variável no GameManager para o renderizador de fundo usar
                GameManager.backgroundImageKey = assetKey;
                const imgAsset = CONFIG.ASSET_LOADED[assetKey];
                if (imgAsset && imgAsset.src) { // Garante que a imagem foi carregada
                     gameWorldElement.style.backgroundImage = `url('${imgAsset.src}')`;
                     gameWorldElement.style.backgroundSize = 'cover';
                     gameWorldElement.style.backgroundPosition = 'center';
                } else {
                    console.warn(`Background asset not loaded or invalid: ${assetKey}`);
                    gameWorldElement.style.backgroundImage = 'none'; // Fallback
                }
            }

            /**
             * Inicia a sequência de diálogo com Tarek.
             * @private
             */
            _startTarekDialogue() {
                gameState.tarekDialogStep = 0;
                const tarekDialogs = [
                    { speaker: "TAREK", text: `Então você é ${gameState.playerName}, o tal Escolhido?` },
                    { speaker: "TAREK", text: "Estas muralhas não são lugar para forasteiros fracos." },
                    { speaker: "TAREK", text: "Prove que merece passar por aqui, ou volte de onde veio!" }
                ];

                const showNextTarekLine = () => {
                    if (gameState.tarekDialogStep < tarekDialogs.length) {
                        const line = tarekDialogs[gameState.tarekDialogStep];
                        this.showDialog(line.speaker, line.text, [{ text: "Continuar", action: () => {
                            gameState.tarekDialogStep++;
                            showNextTarekLine();
                        }}]);
                    } else {
                        gameState.tarekDialogCompleted = true;
                        gameState.inTarekEncounter = false;
                        this.loadPhase(3); // Inicia a fase da batalha com Tarek
                    }
                };
                showNextTarekLine();
            }

            /**
             * Inicia a luta contra o boss.
             */
            triggerBossFight() {
                gameState.inBossFight = true;
                gameState.fixedCamera = true;
                
                AudioManager.Instance.playSFX('sfx_boss_roar'); // CORREÇÃO: AudioManager.Instance

                const tarek = new BossTarek(gameWorldElement.offsetWidth - 150, 300, { // Use gameWorldElement.offsetWidth
                    health: 500, damage: 25, speed: 1.5, xpValue: 250
                });
                enemies.push(tarek);
                
                UIManager.Instance.showBossBars(tarek.name, tarek.health.currentHealth, tarek.health.maxHealth); // CORREÇÃO: UIManager.Instance
                
                this.saveCheckpoint('tarek_fight_start');
                
                EventManager.emit('screen_shake', { intensity: 8, duration: 500 });
                EventManager.emit('screen_flash', { color: COLOR_ACCENT_FIRE, duration: 300 });
                EventManager.emit('add_particles', { type: 'bossIntro', x: tarek.position.x + 35, y: tarek.position.y + 35, count: 40 });

                EventManager.emit('game_state_change', 'BOSS_FIGHT_STARTED');
            }

            /**
             * Lógica quando o boss é derrotado.
             * @param {Enemy} boss - O objeto boss.
             */
            defeatBoss(boss) {
                gameState.bossDefeated = true;
                gameState.inBossFight = false;
                
                AudioManager.Instance.stopMusic(); // CORREÇÃO: AudioManager.Instance
                UIManager.Instance.hideBossBars(); // CORREÇÃO: UIManager.Instance
                
                EventManager.emit('screen_flash', { color: COLOR_ACCENT_GOLD, duration: 800 });
                EventManager.emit('screen_shake', { intensity: 10, duration: 1000 });
                EventManager.emit('add_particles', { type: 'victoryExplosion', x: boss.position.x + 35, y: boss.position.y + 35, count: 60 });
                
                gameState.player.gainXP(boss.xpValue); // Garante que o jogador receba XP do boss

                // Remove o boss da lista de inimigos (se ainda estiver lá)
                enemies = enemies.filter(e => e !== boss);
                boss.destroy(); // Remove o elemento DOM do boss

                setTimeout(() => {
                    this.showDialog(
                        "TAREK",
                        `Impressionante, ${gameState.playerName}... Você realmente tem a força de um Escolhido. Pode passar, mas saiba que desafios ainda maiores o aguardam adiante.`,
                        [
                            {
                                text: "Obrigado pela luta honrosa, Tarek.",
                                action: () => {
                                    this.showDialog(
                                        "TAREK",
                                        "Que os ventos gelados guiem seus passos, Escolhido. E que você encontre o que procura antes que seja tarde demais.",
                                        [
                                            {
                                                text: "Fim da Primeira Jornada",
                                                action: () => {
                                                    this.saveCheckpoint('boss_defeated');
                                                    this.showDialog(
                                                        "NARRAÇÃO",
                                                        "Com Tarek derrotado, o caminho para o interior de Tupãry está aberto. Mas esta é apenas a primeira de muitas provações que aguardam o Escolhido...",
                                                        [
                                                            {
                                                                text: "Fim da Demo (Avance para a Missão 2 em breve)",
                                                                action: () => UIManager.Instance.showVictoryScreen(gameState.playerName, gameState.player.level, gameState.player.xp) // CORREÇÃO: UIManager.Instance
                                                            }
                                                        ]
                                                    );
                                                }
                                            }
                                        ]
                                    );
                                }
                            }
                        ]
                    );
                }, 2000);

                EventManager.emit('game_state_change', 'BOSS_DEFEATED');
            }

            /**
             * Pausa ou despausa o jogo.
             * @param {boolean} forceState - Opcional, força o estado (true para pausar, false para despausar).
             */
            togglePause(forceState = null) {
                if (gameState.inMenu || gameState.inCutscene || gameState.inDialog) return;
                
                gameState.gamePaused = forceState !== null ? forceState : !gameState.gamePaused;
                
                if (gameState.gamePaused) {
                    UIManager.Instance.showPauseMenu(); // CORREÇÃO: UIManager.Instance
                    AudioManager.Instance.stopMusic(); // CORREÇÃO: AudioManager.Instance
                } else {
                    UIManager.Instance.hidePauseMenu(); // CORREÇÃO: UIManager.Instance
                    if (gameState.inBossFight) {
                        AudioManager.Instance.playMusic('music_boss_tarek', true); // CORREÇÃO: AudioManager.Instance
                    } else {
                        AudioManager.Instance.playMusic('music_platforming', true); // CORREÇÃO: AudioManager.Instance
                    }
                }
                EventManager.emit('game_state_change', gameState.gamePaused ? 'PAUSED' : 'RESUMED');
            }

            /**
             * Lógica de Game Over.
             */
            gameOver() {
                this.togglePause(true); // Garante que o jogo esteja pausado
                AudioManager.Instance.stopMusic(); // CORREÇÃO: AudioManager.Instance
                
                EventManager.emit('screen_flash', { color: 'rgba(0, 0, 0, 0.8)', duration: 1000 });
                
                setTimeout(() => {
                    UIManager.Instance.hideAllOverlays(); // CORREÇÃO: UIManager.Instance
                    this.showDialog(
                        "SISTEMA",
                        `${gameState.playerName} foi derrotado... Mas a jornada não termina aqui. O destino de todos os reinos ainda depende de suas escolhas.`,
                        [
                            {
                                text: "Voltar ao último checkpoint",
                                action: () => {
                                    this.restartFromCheckpoint();
                                }
                            },
                            {
                                text: "Reiniciar fase atual",
                                action: () => {
                                    this.loadPhase(gameState.currentPhase);
                                    this.togglePause(false);
                                }
                            },
                            {
                                text: "Voltar ao menu principal",
                                action: () => {
                                    this.exitToMenu();
                                }
                            }
                        ]
                    );
                }, 1500);
                EventManager.emit('game_state_change', 'GAME_OVER');
            }

            /**
             * Exibe uma tela de vitória.
             */
            showVictoryScreen(playerName, level, xp) {
                UIManager.Instance.showVictoryScreen(playerName, level, xp); // CORREÇÃO: UIManager.Instance
                EventManager.emit('game_state_change', 'VICTORY');
            }

            /**
             * Exibe uma caixa de diálogo.
             * @param {string} speaker - Quem está falando.
             * @param {string} text - O texto do diálogo.
             * @param {Array<object>} options - Opções de resposta (cada uma com text e action).
             */
            showDialog(speaker, text, options = null) {
                gameState.inDialog = true;
                this.togglePause(true); // Pausa o jogo quando o diálogo está ativo
                UIManager.Instance.showDialog(speaker, text, options); // CORREÇÃO: UIManager.Instance
                EventManager.emit('game_state_change', 'IN_DIALOG');
            }

            /**
             * Esconde a caixa de diálogo.
             */
            hideDialog() {
                gameState.inDialog = false;
                this.togglePause(false); // Despausa o jogo ao sair do diálogo
                UIManager.Instance.hideDialog(); // CORREÇÃO: UIManager.Instance
                EventManager.emit('game_state_change', 'OUT_OF_DIALOG');
            }

            /**
             * Exibe a cutscene inicial.
             */
            showIntroCutscene() {
                gameState.inCutscene = true;
                UIManager.Instance.showCutscene(); // CORREÇÃO: UIManager.Instance
                AudioManager.Instance.playMusic('music_menu', true); // CORREÇÃO: AudioManager.Instance

                const introSequence = [
                    {
                        title: "O DESEQUILÍBRIO",
                        text: "O mundo treme sob o peso do desequilíbrio. Ignys, o Reino do Fogo, deseja guerra e já move suas tropas em direção aos reinos vizinhos.",
                        gif: null
                    },
                    {
                        title: "O CORAÇÃO DE GELO",
                        text: "Em Tupãry, o Coração de Gelo guarda a metade maligna de Anhangá, o espírito que traz caos.",
                        gif: CONFIG.ASSET_LOADED.cutscene_gif_1 // Este GIF é para a tag <img>, então funciona.
                    },
                    {
                        title: "A CONVOCAÇÃO",
                        text: `Umbra convoca você, ${gameState.playerName}, o Escolhido: recuperar o Coração de Gelo e impedir que Ignys obtenha poder suficiente para dominar todos os reinos.`,
                        gif: null
                    },
                    {
                        title: "O DESTINO",
                        text: "Cada passo, cada luta, cada escolha será decisiva para a sobrevivência de todos.",
                        gif: null
                    }
                ];
                UIManager.Instance.playCutsceneSequence(introSequence, () => { // CORREÇÃO: UIManager.Instance
                    this.endIntroCutscene();
                });
                EventManager.emit('game_state_change', 'IN_CUTSCENE');
            }

            /**
             * Finaliza a cutscene inicial.
             */
            endIntroCutscene() {
                gameState.inCutscene = false;
                UIManager.Instance.hideCutscene(); // CORREÇÃO: UIManager.Instance
                this.loadPhase(1); // Inicia a primeira fase do jogo
                EventManager.emit('game_state_change', 'OUT_OF_CUTSCENE');
            }

            /**
             * Salva o progresso do jogo em cookies.
             */
            saveProgress() {
                const saveData = {
                    playerName: gameState.playerName,
                    playerLevel: gameState.player.level,
                    playerXP: gameState.player.xp,
                    playerNextLevelXP: gameState.player.nextLevelXP,
                    playerMaxHealth: gameState.player.health.maxHealth,
                    playerMaxMana: gameState.player.mana.maxMana,
                    playerDamage: gameState.player.damage,
                    playerSpeed: gameState.player.baseSpeed,
                    currentPhase: gameState.currentPhase,
                    currentCheckpoint: gameState.currentCheckpoint,
                    bossDefeated: gameState.bossDefeated,
                    tarekDialogCompleted: gameState.tarekDialogCompleted,
                    abilitiesMaxCooldown: {} // Salva cooldowns máximos para cada habilidade
                };

                for (const key in gameState.player.abilities) {
                    saveData.abilitiesMaxCooldown[key] = gameState.player.abilities[key].cooldown;
                }
                
                this._setCookie('tupary_save', JSON.stringify(saveData));
                UIManager.Instance.showCheckpointNotification('Progresso Salvo', 'Seu progresso foi salvo com sucesso!'); // CORREÇÃO: UIManager.Instance
                EventManager.emit('game_saved');
            }

            /**
             * Carrega o progresso do jogo de cookies.
             * @returns {object|null} Dados do jogo salvos.
             * @private
             */
            _loadProgress() {
                const saveData = this._getCookie('tupary_save');
                if (saveData) {
                    try {
                        return JSON.parse(saveData);
                    } catch (e) {
                        console.error('Erro ao carregar save:', e);
                    }
                }
                return null;
            }

            /**
             * Aplica os dados salvos ao estado do jogo.
             * @param {object} data - Dados a serem aplicados.
             * @private
             */
            _applySavedData(data) {
                gameState.playerName = data.playerName;
                gameState.player.level = data.playerLevel;
                gameState.player.xp = data.playerXP;
                gameState.player.nextLevelXP = data.playerNextLevelXP;
                gameState.player.health.maxHealth = data.playerMaxHealth;
                gameState.player.health.currentHealth = data.playerMaxHealth; // Garante vida cheia ao carregar
                gameState.player.mana.maxMana = data.playerMaxMana;
                gameState.player.mana.currentMana = data.playerMaxMana; // Garante mana cheia
                gameState.player.damage = data.playerDamage;
                gameState.player.baseSpeed = data.playerSpeed;
                gameState.player.currentSpeed = data.playerSpeed;
                gameState.currentPhase = data.currentPhase;
                gameState.currentCheckpoint = data.currentCheckpoint;
                gameState.bossDefeated = data.bossDefeated;
                gameState.tarekDialogCompleted = data.tarekDialogCompleted;

                for (const key in data.abilitiesMaxCooldown) {
                    if (gameState.player.abilities[key]) {
                        gameState.player.abilities[key].cooldown = data.abilitiesMaxCooldown[key];
                    }
                }

                // Força atualização da UI com os valores carregados
                UIManager.Instance.updatePlayerStats(gameState.player.level, gameState.player.damage); // CORREÇÃO: UIManager.Instance
                UIManager.Instance.updateHealth({ current: gameState.player.health.currentHealth, max: gameState.player.health.maxHealth }); // CORREÇÃO: UIManager.Instance
                UIManager.Instance.updateMana({ current: gameState.player.mana.currentMana, max: gameState.player.mana.maxMana }); // CORREÇÃO: UIManager.Instance
                UIManager.Instance.updateXP({ current: gameState.player.xp, max: gameState.player.nextLevelXP }); // CORREÇÃO: UIManager.Instance
            }

            /**
             * Salva um checkpoint no jogo.
             * @param {string} checkpointName - Nome do checkpoint.
             * @param {string} description - Descrição para a notificação.
             */
            saveCheckpoint(checkpointName, description) {
                gameState.currentCheckpoint = checkpointName;
                const checkpointData = {
                    name: checkpointName,
                    phase: gameState.currentPhase,
                    playerPosition: { x: gameState.player.position.x, y: gameState.player.position.y },
                    playerHealth: gameState.player.health.currentHealth,
                    playerMana: gameState.player.mana.currentMana,
                    playerXP: gameState.player.xp,
                    playerLevel: gameState.player.level,
                    playerNextLevelXP: gameState.player.nextLevelXP,
                    playerMaxHealth: gameState.player.health.maxHealth,
                    playerMaxMana: gameState.player.mana.maxMana,
                    playerDamage: gameState.player.damage,
                    playerSpeed: gameState.player.baseSpeed,
                    tarekDialogCompleted: gameState.tarekDialogCompleted,
                    abilitiesMaxCooldown: {}
                };
                for (const key in gameState.player.abilities) {
                    checkpointData.abilitiesMaxCooldown[key] = gameState.player.abilities[key].cooldown;
                }
                
                this._setCookie('tupary_checkpoint', JSON.stringify(checkpointData));
                UIManager.Instance.showCheckpointNotification('Checkpoint Salvo', `Progresso salvo em: ${description}`); // CORREÇÃO: UIManager.Instance
                EventManager.emit('checkpoint_saved', checkpointName);
            }

            /**
             * Carrega o último checkpoint salvo.
             */
            restartFromCheckpoint() {
                this.togglePause(false); // Despausa o jogo
                const checkpointData = this._getCookie('tupary_checkpoint');
                if (checkpointData) {
                    try {
                        const data = JSON.parse(checkpointData);
                        
                        // Restaura o estado do jogo e do jogador
                        gameState.currentPhase = data.phase;
                        gameState.currentCheckpoint = data.name;
                        
                        // Se o jogador já existe, atualiza as propriedades, senão, recria.
                        if (gameState.player) {
                            gameState.player.position = { x: data.playerPosition.x, y: data.playerPosition.y };
                            gameState.player.health.currentHealth = data.playerHealth;
                            gameState.player.health.maxHealth = data.playerMaxHealth; 
                            gameState.player.mana.currentMana = data.playerMana;
                            gameState.player.mana.maxMana = data.playerMaxMana; 
                            gameState.player.xp = data.playerXP;
                            gameState.player.level = data.playerLevel;
                            gameState.player.nextLevelXP = data.playerNextLevelXP;
                            gameState.player.damage = data.playerDamage;
                            gameState.player.baseSpeed = data.playerSpeed;
                            gameState.player.currentSpeed = data.playerSpeed;
                            gameState.tarekDialogCompleted = data.tarekDialogCompleted;

                            for (const key in data.abilitiesMaxCooldown) {
                                if (gameState.player.abilities[key]) {
                                    gameState.player.abilities[key].cooldown = data.abilitiesMaxCooldown[key];
                                }
                            }
                        } else {
                            // Este caso só deve ocorrer se o jogador foi limpo por algum motivo (ex: exitToMenu)
                            // e estamos tentando reiniciar um checkpoint. Isso recriaria o jogador.
                            console.warn("Player was null, recreating player from checkpoint data.");
                             gameState.player = new Player(data.playerName, {
                                baseHealth: data.playerMaxHealth, baseMana: data.playerMaxMana, baseSpeed: data.playerSpeed,
                                baseDamage: data.playerDamage, manaRegenRate: CONFIG.MANA_REGEN_RATE, // Using default regen rate
                                abilities: [ // Default abilities, would need to store/load specific ability data if they changed
                                    { key: 'U', name: 'Tiro Sombrio', manaCost: 0, cooldown: 0.6, damageModifier: 1.2, animationKey: 'attack_u' },
                                    { key: 'I', name: 'Sombra Ágil', manaCost: 25, cooldown: 5, animationKey: 'attack_i' },
                                    { key: 'O', name: 'Orbe Etéreo', manaCost: 35, cooldown: 4, damageModifier: 1.8, animationKey: 'attack_o' },
                                    { key: 'P', name: 'Fúria de Umbra', manaCost: 50, cooldown: 8, animationKey: 'ultimate' }
                                ]
                            });
                             this._applySavedData(data); // Aplica o resto dos dados
                        }
                        
                        this.loadPhase(data.phase, data.name); // Recarrega a fase e posiciona no checkpoint
                        UIManager.Instance.showCheckpointNotification('Checkpoint Carregado', 'Retornando ao último checkpoint salvo...'); // CORREÇÃO: UIManager.Instance
                        EventManager.emit('checkpoint_loaded', data.name);
                    } catch (e) {
                        console.error('Erro ao carregar checkpoint:', e);
                        // Se houver erro, apenas reinicia a fase atual
                        this.loadPhase(gameState.currentPhase);
                        UIManager.Instance.showCheckpointNotification('Erro!', 'Não foi possível carregar o checkpoint. Reiniciando a fase atual.'); // CORREÇÃO: UIManager.Instance
                    }
                } else {
                    // Se não houver checkpoint, apenas reinicia a fase atual
                    this.loadPhase(gameState.currentPhase);
                    UIManager.Instance.showCheckpointNotification('Nenhum Checkpoint', 'Nenhum checkpoint encontrado. Reiniciando a fase atual.'); // CORREÇÃO: UIManager.Instance
                }
            }

            /**
             * Volta para o menu principal, limpando o estado do jogo.
             */
            exitToMenu() {
                this.saveProgress(); // Salva antes de sair
                
                // Reinicia o estado global do jogo para o menu principal
                gameState = {
                    playerName: '',
                    player: null,
                    currentPhase: 0,
                    currentCheckpoint: 'start',
                    gamePaused: false, inDialog: false, inCutscene: false,
                    inMenu: true, gameStarted: false,
                    cameraOffset: { x: 0, y: 0 }, targetCameraOffset: { x: 0, y: 0 },
                    inBossFight: false, bossDefeated: false,
                    inTarekEncounter: false, tarekDialogStep: 0, tarekDialogCompleted: false,
                    tarekEncounterTriggerX: 5500,
                    fixedCamera: false, fixedCameraTarget: { x: 0, y: 0 }
                };

                // Limpa todos os elementos DOM das entidades
                if (gameWorldElement) {
                    while (gameWorldElement.firstChild) {
                        gameWorldElement.removeChild(gameWorldElement.firstChild);
                    }
                }

                // Limpa todas as entidades
                platforms = []; enemies = []; 
                fallingSpikes = []; checkpoints = [];
                ObjectPooler.Instance.returnAllActiveToPools(); // Garante que pools estejam limpas
                
                UIManager.Instance.hideAllOverlays(); // CORREÇÃO: UIManager.Instance
                UIManager.Instance.showMainMenu(); // CORREÇÃO: UIManager.Instance
                UIManager.Instance.resetMainMenuInputs(); // CORREÇÃO: UIManager.Instance

                AudioManager.Instance.stopMusic(); // CORREÇÃO: AudioManager.Instance
                AudioManager.Instance.playMusic('music_menu', true); // CORREÇÃO: AudioManager.Instance

                // Limpa o canvas (se ainda estiver em uso para algo)
                if (canvas && ctx) { // Check if ctx exists before trying to clear
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }

                EventManager.emit('game_state_change', 'EXIT_TO_MENU');
            }

            /**
             * Define um cookie.
             * @param {string} name - Nome do cookie.
             * @param {string} value - Valor do cookie.
             * @param {number} days - Dias de expiração.
             * @private
             */
            _setCookie(name, value, days = 30) {
                const expires = new Date();
                expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
                document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
            }

            /**
             * Obtém o valor de um cookie.
             * @param {string} name - Nome do cookie.
             * @returns {string|null} - Valor do cookie ou null.
             * @private
             */
            _getCookie(name) {
                const nameEQ = name + "=";
                const ca = document.cookie.split(';');
                for (let i = 0; i < ca.length; i++) {
                    let c = ca[i];
                    while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                    if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
                }
                return null;
            }

            /**
             * Carrega as configurações do jogo de cookies.
             * @private
             */
            _loadSettings() {
                const saved = this._getCookie('tupary_settings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        Object.assign(this.gameSettings, settings);
                    } catch (e) {
                        console.error('Erro ao carregar configurações:', e);
                    }
                }
            }

            /**
             * Salva as configurações do jogo em cookies.
             * @private
             */
            _saveSettings() {
                this._setCookie('tupary_settings', JSON.stringify(this.gameSettings));
            }
        }

        /**
         * @class UIManager
         * @description Gerencia todas as interações e atualizações da interface do usuário (UI).
         */
        class UIManager {
            constructor() {
                if (UIManager.Instance) {
                    return UIManager.Instance;
                }
                UIManager.Instance = this;

                // Referências aos elementos HTML da UI
                this.elements = {
                    mainMenu: document.getElementById('main-menu'),
                    playerNameInput: document.getElementById('player-name'),
                    startGameBtn: document.getElementById('start-game-btn'),
                    
                    healthFill: document.getElementById('health-fill'),
                    healthText: document.getElementById('health-text'),
                    manaFill: document.getElementById('mana-fill'),
                    manaText: document.getElementById('mana-text'),
                    xpFill: document.getElementById('xp-fill'),
                    xpText: document.getElementById('xp-text'),
                    playerLevel: document.getElementById('player-level'),
                    playerClass: document.getElementById('player-class'),
                    playerDamage: document.getElementById('player-damage'),

                    bossName: document.getElementById('boss-name'),
                    bossHealthBar: document.getElementById('boss-health-bar'),
                    bossHealthFill: document.getElementById('boss-health-fill'),

                    abilityBtns: document.querySelectorAll('.ability-btn'),
                    pauseBtn: document.getElementById('pause-btn'),
                    pauseMenu: document.getElementById('pause-menu'),
                    resumeBtn: document.getElementById('resume-btn'),
                    restartBtn: document.getElementById('restart-btn'),
                    saveBtn: document.getElementById('save-btn'),
                    exitBtn: document.getElementById('exit-btn'),

                    mobileControls: document.getElementById('mobile-controls'),
                    
                    dialogContainer: document.getElementById('dialog-container'),
                    dialogSpeaker: document.getElementById('dialog-speaker'),
                    dialogText: document.getElementById('dialog-text'),
                    dialogOptions: document.getElementById('dialog-options'),

                    cinematicOverlay: document.getElementById('cinematic-overlay'),
                    cinematicTitle: document.getElementById('cinematic-title'),
                    cinematicGif: document.getElementById('cutscene-gif'),
                    cinematicText: document.getElementById('cinematic-text'),
                    skipBtn: document.getElementById('skip-btn'),

                    levelUpMenu: document.getElementById('level-up'),
                    upgradeOptions: document.querySelectorAll('.upgrade-option'),

                    checkpointNotification: document.getElementById('checkpoint-notification'),
                    checkpointText: document.getElementById('checkpoint-text'),
                    checkpointDescription: document.getElementById('checkpoint-description'),

                    screenFlash: document.getElementById('screen-flash'),
                    particleContainer: document.getElementById('particle-container'),
                    orientationWarning: document.getElementById('orientation-warning')
                };

                // Debugging element acquisition for critical elements
                if (!this.elements.playerNameInput) console.error("UIManager Error: 'player-name' input element not found!");
                if (!this.elements.startGameBtn) console.error("UIManager Error: 'start-game-btn' button element not found!");
                
                this._initEventListeners();
            }

            _initEventListeners() {
                // Menu Principal
                // CORREÇÃO: Garante que o evento 'input' é ouvido para validar o botão
                this.elements.playerNameInput.addEventListener('input', this.validateMainMenuInputs.bind(this));
                this.elements.startGameBtn.addEventListener('click', () => {
                    GameManager.Instance.startGame(this.elements.playerNameInput.value.trim());
                });

                // Botões de Pausa
                this.elements.pauseBtn.addEventListener('click', () => GameManager.Instance.togglePause());
                this.elements.resumeBtn.addEventListener('click', () => GameManager.Instance.togglePause());
                this.elements.restartBtn.addEventListener('click', () => GameManager.Instance.restartFromCheckpoint());
                this.elements.saveBtn.addEventListener('click', () => GameManager.Instance.saveProgress());
                this.elements.exitBtn.addEventListener('click', () => GameManager.Instance.exitToMenu());

                // Botões de Habilidade
                this.elements.abilityBtns.forEach(btn => {
                    const key = btn.dataset.key;
                    btn.addEventListener('click', () => {
                        if (gameState.player) {
                            gameState.player.abilities[key].activate(); // Ativa a habilidade
                        }
                    });
                });

                // Botão de pular cutscene
                this.elements.skipBtn.addEventListener('click', () => {
                    // No contexto da cutscene inicial, 'skip' significa 'avançar para o próximo passo'
                    // ou 'pular toda a cutscene' se for o último passo.
                    this._advanceCutsceneSequence();
                });

                // Opções de Level Up
                this.elements.upgradeOptions.forEach(option => {
                    option.addEventListener('click', (e) => {
                        const upgradeType = e.currentTarget.dataset.upgrade;
                        this._applyUpgrade(upgradeType);
                    });
                });
            }

            /**
             * Valida os inputs do menu principal (nome do jogador).
             */
            validateMainMenuInputs() {
                const name = this.elements.playerNameInput.value.trim();
                console.log(`DEBUG: Nome no input: '${name}', Comprimento: ${name.length}`); // Log de depuração
                this.elements.startGameBtn.disabled = name.length < 2;
                console.log(`DEBUG: Botão 'Iniciar Jornada' desabilitado: ${this.elements.startGameBtn.disabled}`); // Log de depuração
            }

            /**
             * Reseta os inputs do menu principal.
             */
            resetMainMenuInputs() {
                if (this.elements.playerNameInput) this.elements.playerNameInput.value = '';
                if (this.elements.startGameBtn) this.elements.startGameBtn.disabled = true;
            }

            /**
             * Mostra o menu principal.
             */
            showMainMenu() {
                if (this.elements.mainMenu) {
                    this.elements.mainMenu.style.display = 'flex';
                    this.elements.mainMenu.style.pointerEvents = 'auto';
                }
            }

            /**
             * Esconde o menu principal.
             */
            hideMainMenu() {
                if (this.elements.mainMenu) {
                    this.elements.mainMenu.style.display = 'none';
                    this.elements.mainMenu.style.pointerEvents = 'none';
                }
            }

            /**
             * Mostra/esconde um overlay de UI.
             * @param {HTMLElement} element - O elemento HTML do overlay.
             * @param {boolean} show - True para mostrar, false para esconder.
             * @param {string} displayType - Tipo de display (flex, block, etc.).
             */
            _toggleOverlay(element, show, displayType = 'flex') {
                if (element) {
                    element.style.display = show ? displayType : 'none';
                    element.style.pointerEvents = show ? 'auto' : 'none';
                }
            }

            /**
             * Esconde todos os overlays de UI.
             */
            hideAllOverlays() {
                this._toggleOverlay(this.elements.pauseMenu, false);
                this._toggleOverlay(this.elements.levelUpMenu, false);
                this._toggleOverlay(this.elements.dialogContainer, false);
                this._toggleOverlay(this.elements.cinematicOverlay, false);
                // Outros overlays que podem estar ativos
            }

            /**
             * Atualiza a barra de saúde.
             * @param {object} data - { current, max }.
             */
            updateHealth(data) {
                if (!this.elements.healthFill || !this.elements.healthText) return;
                const percentage = (data.current / data.max) * 100;
                this.elements.healthFill.style.width = percentage + '%';
                this.elements.healthText.textContent = `${Math.round(data.current)}/${Math.round(data.max)}`;
            }

            /**
             * Atualiza a barra de mana.
             * @param {object} data - { current, max }.
             */
            updateMana(data) {
                if (!this.elements.manaFill || !this.elements.manaText) return;
                const percentage = (data.current / data.max) * 100;
                this.elements.manaFill.style.width = percentage + '%';
                this.elements.manaText.textContent = `${Math.round(data.current)}/${Math.round(data.max)}`;
            }

            /**
             * Atualiza a barra de XP.
             * @param {object} data - { current, max }.
             */
            updateXP(data) {
                if (!this.elements.xpFill || !this.elements.xpText) return;
                const percentage = (data.current / data.max) * 100;
                this.elements.xpFill.style.width = percentage + '%';
                this.elements.xpText.textContent = `${Math.round(data.current)}/${Math.round(data.max)}`;
            }

            /**
             * Atualiza as estatísticas do jogador na UI.
             * @param {number} level - Nível do jogador.
             * @param {number} damage - Dano do jogador.
             */
            updatePlayerStats(level, damage) {
                if (this.elements.playerLevel) this.elements.playerLevel.textContent = level;
                if (this.elements.playerDamage) this.elements.playerDamage.textContent = Math.round(damage);
            }

            /**
             * Atualiza a barra de vida do boss.
             * @param {string} name - Nome do boss.
             * @param {number} current - Vida atual.
             * @param {number} max - Vida máxima.
             */
            updateBossHealth(name, current, max) {
                if (!this.elements.bossName || !this.elements.bossHealthFill) return;
                this.elements.bossName.textContent = name;
                const percentage = (current / max) * 100;
                this.elements.bossHealthFill.style.width = percentage + '%';

                if (percentage > 60) {
                    this.elements.bossHealthFill.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
                } else if (percentage > 30) {
                    this.elements.bossHealthFill.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
                } else {
                    this.elements.bossHealthFill.style.background = 'linear-gradient(90deg, #f44336, #e53935)';
                }
            }

            /**
             * Mostra as barras de vida do boss.
             * @param {string} name - Nome do boss.
             * @param {number} current - Vida atual.
             * @param {number} max - Vida máxima.
             */
            showBossBars(name, current, max) {
                if (this.elements.bossName) this.elements.bossName.style.display = 'block';
                if (this.elements.bossHealthBar) this.elements.bossHealthBar.style.display = 'block';
                this.updateBossHealth(name, current, max);
            }

            /**
             * Esconde as barras de vida do boss.
             */
            hideBossBars() {
                if (this.elements.bossName) this.elements.bossName.style.display = 'none';
                if (this.elements.bossHealthBar) this.elements.bossHealthBar.style.display = 'none';
            }

            /**
             * Atualiza o visual do cooldown de uma habilidade.
             * @param {object} data - { key, current, max }.
             */
            updateAbilityCooldown(data) {
                const btn = document.getElementById(`ability-${data.key.toLowerCase()}`);
                const overlay = btn?.querySelector('.cooldown-overlay');
                
                if (btn && overlay) {
                    const cooldownRatio = data.current / data.max;
                    if (cooldownRatio > 0) {
                        btn.classList.add('cooldown');
                        const angle = 360 * (1 - cooldownRatio);
                        overlay.style.background = `conic-gradient(from 0deg, transparent ${angle}deg, rgba(0, 0, 0, 0.8) ${angle}deg)`;
                    } else {
                        btn.classList.remove('cooldown');
                        overlay.style.background = '';
                    }
                }
            }

            /**
             * Exibe o menu de pausa.
             */
            showPauseMenu() {
                this._toggleOverlay(this.elements.pauseMenu, true);
            }

            /**
             * Esconde o menu de pausa.
             */
            hidePauseMenu() {
                this._toggleOverlay(this.elements.pauseMenu, false);
            }

            /**
             * Exibe a caixa de diálogo.
             * @param {string} speaker - Quem está falando.
             * @param {string} text - O texto do diálogo.
             * @param {Array<object>} options - Opções de resposta (cada uma com text e action).
             */
            showDialog(speaker, text, options = null) {
                this._toggleOverlay(this.elements.dialogContainer, true);
                if (this.elements.dialogSpeaker) this.elements.dialogSpeaker.textContent = speaker;
                if (this.elements.dialogText) this.elements.dialogText.textContent = text;
                if (this.elements.dialogOptions) this.elements.dialogOptions.innerHTML = ''; // Limpa opções anteriores

                if (options && options.length > 0) {
                    options.forEach((option) => {
                        const button = document.createElement('div');
                        button.className = 'dialog-option';
                        button.textContent = option.text;
                        button.addEventListener('click', () => {
                            GameManager.Instance.hideDialog(); // Esconde o diálogo
                            if (option.action) option.action(); // Executa a ação da opção
                        });
                        this.elements.dialogOptions.appendChild(button);
                    });
                } else {
                    // Opção padrão "Continuar"
                    const button = document.createElement('div');
                    button.className = 'dialog-option';
                    button.textContent = 'Continuar';
                    button.addEventListener('click', () => GameManager.Instance.hideDialog());
                    this.elements.dialogOptions.appendChild(button);
                }
            }

            /**
             * Esconde a caixa de diálogo.
             */
            hideDialog() {
                this._toggleOverlay(this.elements.dialogContainer, false);
            }

            /**
             * Controla a sequência de cutscene.
             */
            _currentCutsceneSequence = null;
            _currentSequenceIndex = 0;
            _cutsceneFinishCallback = null;

            playCutsceneSequence(sequence, onFinishCallback) {
                this._currentCutsceneSequence = sequence;
                this._currentSequenceIndex = 0;
                this._cutsceneFinishCallback = onFinishCallback;
                this._advanceCutsceneSequence();
            }

            _advanceCutsceneSequence() {
                if (this._currentSequenceIndex < this._currentCutsceneSequence.length) {
                    const sequenceItem = this._currentCutsceneSequence[this._currentSequenceIndex];
                    
                    if (this.elements.cinematicTitle) this.elements.cinematicTitle.textContent = sequenceItem.title;
                    if (this.elements.cinematicText) this.elements.cinematicText.textContent = sequenceItem.text;
                    
                    // Reinicia animações CSS para garantir o efeito fadeIn
                    if (this.elements.cinematicTitle) this.elements.cinematicTitle.style.animation = 'none';
                    if (this.elements.cinematicText) this.elements.cinematicText.style.animation = 'none';
                    void this.elements.cinematicTitle.offsetWidth; // Força reflow
                    void this.elements.cinematicText.offsetWidth;
                    if (this.elements.cinematicTitle) this.elements.cinematicTitle.style.animation = 'fadeInText 2s forwards';
                    if (this.elements.cinematicText) this.elements.cinematicText.style.animation = 'fadeInText 3s forwards 0.5s';

                    // Gerencia a exibição do GIF (elemento <img> HTML pode exibir GIFs animados)
                    if (this.elements.cinematicGif) {
                        if (sequenceItem.gif) {
                            this.elements.cinematicGif.src = sequenceItem.gif.src;
                            this.elements.cinematicGif.style.display = 'block';
                        } else {
                            this.elements.cinematicGif.style.display = 'none';
                            this.elements.cinematicGif.src = ''; // Limpa a URL
                        }
                    }
                    
                    this._currentSequenceIndex++;
                } else {
                    if (this._cutsceneFinishCallback) {
                        this._cutsceneFinishCallback(); // Chama o callback de término
                    }
                    this._currentCutsceneSequence = null;
                    this._currentSequenceIndex = 0;
                    this._cutsceneFinishCallback = null;
                }
            }

            /**
             * Mostra o overlay de cutscene.
             */
            showCutscene() {
                this._toggleOverlay(this.elements.cinematicOverlay, true);
                if (this.elements.skipBtn) this.elements.skipBtn.textContent = 'Próximo';
            }

            /**
             * Esconde o overlay de cutscene.
             */
            hideCutscene() {
                this._toggleOverlay(this.elements.cinematicOverlay, false);
                if (this.elements.cinematicGif) {
                    this.elements.cinematicGif.style.display = 'none'; // Garante que o GIF seja escondido
                    this.elements.cinematicGif.src = '';
                }
            }

            /**
             * Mostra o menu de level up.
             */
            showLevelUpMenu() {
                this._toggleOverlay(this.elements.levelUpMenu, true);
                if (this.elements.levelUpMenu) this.elements.levelUpMenu.style.animation = 'levelUpAnimation 0.8s forwards'; // Adiciona animação de entrada
            }

            /**
             * Aplica o upgrade escolhido no menu de level up.
             * @param {string} upgradeType - Tipo de upgrade.
             */
            _applyUpgrade(upgradeType) {
                if (!gameState.player) return;

                switch(upgradeType) {
                    case 'health':
                        gameState.player.health.maxHealth += 25;
                        gameState.player.health.heal(gameState.player.health.maxHealth); // Cura total
                        break;
                    case 'mana':
                        gameState.player.mana.maxMana += 35;
                        gameState.player.mana.currentMana = gameState.player.mana.maxMana; // Mana total
                        gameState.player.mana.regenRate *= 1.5; // Acelera regeneração
                        break;
                    case 'damage':
                        gameState.player.damage += 8;
                        break;
                    case 'speed':
                        gameState.player.baseSpeed += 0.8;
                        gameState.player.currentSpeed = gameState.player.baseSpeed; // Update current speed after base speed increase
                        // Reduz cooldowns das habilidades
                        for (const key in gameState.player.abilities) {
                            if (gameState.player.abilities[key]) { // Check if ability exists
                                gameState.player.abilities[key].cooldown *= 0.85;
                            }
                        }
                        break;
                }
                this._toggleOverlay(this.elements.levelUpMenu, false);
                if (this.elements.levelUpMenu) this.elements.levelUpMenu.style.animation = ''; // Remove a animação
                EventManager.emit('ui_level_up_applied'); // Notifica que o upgrade foi aplicado
                EventManager.emit('player_level_up_stats', { level: gameState.player.level, damage: gameState.player.damage }); // Atualiza a UI de stats
            }

            /**
             * Exibe uma notificação de checkpoint salvo.
             * @param {string} title - Título da notificação.
             * @param {string} description - Descrição da notificação.
             */
            showCheckpointNotification(title, description) {
                if (!this.elements.checkpointText || !this.elements.checkpointDescription || !this.elements.checkpointNotification) return;
                this.elements.checkpointText.textContent = title;
                this.elements.checkpointDescription.textContent = description;
                this.elements.checkpointNotification.style.display = 'block';
                this.elements.checkpointNotification.style.animation = 'checkpointPulse 2s ease-in-out';
                setTimeout(() => {
                    if (this.elements.checkpointNotification) this.elements.checkpointNotification.style.display = 'none';
                }, 2000);
            }

            /**
             * Efeito de flash na tela.
             * @param {object} data - { color, duration }.
             */
            flashScreen(data) {
                if (!this.elements.screenFlash) return;
                this.elements.screenFlash.style.background = data.color;
                this.elements.screenFlash.classList.add('active');
                setTimeout(() => {
                    if (this.elements.screenFlash) this.elements.screenFlash.classList.remove('active');
                }, data.duration);
            }

            /**
             * Efeito de "tremor" na tela.
             * @param {object} data - { intensity, duration }.
             */
            screenShake(data) {
                if (!GameManager.Instance.gameSettings.screenShake || !document.getElementById('game-container')) return;
                const gameContainer = document.getElementById('game-container');
                const originalTransform = gameContainer.style.transform;
                const startTime = performance.now();
                
                const shake = () => {
                    const elapsed = performance.now() - startTime;
                    if (elapsed < data.duration) {
                        const progress = elapsed / data.duration;
                        const currentIntensity = data.intensity * (1 - progress);
                        
                        const offsetX = (Math.random() - 0.5) * currentIntensity;
                        const offsetY = (Math.random() - 0.5) * currentIntensity;
                        
                        gameContainer.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                        requestAnimationFrame(shake);
                    } else {
                        gameContainer.style.transform = originalTransform;
                    }
                };
                shake();
            }

            /**
             * Atualiza a visibilidade dos controles mobile.
             * @param {boolean} isMobile - Se o dispositivo é mobile.
             * @param {boolean} isLandscape - Se a orientação é paisagem.
             */
            updateMobileControlsVisibility(isMobile, isLandscape) {
                if (this.elements.mobileControls) {
                    this.elements.mobileControls.style.display = (isMobile && isLandscape) ? 'grid' : 'none';
                }
            }

            /**
             * Mostra a tela de vitória.
             * @param {string} playerName - Nome do jogador.
             * @param {number} level - Nível final.
             * @param {number} xp - XP total.
             */
            showVictoryScreen(playerName, level, xp) {
                if (this.elements.cinematicGif) {
                    this.elements.cinematicGif.style.display = 'none';
                    this.elements.cinematicGif.src = '';
                }
                
                this._toggleOverlay(this.elements.cinematicOverlay, true);
                
                if (this.elements.cinematicTitle) this.elements.cinematicTitle.textContent = "VITÓRIA!";
                if (this.elements.cinematicText) {
                    this.elements.cinematicText.innerHTML = `
                        <p>Parabéns, ${playerName}!</p>
                        <br>
                        <p>Você completou a primeira parte da jornada em Tupãry. Tarek foi derrotado e o caminho para o interior do reino gelado está aberto.</p>
                        <br>
                        <p>Mas esta é apenas a primeira de muitas provações. O Coração de Gelo ainda aguarda, e Ignys se aproxima...</p>
                        <br>
                        <p><strong>Estatísticas Finais:</strong></p>
                        <p>Nível Alcançado: ${level}</p>
                        <p>Classe: Escolhido</p>
                        <p>XP Total: ${xp}</p>
                        <br>
                        <p><em>Obrigado por jogar Tupãry: O Reino Congelado!</em></p>
                        <p><em>Mais capítulos em breve...</em></p>
                    `;
                }
                
                if (this.elements.cinematicTitle) this.elements.cinematicTitle.style.animation = 'none';
                if (this.elements.cinematicText) this.elements.cinematicText.style.animation = 'none';
                if (this.elements.cinematicTitle) void this.elements.cinematicTitle.offsetWidth;
                if (this.elements.cinematicText) void this.elements.cinematicText.offsetWidth;
                if (this.elements.cinematicTitle) this.elements.cinematicTitle.style.animation = 'fadeInText 2s forwards';
                if (this.elements.cinematicText) this.elements.cinematicText.style.animation = 'fadeInText 3s forwards 1s';
                
                if (this.elements.skipBtn) {
                    this.elements.skipBtn.textContent = 'Voltar ao Menu';
                    this.elements.skipBtn.onclick = () => {
                        // Limpa cookies de save e checkpoint ao finalizar o jogo
                        GameManager.Instance._setCookie('tupary_save', '', -1);
                        GameManager.Instance._setCookie('tupary_checkpoint', '', -1);
                        GameManager.Instance.exitToMenu();
                    };
                }
            }
        }

        /**
         * @class AudioManager
         * @description Gerencia a reprodução de áudios (música e efeitos sonoros).
         */
        class AudioManager {
            constructor() {
                if (AudioManager.Instance) {
                    return AudioManager.Instance;
                }
                AudioManager.Instance = this;

                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.audioSources = {}; // Armazena AudioBuffers
                this.currentMusicSource = null; // Source node da música atual
                this.musicGainNode = this.audioContext.createGain(); // Nó de ganho para música
                this.sfxGainNode = this.audioContext.createGain(); // Nó de ganho para SFX

                // Conecta os nós de ganho ao destino de áudio
                this.musicGainNode.connect(this.audioContext.destination);
                this.sfxGainNode.connect(this.audioContext.destination);

                this.setMusicVolume(GameManager.Instance.gameSettings.musicVolume);
                this.setSfxVolume(GameManager.Instance.gameSettings.sfxVolume);

                // Listeners para reproduzir SFX e música
                EventManager.subscribe('sfx_play', this.playSFX.bind(this));
                EventManager.subscribe('music_play', (data) => this.playMusic(data.name, data.loop, data.volume));
                EventManager.subscribe('music_stop', this.stopMusic.bind(this));
            }

            /**
             * Carrega um arquivo de áudio.
             * @param {string} name - Nome para identificar o áudio.
             * @param {string} url - URL do arquivo de áudio.
             */
            async loadSound(name, url) {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.audioSources[name] = audioBuffer;
                    console.log(`Áudio carregado: ${url}`);
                    return audioBuffer; // Retorna o buffer carregado
                } catch (error) {
                    console.error(`Erro ao carregar o áudio '${name}' de '${url}':`, error);
                    // Retorna um buffer vazio para evitar erros futuros
                    return this.audioContext.createBuffer(2, 22050, 44100);
                }
            }

            /**
             * Reproduz um efeito sonoro.
             * @param {string} name - Nome do SFX.
             * @param {number} volume - Volume (0.0 a 1.0).
             */
            playSFX(name, volume = 1.0) {
                if (!this.audioSources[name]) {
                    console.warn(`Áudio SFX '${name}' não carregado ou inválido.`);
                    return;
                }
                try {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = this.audioSources[name];
                    source.connect(this.sfxGainNode);
                    source.start(0);
                } catch (error) {
                    console.error("Erro ao reproduzir SFX:", error);
                }
            }

            /**
             * Reproduz uma música.
             * @param {string} name - Nome da música.
             * @param {boolean} loop - Se a música deve repetir.
             * @param {number} volume - Volume (0.0 a 1.0).
             */
            playMusic(name, loop = true, volume = 0.7) {
                this.stopMusic(); // Para qualquer música tocando

                if (!this.audioSources[name]) {
                    console.warn(`Música '${name}' não carregada ou inválida.`);
                    return;
                }

                try {
                    const source = this.audioContext.createBufferSource();
                    source.buffer = this.audioSources[name];
                    source.loop = loop;
                    source.connect(this.musicGainNode);
                    source.start(0);
                    this.currentMusicSource = source;
                } catch (error) {
                    console.error("Erro ao reproduzir música:", error);
                }
            }

            /**
             * Para a música atual.
             */
            stopMusic() {
                if (this.currentMusicSource) {
                    try {
                        this.currentMusicSource.stop();
                        this.currentMusicSource.disconnect(); // Desconecta o nó para liberar recursos
                    } catch (error) {
                        console.error("Erro ao parar música:", error);
                    }
                    this.currentMusicSource = null;
                }
            }

            /**
             * Define o volume da música.
             * @param {number} volume - Volume (0.0 a 1.0).
             */
            setMusicVolume(volume) {
                this.musicGainNode.gain.value = volume;
            }

            /**
             * Define o volume dos efeitos sonoros.
             * @param {number} volume - Volume (0.0 a 1.0).
             */
            setSfxVolume(volume) {
                this.sfxGainNode.gain.value = volume;
            }
        }

        /**
         * @class AssetLoader
         * @description Gerencia o carregamento de todos os assets do jogo.
         */
        class AssetLoader {
            constructor() {
                if (AssetLoader.Instance) {
                    return AssetLoader.Instance;
                }
                AssetLoader.Instance = this;

                this.totalAssetsToLoad = 0;
                this.assetsLoadedCount = 0;
            }

            /**
             * Carrega todos os assets definidos no CONFIG.ASSET_PATHS.
             * @returns {Promise<void>}
             */
            async loadAllAssets() {
                const assetPromises = [];
                for (const [key, path] of Object.entries(CONFIG.ASSET_PATHS)) {
                    if (Array.isArray(path)) { // Se o caminho é um array de frames (para animações)
                        this.totalAssetsToLoad += path.length;
                        const framePromises = path.map(framePath => this._loadImage(framePath));
                        assetPromises.push(Promise.all(framePromises).then(images => { CONFIG.ASSET_LOADED[key] = images; }));
                    } else if (typeof path === 'string' && (path.endsWith('.gif') || path.endsWith('.png') || path.endsWith('.jpg') || path.endsWith('.jpeg'))) {
                        this.totalAssetsToLoad++;
                        assetPromises.push(this._loadImage(path).then(img => { CONFIG.ASSET_LOADED[key] = img; }));
                    } else if (typeof path === 'string' && (path.endsWith('.mp3') || path.endsWith('.wav'))) {
                        this.totalAssetsToLoad++;
                        assetPromises.push(AudioManager.Instance.loadSound(key, path));
                    }
                }
                await Promise.all(assetPromises);
                console.log("Todos os assets carregados.");
            }

            /**
             * Carrega uma imagem e retorna o objeto Image.
             * @param {string} path - Caminho da imagem.
             * @returns {Promise<Image>}
             * @private
             */
            _loadImage(path) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.src = path;
                    img.onload = () => {
                        this.assetsLoadedCount++;
                        console.log(`Imagem carregada: ${path} (${this.assetsLoadedCount}/${this.totalAssetsToLoad})`);
                        resolve(img);
                    };
                    img.onerror = (e) => {
                        console.error(`Erro ao carregar imagem '${path}':`, e);
                        // Fallback para uma imagem transparente 1x1 em caso de erro
                        const placeholder = new Image();
                        placeholder.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='; 
                        this.assetsLoadedCount++;
                        resolve(placeholder); // Resolve mesmo com erro para não travar o carregamento
                    };
                });
            }
        }


        // =================================================================================================
        // ===== 9. LÓGICA DO JOGO (init, gameLoop, update, render, setupPhases) ===========================
        // =================================================================================================

        let GameManagerInstance;
        let UIManagerInstance;
        let AudioManagerInstance;
        let ObjectPoolerInstance;
        let AssetLoaderInstance;

        /**
         * Inicializa o jogo.
         */
        async function init() {
            // Obter o elemento game-world para injetar entidades DOM
            gameWorldElement = document.getElementById('game-world');

            // Inicializa as instâncias dos Singletons
            GameManagerInstance = new GameManager();
            UIManagerInstance = new UIManager();
            AudioManagerInstance = new AudioManager();
            ObjectPoolerInstance = new ObjectPooler();
            AssetLoaderInstance = new AssetLoader();

            // Detecta dispositivo e orientação
            detectDevice();
            
            // Canvas agora é opcional, mas mantido para compatibilidade se precisar de drawing específico
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas(); // Ajusta o tamanho do game-container e game-world
            window.addEventListener('resize', resizeCanvas);
            
            // Carrega assets (aguarda para continuar)
            await AssetLoader.Instance.loadAllAssets();
            
            // Inicializa pools de objetos após assets carregados
            ObjectPooler.Instance.initializePools();

            // Inicializa cores CSS para uso no DOM e lógica
            initGlobalColors();
            
            // Tenta carregar progresso salvo para preencher o menu
            const savedData = GameManager.Instance._loadProgress();
            if (savedData) {
                UIManager.Instance.elements.playerNameInput.value = savedData.playerName || ''; // CORREÇÃO: UIManager.Instance
                UIManager.Instance.validateMainMenuInputs(); // Chamada inicial para validar o botão // CORREÇÃO: UIManager.Instance
            } else {
                AudioManager.Instance.playMusic('music_menu', true); // CORREÇÃO: AudioManager.Instance
            }
            
            // Inicia o loop do jogo
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * O loop principal do jogo.
         * @param {DOMHighResTimeStamp} timestamp - Tempo atual em milissegundos.
         */
        function gameLoop(timestamp) {
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Limita o deltaTime para evitar "pulos" durante lags
            deltaTime = Math.min(deltaTime, CONFIG.DELTA_TIME_CAP);
            
            if (!gameState.gamePaused && gameState.gameStarted) {
                if (!gameState.inCutscene && !gameState.inDialog) {
                    update(deltaTime);
                }
                render(deltaTime);
            } else if (gameState.inMenu) {
                // Não precisa de renderMenu, pois o menu é um elemento HTML estático
            } else {
                render(deltaTime); // Renderiza mesmo pausado para UI, etc. (atualiza posições de elementos já criados)
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Atualiza a lógica do jogo.
         * @param {number} deltaTime - Tempo decorrido (em ms).
         */
        function update(deltaTime) {
            // Atualiza o jogador
            if (gameState.player) {
                gameState.player.update(deltaTime);
            }

            // Atualiza inimigos
            enemies = enemies.filter(enemy => enemy.health.currentHealth > 0); // Remove inimigos mortos
            enemies.forEach(enemy => enemy.update(deltaTime));

            // Atualiza projéteis e partículas (Object Pooling)
            ObjectPooler.Instance.getActiveObjects('darkShotProjectile').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('etherealOrbProjectile').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('enemyIceShot').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossSlash').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossIceOrb').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossPrison').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossDash').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('snowParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('jumpDustParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('landDustParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('hitSparkParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('deathExplosionParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('projectileTrailParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('umbraFuriaParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('bossIntroParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('dashIceParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('prisonActivateParticle').forEach(p => p.update(deltaTime));
            ObjectPooler.Instance.getActiveObjects('xpGainParticle').forEach(p => p.update(deltaTime));


            // Atualiza espinhos que caem
            fallingSpikes.forEach(spike => spike.update(deltaTime));

            // Lógica de física (separada para FixedUpdate)
            fixedUpdate(deltaTime);

            // Atualiza a câmera
            updateCamera(deltaTime);

            // Verifica checkpoints
            checkpoints.forEach(cp => cp.checkCollisionWithPlayer());

            // Verifica colisão de espinhos com o jogador
            fallingSpikes.forEach((spike) => { 
                if (spike.checkCollisionWithPlayer()) {
                    // Implementar remoção do spike ou reset se for um uso único após colisão
                }
            });

            // Otimização de partículas (limita o número total)
            _limitParticles();
            
            // Gera partículas de neve (se estiver em uma fase normal e não no menu)
            if (!gameState.inMenu && !gameState.gamePaused && GameManager.backgroundImageKey === null) {
                if (Math.random() < CONFIG.SNOW_SPAWN_RATE) {
                    EventManager.emit('add_particles', { type: 'snow', x: gameState.player.position.x + Math.random() * gameWorldElement.offsetWidth, y: -10 + gameState.cameraOffset.y, count: 1 });
                }
            }

            // Limpa inputs de toque únicos
            if (gameState.player) {
                gameState.player.input.clearOneShotInputs();
            }
        }

        /**
         * Atualiza a lógica de física em intervalos fixos.
         * Separado do `update` para garantir consistência física.
         * @param {number} deltaTime - Tempo decorrido (em ms).
         */
        function fixedUpdate(deltaTime) {
            // Atualiza o jogador
            if (gameState.player) {
                gameState.player.fixedUpdate(deltaTime);
            }

            // Atualiza inimigos
            enemies.forEach(enemy => enemy.fixedUpdate(deltaTime));
        }

        /**
         * Renderiza todos os elementos do jogo no DOM.
         * Não desenha no Canvas diretamente.
         * @param {number} deltaTime - Tempo decorrido (em ms).
         */
        function render(deltaTime) {
            // A posição do gameWorldElement é ajustada para simular a câmera
            gameWorldElement.style.transform = `translate(${-gameState.cameraOffset.x}px, ${-gameState.cameraOffset.y}px)`;
            
            // Renderiza o jogador e inimigos (atualiza as posições de seus elementos DOM)
            if (gameState.player) gameState.player.render();
            enemies.forEach(e => e.render());

            // Renderiza projéteis e partículas (atualiza as posições de seus elementos DOM)
            ObjectPooler.Instance.getActiveObjects('darkShotProjectile').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('etherealOrbProjectile').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('enemyIceShot').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossSlash').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossIceOrb').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossPrison').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossDash').forEach(p => p.render());
            
            ObjectPooler.Instance.getActiveObjects('snowParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('jumpDustParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('landDustParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('hitSparkParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('deathExplosionParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('projectileTrailParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('umbraFuriaParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('bossIntroParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('dashIceParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('prisonActivateParticle').forEach(p => p.render());
            ObjectPooler.Instance.getActiveObjects('xpGainParticle').forEach(p => p.render());

            // Renderiza plataformas e checkpoints (já que são elementos DOM, a posição é setada uma vez na criação e atualizada aqui pelo transform do gameWorldElement)
            platforms.forEach(p => p.render());
            fallingSpikes.forEach(s => s.render());
            checkpoints.forEach(cp => cp.render()); // Para exibir em DEBUG_MODE

            // Remove números de dano/xp expirados do DOM.
            _removeExpiredDamageNumbers();

            if (window.DEBUG_MODE) {
                // Info de debug agora vai para o console, não para o Canvas
                // Para info na tela, seria necessário criar elementos DOM para isso
                renderDebugInfo(); // Chamada para mostrar o console.log com DEBUG INFO
            }
        }

        /**
         * Renderiza o plano de fundo.
         * Agora manipula o background-image do gameWorldElement.
         */
        function renderBackground() {
            if (GameManager.backgroundImageKey) {
                const imgAsset = CONFIG.ASSET_LOADED[GameManager.backgroundImageKey];
                if (imgAsset && imgAsset.src) { // Garante que a imagem foi carregada e tem src
                    gameWorldElement.style.backgroundImage = `url('${imgAsset.src}')`;
                    gameWorldElement.style.backgroundSize = 'cover';
                    gameWorldElement.style.backgroundPosition = 'center';
                } else {
                    console.warn(`Background asset not loaded or invalid: ${GameManager.backgroundImageKey}`);
                    gameWorldElement.style.backgroundImage = 'none'; // Fallback
                }
            } else {
                gameWorldElement.style.backgroundImage = 'none'; // Limpa imagem se não for para ter
            }
            gameWorldElement.style.backgroundColor = 'var(--primary-dark)'; // Fallback para cor sólida
            // Para parallax com DOM, manipular background-position ou criar divs para cada camada.
            // Aqui, mantemos simples com cor sólida.
        }

        /**
         * Atualiza a posição da câmera.
         * @param {number} deltaTime - Tempo decorrido (em ms).
         */
        function updateCamera(deltaTime) {
            if (gameState.fixedCamera) {
                gameState.cameraOffset.x = gameState.fixedCameraTarget.x;
                gameState.cameraOffset.y = gameState.fixedCameraTarget.y;
                return;
            }

            if (!gameState.player) return; // Não atualiza câmera se o jogador não existe

            // O tamanho do "viewport" do jogo é o tamanho do game-container
            const viewportWidth = document.getElementById('game-container').offsetWidth;
            const viewportHeight = document.getElementById('game-container').offsetHeight;

            gameState.targetCameraOffset.x = gameState.player.position.x - viewportWidth / 2;
            gameState.targetCameraOffset.y = gameState.player.position.y - viewportHeight / 2;
            
            // Limita a câmera aos limites do mundo
            gameState.targetCameraOffset.x = Math.max(0, Math.min(gameState.targetCameraOffset.x, CONFIG.WORLD_WIDTH - viewportWidth));
            gameState.targetCameraOffset.y = Math.max(0, Math.min(gameState.targetCameraOffset.y, CONFIG.WORLD_HEIGHT - viewportHeight)); // Usar 0 para Y para não mostrar "acima do mundo"
            
            // Suaviza o movimento da câmera
            gameState.cameraOffset.x += (gameState.targetCameraOffset.x - gameState.cameraOffset.x) * CONFIG.CAMERA_SMOOTHING;
            gameState.cameraOffset.y += (gameState.targetCameraOffset.y - gameState.cameraOffset.y) * CONFIG.CAMERA_SMOOTHING;
        }

        /**
         * Limita o número de partículas ativas.
         * @private
         */
        function _limitParticles() {
            const allParticles = ObjectPooler.Instance.getActiveObjects('snowParticle')
                .concat(ObjectPooler.Instance.getActiveObjects('jumpDustParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('landDustParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('hitSparkParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('deathExplosionParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('projectileTrailParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('umbraFuriaParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('bossIntroParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('dashIceParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('prisonActivateParticle'))
                .concat(ObjectPooler.Instance.getActiveObjects('xpGainParticle'));
            
            if (allParticles.length > CONFIG.MAX_PARTICLES) {
                // Remove as partículas mais antigas (as primeiras da lista)
                for (let i = 0; i < allParticles.length - CONFIG.MAX_PARTICLES; i++) {
                    allParticles[i].deactivate();
                }
            }
        }

        /**
         * Remove números de dano/XP expirados do DOM.
         * @private
         */
        function _removeExpiredDamageNumbers() {
            const existingNumbers = document.querySelectorAll('.damage-number, .xp-number'); // Query global
            const currentTime = performance.now();
            existingNumbers.forEach(number => {
                const startTime = parseFloat(number.dataset.startTime);
                const duration = parseFloat(number.dataset.duration);
                // Usar offsetTop e offsetLeft para verificar se está visível
                const isOffscreen = number.offsetTop < -50 || number.offsetLeft < -50 || 
                                    number.offsetTop > window.innerHeight + 50 || number.offsetLeft > window.innerWidth + 50;

                if (currentTime - startTime >= duration || isOffscreen) {
                    if (number.parentNode) { // Verifica se ainda está no DOM
                        number.parentNode.removeChild(number);
                    }
                }
            });
        }


        // =================================================================================================
        // ===== 10. FUNÇÕES UTILITÁRIAS ===================================================================
        // =================================================================================================

        /**
         * Detecta o tipo de dispositivo (mobile/desktop).
         */
        function detectDevice() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      window.innerWidth <= 800 || 
                      'ontouchstart' in window;
            
            if (isMobile) {
                checkOrientation();
                window.addEventListener('orientationchange', () => {
                    setTimeout(checkOrientation, 100);
                });
                window.addEventListener('resize', checkOrientation);
            }
        }

        /**
         * Verifica a orientação do dispositivo móvel.
         */
        function checkOrientation() {
            if (!isMobile) return;
            
            isLandscape = window.innerWidth > window.innerHeight;
            
            if (!isLandscape) {
                UIManager.Instance.elements.orientationWarning.style.display = 'flex'; // CORREÇÃO: UIManager.Instance
                if (gameState.gameStarted && !gameState.gamePaused && !gameState.inMenu) {
                    GameManager.Instance.togglePause(true);
                }
            } else {
                UIManager.Instance.elements.orientationWarning.style.display = 'none'; // CORREÇÃO: UIManager.Instance
                if (gameState.gameStarted && gameState.gamePaused && !gameState.inMenu && !gameState.inCutscene) {
                    GameManager.Instance.togglePause(false);
                }
            }
            UIManager.Instance.updateMobileControlsVisibility(isMobile, isLandscape); // CORREÇÃO: UIManager.Instance
        }

        /**
         * Redimensiona o game-container para se ajustar ao viewport.
         * O game-world será ajustado para o WORLD_WIDTH e WORLD_HEIGHT do jogo.
         */
        function resizeCanvas() { // Renomeado de resizeCanvas para melhor clareza no contexto DOM
            const gameContainer = document.getElementById('game-container');
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Mantém a proporção do jogo (16:9, ou o que for definido por max-width/height no CSS)
            // Adapta o game-container para o viewport
            let scale = Math.min(viewportWidth / 1600, viewportHeight / 770);
            gameContainer.style.width = `${1600 * scale}px`;
            gameContainer.style.height = `${770 * scale}px`;
            gameContainer.style.transform = `scale(1)`; // Garante que não haja escala externa

            // Ajusta o game-world para o tamanho total do mundo (para parallax)
            if (gameWorldElement) { // Verifica se o elemento já foi inicializado
                gameWorldElement.style.width = `${CONFIG.WORLD_WIDTH}px`;
                gameWorldElement.style.height = `${CONFIG.WORLD_HEIGHT}px`;
            }

            // Opcional: ajustar o canvas (se usado para efeitos)
            if (canvas) {
                canvas.width = 1600; // Ou o tamanho ideal para efeitos
                canvas.height = 770;
            }
            
            if (isMobile) {
                UIManager.Instance.updateMobileControlsVisibility(isMobile, isLandscape); // CORREÇÃO: UIManager.Instance
            }
        }

        /**
         * Inicializa as variáveis de cor global a partir do CSS.
         */
        function initGlobalColors() {
            const rootStyle = getComputedStyle(document.documentElement);
            COLOR_HEALTH = rootStyle.getPropertyValue('--health-color').trim();
            COLOR_MANA = rootStyle.getPropertyValue('--mana-color').trim();
            COLOR_XP = rootStyle.getPropertyValue('--xp-color').trim();
            COLOR_ACCENT_FIRE = rootStyle.getPropertyValue('--accent-fire').trim();
            COLOR_ACCENT_GOLD = rootStyle.getPropertyValue('--accent-gold').trim();
            COLOR_ACCENT_BLUE = rootStyle.getPropertyValue('--accent-blue').trim();
            COLOR_ACCENT_ICE = rootStyle.getPropertyValue('--accent-ice').trim();
            COLOR_TEXT_LIGHT = rootStyle.getPropertyValue('--text-light').trim();
            COLOR_UMBRA = rootStyle.getPropertyValue('--umbra-color').trim();
            COLOR_PLAYER_COLOR = rootStyle.getPropertyValue('--player-color').trim(); 
            COLOR_SPIKE = rootStyle.getPropertyValue('--spike-color').trim();
        }

        /**
         * Exibe informações de debug no console.
         */
        function renderDebugInfo() {
            if (!window.DEBUG_MODE || !gameState.player) return;

            // Em um sistema DOM-based, infos de debug são melhores no console ou em um overlay de UI específico.
            console.groupCollapsed("DEBUG INFO (Pressione F12 para console)");
            console.log(`FPS: ${Math.round(1000 / (performance.now() - lastTime))}`);
            console.log(`Player Pos: (${Math.round(gameState.player.position.x)}, ${Math.round(gameState.player.position.y)})`);
            console.log(`Player Vel: (${Math.round(gameState.player.physics.velocity.x)}, ${Math.round(gameState.player.physics.velocity.y)})`);
            console.log(`Camera Offset: (${Math.round(gameState.cameraOffset.x)}, ${Math.round(gameState.cameraOffset.y)})`);
            console.log(`Enemies: ${enemies.length}`);
            console.log(`Active Particles: ${ObjectPooler.Instance.getActiveObjects('snowParticle').length + ObjectPooler.Instance.getActiveObjects('hitSparkParticle').length + ObjectPooler.Instance.getActiveObjects('deathExplosionParticle').length + ObjectPooler.Instance.getActiveObjects('projectileTrailParticle').length}`);
            console.log(`Active Projectiles: ${ObjectPooler.Instance.getActiveObjects('darkShotProjectile').length + ObjectPooler.Instance.getActiveObjects('enemyIceShot').length}`);
            console.log(`Grounded: ${gameState.player.physics.isGrounded}`);
            console.log(`Current State: ${gameState.player.currentState.constructor.name}`);
            console.groupEnd();
        }

        // Event listener para adicionar partículas
        EventManager.subscribe('add_particles', (data) => {
            const particle = ObjectPooler.Instance.getFromPool(data.type + 'Particle', data);
            // Partículas não precisam ser adicionadas a uma lista global, pois ObjectPooler já as gerencia
        });

        // Event listener para spawnar projéteis
        EventManager.subscribe('spawn_projectile', (data) => {
            const projectile = ObjectPooler.Instance.getFromPool(data.type + 'Projectile', data);
            // Projéteis não precisam ser adicionados a uma lista global, ObjectPooler já as gerencia
        });

        // Event listener para mostrar números de dano/XP
        EventManager.subscribe('show_damage_number', (data) => {
            const damageNumberDiv = document.createElement('div');
            damageNumberDiv.className = data.isPlayerDamage ? 'damage-number' : 'xp-number'; 
            damageNumberDiv.textContent = data.value;
            // Posição ajustada para ser relativa ao elemento DOM do jogador
            damageNumberDiv.style.left = `${data.x}px`;
            damageNumberDiv.style.top = `${data.y}px`;
            
            // Adiciona metadados para controle de tempo pelo JS
            damageNumberDiv.dataset.startTime = performance.now();
            damageNumberDiv.dataset.duration = data.isPlayerDamage ? 1000 : 1500; // Duração da animação CSS

            gameWorldElement.appendChild(damageNumberDiv); // Adiciona ao game-world para que siga a câmera
        });

        // Player XP e Level Up (integrado com EventBus)
        if (Player.prototype.gainXP === undefined) { // Garante que a função só é definida uma vez
            Player.prototype.gainXP = function(amount) {
                this.xp += amount;
                EventManager.emit('show_damage_number', {
                    value: `+${amount} XP`,
                    x: this.position.x + CONFIG.PLAYER_WIDTH / 2,
                    y: this.position.y - 10,
                    isPlayerDamage: false // Não é dano
                });
                EventManager.emit('add_particles', { type: 'xpGain', x: this.position.x + CONFIG.PLAYER_WIDTH / 2, y: this.position.y + CONFIG.PLAYER_HEIGHT / 2, count: 8, color: COLOR_XP });

                if (this.xp >= this.nextLevelXP) {
                    this.levelUp();
                }
                EventManager.emit('xp_gained', { current: this.xp, max: this.nextLevelXP });
            };

            Player.prototype.levelUp = function() {
                this.level++;
                this.xp -= this.nextLevelXP;
                this.nextLevelXP = Math.floor(this.nextLevelXP * 1.8);
                
                // Buffs padrão ao level up (ajustar conforme Ben 10-ish)
                this.health.maxHealth += 10;
                this.health.heal(this.health.maxHealth);
                this.mana.maxMana += 15;
                this.mana.currentMana = this.mana.maxMana;
                this.damage += 3;
                this.baseSpeed += 0.2;
                this.currentSpeed = this.baseSpeed; // Garante que a velocidade atual também seja atualizada

                EventManager.emit('sfx_play', 'sfx_level_up');
                EventManager.emit('screen_flash', { color: COLOR_XP, duration: 500 });
                EventManager.emit('add_particles', { type: 'umbraFuria', x: this.position.x + CONFIG.PLAYER_WIDTH / 2, y: this.position.y + CONFIG.PLAYER_HEIGHT / 2, count: 30 });
                EventManager.emit('player_level_up', { level: this.level, damage: this.damage }); // Notifica que o jogador subiu de nível.
            };

             // Adiciona propriedades de XP e Nível no construtor do Player
             // (Esta é uma forma de "monkey patch" o construtor para adicionar propriedades)
            const originalPlayerConstructor = Player;
            Player = function(...args) {
                originalPlayerConstructor.apply(this, args);
                this.level = 1;
                this.xp = 0;
                this.nextLevelXP = 100;
            };
            // Restaura o prototype para não perder métodos da classe original
            Player.prototype = originalPlayerConstructor.prototype;
            Player.prototype.constructor = Player;
        }

        // Adiciona um método estático para o Checkpoint para busca
        if (Checkpoint.findByName === undefined) {
            Checkpoint.findByName = function(checkpointsArray, name) {
                return checkpointsArray.find(cp => cp.name === name);
            };
        }


        // Define o modo de debug se a URL tiver #debug
        if (window.location.hash === '#debug') {
            window.DEBUG_MODE = true;
            console.log('Modo DEBUG ativado!');
        }


        // ===== INICIALIZAÇÃO FINAL =====
        // Evento DOMContentLoaded garante que todo o HTML foi carregado antes de inicializar o jogo
        window.addEventListener('DOMContentLoaded', init);

        // Event listener para salvar progresso antes de fechar a aba/navegador
        window.addEventListener('beforeunload', (e) => {
            if (gameState.gameStarted && !gameState.inMenu) {
                GameManager.Instance.saveProgress();
            }
        });

        // Event listener para pausar o jogo quando a aba/janela não está ativa
        window.addEventListener('visibilitychange', () => {
            if (document.hidden && gameState.gameStarted && !gameState.inMenu && !gameState.gamePaused) {
                GameManager.Instance.togglePause(true);
            }
        });

        // Exposição global para debug (apenas em modo DEBUG)
        // Permite acessar objetos do jogo diretamente pelo console do navegador para depuração.
        if (window.DEBUG_MODE) {
            window.gameState = gameState;
            window.CONFIG = CONFIG;
            window.enemies = enemies;
            window.platforms = platforms;
            window.fallingSpikes = fallingSpikes;
            window.GameManager = GameManager.Instance;
            window.UIManager = UIManager.Instance;
            window.AudioManager = AudioManager.Instance;
            window.ObjectPooler = ObjectPooler.Instance;
            window.EventManager = EventManager;

            // Comandos de debug para facilitar testes no console
            window.debugCommands = {
                // Ativa o "modo deus" para o jogador (vida e mana infinitas)
                godMode: () => {
                    if (gameState.player) {
                        gameState.player.health.maxHealth = 9999;
                        gameState.player.health.currentHealth = 9999;
                        gameState.player.mana.maxMana = 9999;
                        gameState.player.mana.currentMana = 9999;
                        UIManager.Instance.updateHealth({ current: 9999, max: 9999 });
                        UIManager.Instance.updateMana({ current: 9999, max: 9999 });
                        console.log("God Mode ATIVADO!");
                    } else {
                        console.log("Jogador não encontrado para ativar God Mode.");
                    }
                },
                
                // Força o level up do jogador
                levelUp: () => {
                    if (gameState.player) {
                        gameState.player.gainXP(gameState.player.nextLevelXP); // Adiciona XP suficiente para o próximo nível
                        console.log(`Jogador subiu para o nível ${gameState.player.level}!`);
                    } else {
                        console.log("Jogador não encontrado para level up.");
                    }
                },
                
                // Teleporta o jogador para uma coordenada específica (útil para pular seções)
                teleport: (x = 4800, y = 300) => { // Valores padrão para um ponto mais avançado na fase 1
                    if (gameState.player) {
                        gameState.player.position.x = x;
                        gameState.player.position.y = y;
                        gameState.player.physics.velocity = { x: 0, y: 0 }; // Reseta velocidade para evitar quedas
                        console.log(`Jogador teleportado para (${x}, ${y}).`);
                    } else {
                        console.log("Jogador não encontrado para teleporte.");
                    }
                },
                
                // Inicia diretamente a luta contra o boss (fase 3)
                spawnBoss: () => {
                    GameManager.Instance.loadPhase(3);
                    console.log("Iniciando luta contra o Boss!");
                },
                
                // Remove todos os inimigos da tela
                clearEnemies: () => {
                    enemies.forEach(enemy => enemy.destroy()); // Garante que os elementos DOM sejam removidos
                    enemies = [];
                    console.log("Todos os inimigos removidos.");
                },
                
                // Adiciona partículas na posição do jogador para testes visuais
                addParticles: (type = 'snow', count = 50) => {
                    if (gameState.player) {
                        EventManager.emit('add_particles', { 
                            type: type, 
                            x: gameState.player.position.x + CONFIG.PLAYER_WIDTH / 2, 
                            y: gameState.player.position.y + CONFIG.PLAYER_HEIGHT / 2, 
                            count: count 
                        });
                        console.log(`Adicionadas ${count} partículas do tipo '${type}'.`);
                    } else {
                        console.log("Jogador não encontrado para adicionar partículas.");
                    }
                },

                // Simula o uso de uma habilidade pelo teclado (para testes)
                useAbilityDebug: (key) => {
                    if (gameState.player && gameState.player.abilities[key]) {
                        gameState.player.abilities[key].activate();
                        console.log(`Tentando ativar habilidade '${key}'.`);
                    } else {
                        console.log(`Habilidade '${key}' não encontrada ou jogador ausente.`);
                    }
                }
            };
        }
    </script>
</body>
</html>