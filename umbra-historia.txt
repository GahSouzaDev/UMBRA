<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tup√£ry: O Reino Congelado</title>
    <style>
        /* ===== VARI√ÅVEIS CSS ===== */
        :root {
            --primary-dark: #000000;
            --primary-medium: #0a0a0a;
            --primary-light: #1a1a1a;
            --accent-gold: #d4af37;
            --accent-gold-light: #f5d76e;
            --accent-blue: #3a86ff;
            --accent-ice: #90e0ef;
            --accent-fire: #ff6b6b;
            --accent-nature: #52b788;
            --text-light: #f0f0f0;
            --text-gray: #aaaaaa;
            --health-color: var(--accent-fire);
            --mana-color: var(--accent-blue);
            --xp-color: var(--accent-gold);
            --shadow-dark: rgba(0, 0, 0, 0.8);
            --spike-color: #666666; /* Nova cor para espinhos */
        }

        /* ===== RESET E BASE ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary-medium) 50%, var(--primary-light) 100%);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* ===== CONTAINER PRINCIPAL ===== */
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 1600px; /* Aumentado para 1600 */
            max-height: 770px; /* Ajustado para 770 */
            overflow: hidden;
            border: 3px solid var(--accent-gold);
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.4); /* Sombra dourada */
            background: linear-gradient(to bottom, #0f1419, #1a1a2e);
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            background: transparent;
        }

        /* ===== ORIENTA√á√ÉO MOBILE ===== */
        .orientation-warning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--primary-dark);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            text-align: center;
            padding: 20px;
        }

        .orientation-warning h2 {
            color: var(--accent-gold);
            margin-bottom: 20px;
            font-size: 24px;
        }

        .orientation-warning p {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
        }

        .rotate-icon {
            font-size: 48px;
            margin: 20px 0;
            animation: rotatePhone 2s infinite;
        }

        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }

        /* ===== TELA DE IN√çCIO/NOME ===== */
        .start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95) 0%, rgba(10, 10, 10, 0.95) 100%);
            z-index: 50;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-title {
            font-size: 36px;
            font-weight: bold;
            color: var(--accent-gold);
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            letter-spacing: 2px;
        }

        .game-subtitle {
            font-size: 18px;
            color: var(--accent-ice);
            text-align: center;
            margin-bottom: 40px;
            font-style: italic;
        }

        .name-input-group {
            margin-bottom: 30px;
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--accent-gold);
            border-radius: 10px;
            padding: 20px 30px;
            max-width: 400px;
            width: 90%;
        }

        .name-input-group label {
            display: block;
            color: var(--text-light);
            margin-bottom: 15px;
            font-weight: bold;
            font-size: 18px;
        }

        .name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--accent-blue);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s, box-shadow 0.3s;
            text-align: center;
        }

        .name-input:focus {
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold-light);
        }

        .start-game-btn {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(212, 175, 55, 0.3);
        }

        .start-game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.5);
        }

        .start-game-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* ===== UI LAYER ===== */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* Permite cliques atrav√©s da UI para o canvas */
        }

        /* ===== BARRAS DE STATUS ===== */
        .status-bars {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
        }

        .bar-container {
            width: 200px;
            height: 15px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--text-light);
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        .bar-fill {
            height: 100%;
            transition: width 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .health-fill {
            background: linear-gradient(90deg, #ff6b6b, #ff3333);
        }

        .mana-fill {
            background: linear-gradient(90deg, #4dabf7, #3366ff);
        }

        .xp-fill {
            background: linear-gradient(90deg, var(--accent-gold-light), var(--accent-gold));
        }

        .bar-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.3) 50%, transparent 100%);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .bar-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }

        /* ===== STATS DO JOGADOR ===== */
        .player-stats {
            position: absolute;
            top: 15px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 10px 15px;
            font-size: 14px;
            text-align: right;
            min-width: 150px;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        .stat-line:last-child {
            margin-bottom: 0;
        }

        .stat-label {
            color: var(--accent-ice);
            font-weight: bold;
        }

        .stat-value {
            color: var(--accent-gold);
            font-weight: bold;
        }

        /* ===== SISTEMA DE HABILIDADES (Desktop) ===== */
        .abilities-container {
            position: absolute;
            bottom: 15px;
            right: 15px;
            display: flex;
            gap: 12px;
            pointer-events: auto;
        }

        .ability-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(26, 26, 46, 0.8));
            border: 3px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .ability-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        .ability-btn:active {
            transform: scale(0.95);
        }

        .ability-btn.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .ability-btn.cooldown:hover {
            transform: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(from 0deg, transparent 0deg, rgba(0, 0, 0, 0.8) 0deg);
            transition: background 0.1s linear;
        }

        .ability-tooltip {
            position: absolute;
            bottom: 70px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--accent-blue);
            border-radius: 8px;
            padding: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            width: 200px;
            text-align: center;
            z-index: 10;
        }

        .ability-btn:hover .ability-tooltip {
            opacity: 1;
        }

        .tooltip-name {
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 5px;
        }

        .tooltip-description {
            color: var(--text-light);
            font-size: 12px;
            line-height: 1.3;
            margin-bottom: 5px;
        }

        .tooltip-cost {
            color: var(--mana-color);
            font-size: 11px;
            font-style: italic;
        }

        /* ===== CONTROLES MOBILE (Bot√µes D-pad) ===== */
        .mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 150px;
            display: grid; /* Usar grid para posicionar */
            grid-template-columns: 80px 80px auto 80px 80px; /* Colunas para D-pad e A√ß√µes */
            grid-template-rows: 60px 60px 30px; /* Linhas para D-pad e A√ß√µes */
            gap: 5px;
            pointer-events: auto;
            z-index: 5;
        }
        .mobile-dpad {
            grid-area: 1 / 1 / 3 / 3; /* Ocupa as duas primeiras colunas e duas primeiras linhas */
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            width: 120px;
            height: 120px;
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
        }

        .dpad-btn {
            background: var(--primary-medium);
            border: 2px solid var(--accent-blue);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.1s;
            border-radius: 5px;
        }
        .dpad-btn:active {
            background: var(--accent-blue);
            transform: scale(0.95);
        }

        .dpad-up { grid-area: 1 / 2 / 2 / 3; border-top-left-radius: 10px; border-top-right-radius: 10px;}
        .dpad-left { grid-area: 2 / 1 / 3 / 2; border-top-left-radius: 10px; border-bottom-left-radius: 10px;}
        .dpad-center { grid-area: 2 / 2 / 3 / 3; opacity: 0.3; pointer-events: none;}
        .dpad-right { grid-area: 2 / 3 / 3 / 4; border-top-right-radius: 10px; border-bottom-right-radius: 10px;}
        .dpad-down { grid-area: 3 / 2 / 4 / 3; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px;}

        .mobile-action-buttons {
            grid-area: 1 / 4 / 3 / 6; /* Ocupa as √∫ltimas duas colunas e duas primeiras linhas */
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            position: absolute;
            bottom: 20px;
            right: 20px;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .mobile-btn:active {
            transform: scale(0.9);
            background: rgba(212, 175, 55, 0.3);
        }

        /* ===== SISTEMA DE DI√ÅLOGO ===== */
        .dialog-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(10, 10, 10, 0.9));
            border: 3px solid var(--accent-blue);
            border-radius: 15px;
            padding: 20px;
            display: none;
            pointer-events: auto;
            z-index: 20;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .dialog-speaker {
            color: var(--accent-gold);
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .dialog-text {
            color: var(--text-light);
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
            min-height: 60px;
        }

        .dialog-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .dialog-option {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.2), rgba(255, 107, 107, 0.2));
            border: 2px solid var(--accent-gold);
            border-radius: 8px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-light);
            font-weight: bold;
        }

        .dialog-option:hover {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.4), rgba(255, 107, 107, 0.4));
            transform: translateX(5px);
        }

        .dialog-option:active {
            transform: translateX(5px) scale(0.98);
        }

        /* ===== CUTSCENES ===== */
        .cinematic-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            z-index: 30;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
            opacity: 0; /* Come√ßa invis√≠vel para o fade-in */
            transition: opacity 0.5s ease-in-out; /* Adicionado para fade-in/out */
        }
        .cinematic-overlay.active {
            opacity: 1;
        }

        .cinematic-text {
            font-size: 20px;
            text-align: center;
            max-width: 80%;
            margin-bottom: 30px;
            color: var(--text-light);
            line-height: 1.6;
            opacity: 0;
            animation: fadeInText 3s forwards;
        }

        .cinematic-title {
            font-size: 32px;
            color: var(--accent-gold);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .skip-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-weight: bold;
        }

        .skip-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
        }

        /* ===== PAUSE MENU ===== */
        .pause-btn {
            position: absolute;
            top: 15px;
            right: 180px; /* Ajustado para n√£o colidir com o boss bar na mobile */
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--accent-gold);
            color: var(--text-light);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            font-size: 16px;
        }

        .pause-btn:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: scale(1.1);
        }

        .pause-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 40;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }

        .pause-title {
            font-size: 36px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .menu-option {
            background: linear-gradient(45deg, var(--accent-gold), var(--accent-fire));
            color: var(--primary-dark);
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 200px;
        }

        .menu-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(212, 175, 55, 0.4);
        }

        /* ===== LEVEL UP (AUTOM√ÅTICO) ===== */
        .level-up {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(10, 10, 10, 0.95));
            border: 3px solid var(--accent-gold);
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            z-index: 35;
            display: none;
            min-width: 400px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .level-up-title {
            font-size: 28px;
            color: var(--accent-gold);
            font-weight: bold;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .level-up-subtitle {
            font-size: 16px;
            color: var(--text-light);
            margin-bottom: 25px;
        }

        /* ===== CHECKPOINT SYSTEM ===== */
        .checkpoint-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid var(--accent-blue);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            z-index: 25;
            display: none;
            animation: checkpointPulse 2s ease-in-out;
        }

        @keyframes checkpointPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.8; }
        }

        .checkpoint-text {
            color: var(--accent-blue);
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .checkpoint-description {
            color: var(--text-light);
            font-size: 14px;
        }

        /* ===== ANIMA√á√ïES ===== */
        @keyframes fadeInText {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes levelUpAnimation {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* ===== EFEITOS ESPECIAIS ===== */
        .screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.8);
            z-index: 15;
            opacity: 0;
            pointer-events: none;
        }

        .screen-flash.active {
            animation: flash 0.3s ease-out;
        }

        @keyframes flash {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        .boss-health-bar {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 400px;
            height: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--accent-fire);
            border-radius: 10px;
            display: none;
            overflow: hidden;
            z-index: 10; /* Para aparecer acima de elementos do jogo */
        }

        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--health-color), var(--accent-fire));
            transition: width 0.5s ease;
            position: relative;
        }

        .boss-health-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255, 255, 255, 0.4) 50%, transparent 100%);
            animation: shimmer 1.5s infinite;
        }

        .boss-name {
            position: absolute;
            top: 55px;
            left: 50%;
            transform: translateX(-50%);
            color: var(--accent-fire);
            font-size: 18px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 10;
        }

        /* ===== PART√çCULAS E N√öMEROS ===== */
        .particle-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 3;
        }

        .damage-number, .xp-number {
            position: absolute;
            font-weight: bold;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 10;
            animation: damageNumber 1s ease-out forwards;
        }
        .damage-number { color: var(--accent-fire); }
        .xp-number { color: var(--xp-color); animation: xpNumber 1.5s ease-out forwards; }

        @keyframes damageNumber {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
        }

        @keyframes xpNumber {
            0% { opacity: 1; transform: translateY(0) scale(0.8); }
            100% { opacity: 0; transform: translateY(-30px) scale(1.2); }
        }

        /* ===== RESPONSIVIDADE ===== */
        @media (max-width: 800px) {
            #game-container {
                width: 100vw;
                height: 100vh;
                max-width: none;
                max-height: none;
                border: none;
                border-radius: 0;
            }

            .mobile-controls {
                display: grid; /* For√ßar grid em mobile */
            }

            .abilities-container {
                display: none; /* Esconder desktop abilities */
            }

            .status-bars {
                top: 10px;
                left: 10px;
            }

            .bar-container {
                width: 150px;
                height: 12px;
            }

            .player-stats {
                top: 10px;
                right: 10px;
                padding: 8px 12px;
                font-size: 12px;
                min-width: 120px;
            }

            .pause-btn {
                top: 10px;
                right: 140px;
                width: 40px;
                height: 40px;
                font-size: 14px;
            }

            .dialog-container {
                width: 95%;
                padding: 15px;
                bottom: 15px;
            }

            .dialog-text {
                font-size: 14px;
                min-height: 50px;
            }

            .cinematic-text {
                font-size: 16px;
                max-width: 90%;
            }

            .cinematic-title {
                font-size: 24px;
            }

            .skip-btn {
                bottom: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 14px;
            }
        }

        @media (max-height: 500px) and (orientation: landscape) {
            .status-bars {
                top: 5px;
                left: 5px;
            }

            .bar-container {
                width: 120px;
                height: 10px;
            }

            .player-stats {
                top: 5px;
                right: 5px;
                padding: 5px 8px;
                font-size: 10px;
                min-width: 100px;
            }

            .mobile-dpad {
                bottom: 10px;
                left: 10px;
                width: 100px;
                height: 100px;
            }

            .mobile-action-buttons {
                bottom: 10px;
                right: 10px;
            }

            .mobile-btn {
                width: 45px;
                height: 45px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <!-- Aviso de Orienta√ß√£o Mobile -->
    <div class="orientation-warning" id="orientation-warning">
        <div class="rotate-icon">üì±</div>
        <h2>Vire o Dispositivo</h2>
        <p>Para uma melhor experi√™ncia de jogo, por favor vire seu dispositivo para o modo paisagem (horizontal).</p>
    </div>

    <!-- Container Principal do Jogo -->
    <div id="game-container">
        <!-- Tela de In√≠cio / Nome do Jogador -->
        <div class="start-screen" id="start-screen">
            <h1 class="game-title">TUP√ÉRY</h1>
            <p class="game-subtitle">O Reino Congelado</p>
            
            <div class="name-input-group">
                <label for="player-name">Desperte, Escolhido! Diga-me seu nome:</label>
                <input type="text" id="player-name" class="name-input" placeholder="Seu nome, para que o destino o chame..." maxlength="20">
            </div>
            
            <button class="start-game-btn" id="start-game-btn" disabled>Iniciar Jornada</button>
        </div>

        <!-- Canvas do Jogo -->
        <canvas id="game-canvas"></canvas>
        
        <!-- Flash de Tela -->
        <div class="screen-flash" id="screen-flash"></div>
        
        <!-- Container de Part√≠culas -->
        <div class="particle-container" id="particle-container"></div>

        <!-- UI Layer -->
        <div class="ui-layer">
            <!-- Barras de Status -->
            <div class="status-bars">
                <div class="status-bar">
                    <div class="status-icon">‚ù§Ô∏è</div>
                    <div class="bar-container">
                        <div class="bar-fill health-fill" id="health-fill"></div>
                        <div class="bar-text" id="health-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">üíô</div>
                    <div class="bar-container">
                        <div class="bar-fill mana-fill" id="mana-fill"></div>
                        <div class="bar-text" id="mana-text">100/100</div>
                    </div>
                </div>
                
                <div class="status-bar">
                    <div class="status-icon">‚≠ê</div>
                    <div class="bar-container">
                        <div class="bar-fill xp-fill" id="xp-fill"></div>
                        <div class="bar-text" id="xp-text">0/100</div>
                    </div>
                </div>
            </div>
            
            <!-- Stats do Jogador -->
            <div class="player-stats" id="player-stats">
                <div class="stat-line">
                    <span class="stat-label">N√≠vel:</span>
                    <span class="stat-value" id="player-level">1</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Classe:</span>
                    <span class="stat-value" id="player-class">Escolhido</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Dano:</span>
                    <span class="stat-value" id="player-damage">15</span>
                </div>
            </div>
            
            <!-- Barra de Vida do Boss -->
            <div class="boss-name" id="boss-name">TAREK, O GUERREIRO</div>
            <div class="boss-health-bar" id="boss-health-bar">
                <div class="boss-health-fill" id="boss-health-fill"></div>
            </div>
            
            <!-- Habilidades (Desktop) -->
            <div class="abilities-container" id="abilities-container">
                <div class="ability-btn" id="ability-u" data-key="U">
                    U
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-u-name">Ataque R√°pido</div>
                        <div class="tooltip-description" id="tooltip-u-desc">Golpe √°gil de curta dist√¢ncia.</div>
                        <div class="tooltip-cost" id="tooltip-u-cost">Custo: 0 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-i" data-key="I">
                    I
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-i-name">Proj√©til de Energia</div>
                        <div class="tooltip-description" id="tooltip-i-desc">Lan√ßa um proj√©til r√°pido √† dist√¢ncia.</div>
                        <div class="tooltip-cost" id="tooltip-i-cost">Custo: 15 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-o" data-key="O">
                    O
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-o-name">Explos√£o Arcana</div>
                        <div class="tooltip-description" id="tooltip-o-desc">Causa uma explos√£o de energia que danifica m√∫ltiplos inimigos √† frente.</div>
                        <div class="tooltip-cost" id="tooltip-o-cost">Custo: 30 Mana</div>
                    </div>
                </div>
                
                <div class="ability-btn" id="ability-p" data-key="P">
                    P
                    <div class="cooldown-overlay"></div>
                    <div class="ability-tooltip">
                        <div class="tooltip-name" id="tooltip-p-name">F√∫ria de Umbra</div>
                        <div class="tooltip-description" id="tooltip-p-desc">Canaliza a energia de Umbra para ficar mais r√°pido, resistente e poderoso no ataque.</div>
                        <div class="tooltip-cost" id="tooltip-p-cost">Custo: 50 Mana</div>
                    </div>
                </div>
            </div>
            
            <!-- Bot√£o de Pausa -->
            <div class="pause-btn" id="pause-btn">‚è∏Ô∏è</div>
            
            <!-- Controles Mobile (D-pad e A√ß√µes) -->
            <div class="mobile-controls" id="mobile-controls">
                <div class="mobile-dpad">
                    <div class="dpad-btn dpad-up" id="mobile-up">‚ñ≤</div>
                    <div class="dpad-btn dpad-left" id="mobile-left">‚óÄ</div>
                    <div class="dpad-btn dpad-center"></div>
                    <div class="dpad-btn dpad-right" id="mobile-right">‚ñ∂</div>
                    <div class="dpad-btn dpad-down" id="mobile-down">‚ñº</div>
                </div>
                
                <div class="mobile-action-buttons">
                    <div class="mobile-btn" id="mobile-ability-u">U</div>
                    <div class="mobile-btn" id="mobile-ability-i">I</div>
                    <div class="mobile-btn" id="mobile-ability-o">O</div>
                    <div class="mobile-btn" id="mobile-ability-p">P</div>
                </div>
            </div>
            
            <!-- Sistema de Di√°logo -->
            <div class="dialog-container" id="dialog-container">
                <div class="dialog-speaker" id="dialog-speaker"></div>
                <div class="dialog-text" id="dialog-text"></div>
                <div class="dialog-options" id="dialog-options"></div>
            </div>
            
            <!-- Overlay de Cutscene -->
            <div class="cinematic-overlay" id="cinematic-overlay">
                <div class="cinematic-title" id="cinematic-title"></div>
                <div class="cinematic-text" id="cinematic-text"></div>
                <button class="skip-btn" id="skip-btn">Pular (Espa√ßo)</button>
            </div>
            
            <!-- Menu de Pausa -->
            <div class="pause-menu" id="pause-menu">
                <h2 class="pause-title">JOGO PAUSADO</h2>
                <button class="menu-option" id="resume-btn">Continuar</button>
                <button class="menu-option" id="restart-btn">Reiniciar Checkpoint</button>
                <button class="menu-option" id="save-btn">Salvar Progresso</button>
                <button class="menu-option" id="exit-btn">Voltar ao Menu</button>
            </div>
            
            <!-- Sistema de Level Up (AUTOM√ÅTICO) -->
            <div class="level-up" id="level-up">
                <h2 class="level-up-title">N√çVEL AUMENTADO!</h2>
                <p class="level-up-subtitle">Seu poder cresce, Escolhido!</p>
                <button class="menu-option" id="continue-level-up-btn">Continuar</button>
            </div>
            
            <!-- Notifica√ß√£o de Checkpoint -->
            <div class="checkpoint-notification" id="checkpoint-notification">
                <div class="checkpoint-text">CHECKPOINT SALVO</div>
                <div class="checkpoint-description">Seu progresso foi salvo automaticamente</div>
            </div>
        </div>
    </div>

    <script>
        // ===== CONFIGURA√á√ïES GLOBAIS =====
        const CONFIG = {
            // F√≠sica do jogo
            GRAVITY: 0.6,
            PLAYER_SPEED: 4,
            JUMP_FORCE: 14,
            CROUCH_HEIGHT: 30,
            NORMAL_HEIGHT: 50,
            PLAYER_WIDTH: 50, // Definido para f√°cil acesso
            PLAYER_HEIGHT: 50, // Definido para f√°cil acesso
            
            // Mundo
            WORLD_WIDTH: 3000, // Aumentado para demonstrar a expans√£o
            WORLD_HEIGHT: 450,
            CAMERA_SMOOTHING: 0.08,
            
            // Combate
            DAMAGE_FLASH_DURATION: 200,
            INVINCIBILITY_DURATION: 1000,
            
            // Regenera√ß√£o
            MANA_REGEN_RATE: 2.0, // Aumentado para uso mais frequente de habilidades
            HEALTH_REGEN_RATE: 0.05,
            
            // Part√≠culas
            MAX_PARTICLES: 200,
            SNOW_SPAWN_RATE: 0.15,
            
            // Performance
            TARGET_FPS: 60,
            DELTA_TIME_CAP: 32,

            // Habilidades do Escolhido (Poderes de Umbra)
            UMBRA_FURY_DURATION: 7000, // Dura√ß√£o da Ultimate (7 segundos)
            UMBRA_FURY_DAMAGE_BOOST: 1.5, // Dano base do ataque U na ultimate
            UMBRA_FURY_SPEED_BOOST: 1.3, // Aumento de velocidade na ultimate
            UMBRA_FURY_DAMAGE_REDUCTION: 0.5, // Redu√ß√£o de dano recebido na ultimate

            // CAMINHOS DE RECURSOS (Imagens e √Åudios)
            // IMPORTANTE: Substitua estes caminhos pelos seus pr√≥prios arquivos GIF/PNG/JPG!
            // Exemplo: 'player_idle.gif', 'sound_impact.mp3'
            ASSET_PATHS: {
                // Sprites do Jogador (substitua por caminhos para suas folhas de sprites ou GIFs)
                player_idle: 'assets/sprites/player/idle.gif', 
                player_walk: 'assets/sprites/player/walk.gif', 
                player_jump: 'assets/sprites/player/jump.gif', 
                player_crouch: 'assets/sprites/player/crouch.gif', 
                player_attack_u: 'assets/sprites/player/attack_u.gif', 
                player_attack_i: 'assets/sprites/player/attack_i.gif', 
                player_attack_o: 'assets/sprites/player/attack_o.gif', 
                player_ultimate: 'assets/sprites/player/ultimate_form.gif', 
                player_damage_flash: 'assets/sprites/player/damage_flash.png', // Exemplo de imagem para flash de dano

                // Sprites de Inimigos e Bosses
                sentinel_sprite: 'assets/sprites/enemies/sentinel.gif', 
                tarek_sprite_idle: 'assets/sprites/bosses/tarek_idle.gif', // Tarek parado
                tarek_sprite_walk: 'assets/sprites/bosses/tarek_walk.gif', // Tarek andando
                tarek_sprite_attack: 'assets/sprites/bosses/tarek_attack.gif', // Tarek atacando (pode ser uma base para as habilidades)

                // Efeitos de Habilidade e Part√≠culas
                projectile_i: 'assets/sprites/effects/projectile_i.gif', 
                explosion_o: 'assets/sprites/effects/explosion_o.gif', 
                tarek_ice_orb: 'assets/sprites/effects/tarek_ice_orb.gif', 
                tarek_prison: 'assets/sprites/effects/tarek_prison.gif', 
                falling_spike_sprite: 'assets/sprites/obstacles/falling_spike.png', // Novo sprite para espinho que cai

                // Elementos do cen√°rio
                platform_ground: 'assets/sprites/platforms/ground.png',
                platform_basic: 'assets/sprites/platforms/platform_basic.png',
                platform_slippery: 'assets/sprites/platforms/platform_slippery.png',
                spike_trap: 'assets/sprites/obstacles/spike_trap.png', // Espinhos fixos

                // Backgrounds (Exemplos, ajuste conforme suas camadas de parallax)
                bg_sky: 'assets/backgrounds/sky.png', 
                bg_mountains: 'assets/backgrounds/mountains.png',
                bg_hills: 'assets/backgrounds/hills.png',
                bg_foreground: 'assets/backgrounds/foreground.png',

                // √Åudios
                music_menu: 'assets/audio/music/menu.mp3', 
                music_platforming: 'assets/audio/music/platforming.mp3', 
                music_boss_tarek: 'assets/audio/music/tarek_boss.mp3', 
                sfx_jump: 'assets/audio/sfx/jump.mp3', 
                sfx_attack_u: 'assets/audio/sfx/attack_u.mp3', 
                sfx_ability_i: 'assets/audio/sfx/ability_i.mp3', 
                sfx_ability_o: 'assets/audio/sfx/ability_o.mp3', 
                sfx_ability_p: 'assets/audio/sfx/ability_p.mp3', 
                sfx_damage_player: 'assets/audio/sfx/damage_player.mp3', 
                sfx_damage_enemy: 'assets/audio/sfx/damage_enemy.mp3', 
                sfx_level_up: 'assets/audio/sfx/level_up.mp3', 
                sfx_boss_roar: 'assets/audio/sfx/boss_roar.mp3',
                sfx_spike_fall: 'assets/audio/sfx/spike_fall.mp3', // Novo SFX para espinho caindo
            }
        };

        // ===== VARI√ÅVEIS GLOBAIS =====
        let canvas, ctx;
        let isMobile = false;
        let isLandscape = true;
        
        // Estado do jogo
        let gameState = {
            // Jogador
            playerName: '',
            playerClass: 'Escolhido', // Fixo para o Escolhido
            playerHealth: 100,
            playerMaxHealth: 100,
            playerMana: 100,
            playerMaxMana: 100,
            playerPosition: { x: 100, y: 300 },
            playerVelocity: { x: 0, y: 0 },
            playerLevel: 1,
            playerXP: 0,
            playerNextLevelXP: 100,
            playerDamage: 15,
            playerSpeed: CONFIG.PLAYER_SPEED,
            
            // Estados do Jogador
            isGrounded: false,
            isCrouching: false,
            isInvincible: false,
            invincibilityTimer: 0,
            facing: 'right',
            currentAnimation: 'idle', // 'idle', 'walk', 'jump', 'crouch', 'attack_u', 'attack_i', 'attack_o', 'umbra_fury'
            isUmbraFurious: false, // Novo estado para Ultimate
            umbraFuryTimer: 0,
            
            // Habilidades
            abilitiesCooldown: { U: 0, I: 0, O: 0, P: 0 },
            abilitiesMaxCooldown: { U: 0.5, I: 2, O: 4, P: 20 }, // Cooldowns ajustados
            
            // Controle de jogo
            gamePaused: false,
            inDialog: false,
            inCutscene: false,
            inStartScreen: true, // Novo estado para a tela inicial
            gameStarted: false,
            
            // C√¢mera
            cameraOffset: { x: 0, y: 0 },
            targetCameraOffset: { x: 0, y: 0 },
            
            // Fase atual
            currentPhase: 0, // 0: Start Screen, 1: Intro Cinematic, 2: Platforming (Pre-Tarek), 3: Tarek Dialogue, 4: Tarek Boss Fight
            currentCheckpoint: 'start',
            
            // Boss fight
            inBossFight: false,
            bossDefeated: false,

            // Tarek Encounter
            inTarekEncounter: false, // Novo estado para o di√°logo fixo
            tarekDialogStep: 0,
            tarekDialogCompleted: false,

            // Fixed camera for specific encounters
            fixedCamera: false,
            fixedCameraTarget: { x: 0, y: 0 } // Posi√ß√£o para onde a c√¢mera deve ficar fixa
        };

        // Arrays de entidades
        let platforms = [];
        let particles = [];
        let backgroundLayers = [];
        let enemies = []; // Inclui Sentinelas e Tarek
        let abilityEffects = [];
        let damageNumbers = [];
        let checkpoints = [];
        let fallingSpikes = []; // Novo array para espinhos que caem
        
        // Controles
        let keys = {};
        let lastTime = 0;
        let animationFrameId = null;
        
        // Mobile controls
        let mobileControls = {
            up: false,
            down: false,
            left: false,
            right: false,
            abilityU: false,
            abilityI: false,
            abilityO: false,
            abilityP: false
        };

        // Player Character (Chosen One) definition
        let currentChampion = null;

        // ===== Sistema de √Åudio (Novo) =====
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioSources = {}; // Cache para buffers de √°udio
        let currentMusic = null;

        async function loadSound(name, url) {
            try {
                if (!url) { // Ignorar assets com URL vazia
                    console.warn(`URL vazia para √°udio: ${name}. Pulando carregamento.`);
                    return;
                }
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                audioSources[name] = audioBuffer;
                console.log(`√Åudio '${name}' carregado.`);
            } catch (error) {
                console.error(`Erro ao carregar o √°udio '${name}' (${url}):`, error);
            }
        }

        function playSound(name, volume = 1.0) {
            if (!audioSources[name]) {
                // console.warn(`√Åudio '${name}' n√£o carregado ou n√£o encontrado.`);
                return;
            }
            const source = audioContext.createBufferSource();
            source.buffer = audioSources[name];
            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume * gameSettings.sfxVolume;
            source.connect(gainNode).connect(audioContext.destination);
            source.start(0);
        }

        function playMusic(name, loop = true, volume = 0.7) {
            if (currentMusic) {
                currentMusic.stop();
            }

            if (!audioSources[name]) {
                // console.warn(`M√∫sica '${name}' n√£o carregada ou n√£o encontrada.`);
                return;
            }

            const source = audioContext.createBufferSource();
            source.buffer = audioSources[name];
            source.loop = loop;
            const gainNode = audioContext.createGain();
            gainNode.gain.value = volume * gameSettings.musicVolume;
            source.connect(gainNode).connect(audioContext.destination);
            source.start(0);
            currentMusic = source;
            console.log(`Tocando m√∫sica: '${name}'.`);
        }

        function stopMusic() {
            if (currentMusic) {
                currentMusic.stop();
                currentMusic = null;
                console.log('M√∫sica parada.');
            }
        }

        // ===== Gerenciador de Assets (Imagens) =====
        const ASSET_MANAGER = {
            cache: {},
            successCount: 0,
            errorCount: 0,
            assetQueue: [],

            queueDownload(path) {
                if (!path) return; // Ignorar paths vazios
                this.assetQueue.push(path);
            },

            isDone() {
                return this.assetQueue.length === this.successCount + this.errorCount;
            },

            downloadAll(callback) {
                if (this.assetQueue.length === 0) {
                    callback();
                    return;
                }
                for (let i = 0; i < this.assetQueue.length; i++) {
                    const path = this.assetQueue[i];
                    const img = new Image();
                    img.addEventListener("load", () => {
                        this.successCount++;
                        console.log(`Imagem ${path} carregada.`);
                        if (this.isDone()) callback();
                    });
                    img.addEventListener("error", () => {
                        this.errorCount++;
                        console.error(`Erro ao carregar imagem ${path}.`);
                        if (this.isDone()) callback();
                    });
                    img.src = path;
                    this.cache[path] = img;
                }
            },

            getAsset(path) {
                return this.cache[path];
            }
        };

        // ===== DETEC√á√ÉO DE DISPOSITIVO =====
        function detectDevice() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                      window.innerWidth <= 800 || 
                      'ontouchstart' in window;
            
            if (isMobile) {
                checkOrientation();
                window.addEventListener('orientationchange', () => {
                    setTimeout(checkOrientation, 100);
                });
                window.addEventListener('resize', checkOrientation);
            }
        }

        function checkOrientation() {
            if (!isMobile) return;
            
            isLandscape = window.innerWidth > window.innerHeight;
            const orientationWarning = document.getElementById('orientation-warning');
            
            if (!isLandscape) {
                orientationWarning.style.display = 'flex';
                if (gameState.gameStarted && !gameState.gamePaused) { // Pausa o jogo se virar e n√£o estiver pausado
                    togglePause();
                }
            } else {
                orientationWarning.style.display = 'none';
                if (gameState.gameStarted && gameState.gamePaused && !gameState.inStartScreen && !gameState.inCutscene) { // Volta do pause se estava pausado por orienta√ß√£o
                    // S√≥ despausa se n√£o estiver em cutscene ou tela inicial
                    togglePause();
                }
            }
            updateMobileControlsVisibility();
        }

        // ===== Feedback T√°til (Vibra√ß√£o) =====
        function vibrate(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        // ===== SISTEMA DE COOKIES =====
        function setCookie(name, value, days = 30) {
            const expires = new Date();
            expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
            document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length, c.length);
            }
            return null;
        }

        function saveProgress() {
            const saveData = {
                playerName: gameState.playerName,
                playerLevel: gameState.playerLevel,
                playerXP: gameState.playerXP,
                playerMaxHealth: gameState.playerMaxHealth,
                playerMaxMana: gameState.playerMaxMana,
                playerDamage: gameState.playerDamage,
                playerSpeed: gameState.playerSpeed,
                currentPhase: gameState.currentPhase,
                currentCheckpoint: gameState.currentCheckpoint,
                bossDefeated: gameState.bossDefeated,
                // Salvar quaisquer outros estados relevantes aqui
            };
            
            setCookie('tupary_save', JSON.stringify(saveData));
            showCheckpointNotification('Progresso Salvo', 'Seu progresso foi salvo com sucesso!');
        }

        function loadProgress() {
            const saveData = getCookie('tupary_save');
            if (saveData) {
                try {
                    const data = JSON.parse(saveData);
                    return data;
                } catch (e) {
                    console.error('Erro ao carregar save:', e);
                }
            }
            return null;
        }

        // ===== INICIALIZA√á√ÉO =====
        async function init() { // Tornar ass√≠ncrona para carregamento de √°udio e imagem
            detectDevice();
            
            canvas = document.getElementById('game-canvas');
            ctx = canvas.getContext('2d');
            
            // Configurar canvas
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Carregar todos os sons e m√∫sicas
            for (const key in CONFIG.ASSET_PATHS) {
                if (CONFIG.ASSET_PATHS[key].endsWith('.mp3')) { // Supondo MP3 para √°udio
                    await loadSound(key, CONFIG.ASSET_PATHS[key]);
                } else { // Supondo imagens para o resto
                    ASSET_MANAGER.queueDownload(CONFIG.ASSET_PATHS[key]);
                }
            }
            console.log("Todos os assets de √°udio carregados.");
            
            // Carregar todas as imagens
            ASSET_MANAGER.downloadAll(() => {
                console.log("Todos os assets de imagem carregados.");
                // Inicializar sistemas AP√ìS o carregamento de todos os assets
                initChosenOne(); // Inicializa o personagem "Escolhido"
                initEventListeners();
                initMobileControls();
                
                // Carregar progresso salvo
                const savedData = loadProgress();
                if (savedData) {
                    populateStartScreenWithSavedData(savedData);
                } else {
                    playMusic('music_menu', true); // Toca a m√∫sica do menu ao iniciar
                }
                
                // Iniciar loop do jogo
                gameLoop(0);
            });
        }

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const rect = container.getBoundingClientRect();
            
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // Ajustar controles mobile
            if (isMobile) {
                updateMobileControlsVisibility();
            }
        }

        function populateStartScreenWithSavedData(data) {
            document.getElementById('player-name').value = data.playerName || '';
            // Se houver nome salvo, habilitar o bot√£o de iniciar
            validateStartInputs();

            // Restaurar estado do jogo a partir do save
            Object.assign(gameState, data); // Sobrescreve as propriedades de gameState
            
            // Carregar a fase salva
            if (gameState.gameStarted) {
                document.getElementById('start-screen').style.display = 'none';
                loadPhase(gameState.currentPhase);
                setupCharacter(gameState.playerLevel, gameState.playerMaxHealth, gameState.playerMaxMana, gameState.playerDamage, gameState.playerSpeed); // Aplica stats salvos
                updateAllUI();
                playMusic('music_platforming', true); // Toca a m√∫sica da fase salva
            }
        }

        // ===== PERSONAGEM "O ESCOLHIDO" =====
        function initChosenOne() {
            // Define o personagem √∫nico "O Escolhido"
            currentChampion = {
                id: 'chosenOne',
                name: 'O Escolhido',
                type: 'hybrid', // H√≠brido: combate corpo a corpo e √† dist√¢ncia
                baseHealth: 100,
                baseMana: 120,
                baseSpeed: 4,
                baseDamage: 15,
                abilities: [
                    {
                        key: 'U',
                        name: 'Ataque R√°pido',
                        description: 'Golpe √°gil de curta dist√¢ncia. Aumenta muito na F√∫ria de Umbra.',
                        damage: (base) => gameState.isUmbraFurious ? base * CONFIG.UMBRA_FURY_DAMAGE_BOOST : base * 1.0,
                        manaCost: 0,
                        cooldown: 0.5,
                        execute: function() {
                            playSound('sfx_attack_u');
                            addAbilityEffect({
                                type: 'meleeAttack',
                                x: gameState.playerPosition.x + (gameState.facing === 'right' ? CONFIG.PLAYER_WIDTH : -40), // Ajustado para player_width
                                y: gameState.playerPosition.y + 15,
                                width: 40,
                                height: 20,
                                duration: 200,
                                damage: this.damage(gameState.playerDamage),
                                origin: 'player',
                                umbraBoosted: gameState.isUmbraFurious
                            });
                            // Define anima√ß√£o de ataque, que voltar√° para idle/walk ap√≥s um tempo
                            gameState.currentAnimation = 'attack_u';
                            setTimeout(() => { gameState.currentAnimation = 'idle'; }, 200); // Exemplo de reset
                        }
                    },
                    {
                        key: 'I',
                        name: 'Proj√©til de Energia',
                        description: 'Lan√ßa um proj√©til r√°pido √† dist√¢ncia com baixo custo de mana.',
                        damage: (base) => base * 1.0,
                        manaCost: 15,
                        cooldown: 2,
                        execute: function() {
                            playSound('sfx_ability_i');
                            addAbilityEffect({
                                type: 'energyProjectile', // Novo tipo de efeito
                                x: gameState.playerPosition.x + (gameState.facing === 'right' ? CONFIG.PLAYER_WIDTH : -25),
                                y: gameState.playerPosition.y + 20,
                                width: 25,
                                height: 8,
                                duration: 1500,
                                damage: this.damage(gameState.playerDamage),
                                direction: gameState.facing === 'right' ? 1 : -1,
                                speed: 7,
                                origin: 'player',
                                piercing: false
                            });
                            gameState.currentAnimation = 'attack_i';
                            setTimeout(() => { gameState.currentAnimation = 'idle'; }, 300); // Exemplo de reset
                        }
                    },
                    {
                        key: 'O',
                        name: 'Explos√£o Arcana',
                        description: 'Causa uma explos√£o de energia que danifica m√∫ltiplos inimigos √† frente.',
                        damage: (base) => base * 1.8,
                        manaCost: 30,
                        cooldown: 4,
                        execute: function() {
                            playSound('sfx_ability_o');
                            addAbilityEffect({
                                type: 'arcaneExplosion', // Novo tipo de efeito
                                x: gameState.playerPosition.x + (gameState.facing === 'right' ? CONFIG.PLAYER_WIDTH / 2 : -CONFIG.PLAYER_WIDTH / 2),
                                y: gameState.playerPosition.y,
                                width: 80,
                                height: 80,
                                duration: 300,
                                damage: this.damage(gameState.playerDamage),
                                origin: 'player',
                                areaEffect: true // Indica que √© um efeito de √°rea
                            });
                            screenShake(5, 200);
                            gameState.currentAnimation = 'attack_o';
                            setTimeout(() => { gameState.currentAnimation = 'idle'; }, 400); // Exemplo de reset
                        }
                    },
                    {
                        key: 'P',
                        name: 'F√∫ria de Umbra',
                        description: 'Canaliza a energia de Umbra para ficar mais r√°pido, resistente e poderoso no ataque por tempo limitado.',
                        damage: (base) => base, // N√£o causa dano direto, mas modifica outros ataques
                        manaCost: 50,
                        cooldown: 20, // Cooldown longo para ultimate
                        execute: function() {
                            playSound('sfx_ability_p');
                            gameState.isUmbraFurious = true;
                            gameState.umbraFuryTimer = CONFIG.UMBRA_FURY_DURATION;
                            gameState.currentAnimation = 'umbra_fury';
                            // Buffs ser√£o aplicados em updatePlayer
                        }
                    }
                ]
            };
        }

        // ===== EVENT LISTENERS =====
        function initEventListeners() {
            // Start Screen
            document.getElementById('player-name').addEventListener('input', validateStartInputs);
            document.getElementById('start-game-btn').addEventListener('click', startNewGame);
            
            // Controles de teclado
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            // Bot√µes da UI
            document.getElementById('pause-btn').addEventListener('click', togglePause);
            document.getElementById('resume-btn').addEventListener('click', togglePause);
            document.getElementById('restart-btn').addEventListener('click', restartFromCheckpoint);
            document.getElementById('save-btn').addEventListener('click', saveProgress);
            document.getElementById('exit-btn').addEventListener('click', exitToMenu);
            document.getElementById('skip-btn').addEventListener('click', skipCutscene);
            
            // Habilidades desktop
            document.querySelectorAll('.ability-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const key = e.currentTarget.dataset.key;
                    if (key) useAbility(key);
                });
            });
            
            // Level up (autom√°tico)
            document.getElementById('continue-level-up-btn').addEventListener('click', () => {
                document.getElementById('level-up').style.display = 'none';
                gameState.gamePaused = false;
            });
        }

        function handleKeyDown(e) {
            // Prevenir scroll da p√°gina para as setas e espa√ßo
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' '].includes(e.key)) {
                e.preventDefault();
            }
            keys[e.key.toLowerCase()] = true; // Define a tecla pressionada

            // Pausar com ESC
            if (e.key === 'Escape' && gameState.gameStarted && !gameState.inStartScreen && !gameState.inCutscene) {
                togglePause();
            }
            
            // Pular cutscene (agora avan√ßa um passo, n√£o tudo)
            if ((e.key === ' ' || e.key === 'Enter') && gameState.inCutscene) {
                if (gameState.currentPhase === 1) { // Intro cinematica
                    showIntroCutscene(); // Rechamada para avan√ßar o passo
                } else if (gameState.currentPhase === 3) { // Intro Tarek
                    showTarekIntroCutscene(); // Rechamada para avan√ßar o passo
                }
            }
            
            // Habilidades (apenas se o jogo estiver ativo e n√£o em estados de UI)
            if (['u', 'i', 'o', 'p'].includes(e.key.toLowerCase()) && 
                !gameState.gamePaused && !gameState.inDialog && !gameState.inCutscene && !gameState.inStartScreen) {
                useAbility(e.key.toUpperCase());
            }
        }

        function handleKeyUp(e) {
            keys[e.key.toLowerCase()] = false; // Desdefine a tecla solta
        }

        // ===== CONTROLES MOBILE =====
        function initMobileControls() {
            // D-pad
            document.getElementById('mobile-up').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.up = true; });
            document.getElementById('mobile-up').addEventListener('touchend', () => mobileControls.up = false);
            document.getElementById('mobile-down').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.down = true; });
            document.getElementById('mobile-down').addEventListener('touchend', () => mobileControls.down = false);
            document.getElementById('mobile-left').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.left = true; });
            document.getElementById('mobile-left').addEventListener('touchend', () => mobileControls.left = false);
            document.getElementById('mobile-right').addEventListener('touchstart', (e) => { e.preventDefault(); mobileControls.right = true; });
            document.getElementById('mobile-right').addEventListener('touchend', () => mobileControls.right = false);

            // Bot√µes de A√ß√£o
            document.getElementById('mobile-ability-u').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('U'); });
            document.getElementById('mobile-ability-i').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('I'); });
            document.getElementById('mobile-ability-o').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('O'); });
            document.getElementById('mobile-ability-p').addEventListener('touchstart', (e) => { e.preventDefault(); useAbility('P'); });

            updateMobileControlsVisibility();
        }

        function updateMobileControlsVisibility() {
            const mobileControlsDiv = document.getElementById('mobile-controls');
            if (isMobile && isLandscape) {
                mobileControlsDiv.style.display = 'grid';
            } else {
                mobileControlsDiv.style.display = 'none';
            }
        }

        // ===== TELA DE IN√çCIO / NOME =====
        function validateStartInputs() {
            const name = document.getElementById('player-name').value.trim();
            const startBtn = document.getElementById('start-game-btn');
            
            if (name.length >= 2) {
                startBtn.disabled = false;
            } else {
                startBtn.disabled = true;
            }
        }

        function startNewGame() {
            const name = document.getElementById('player-name').value.trim();
            if (name.length < 2) return;
            
            gameState.playerName = name;
            gameState.inStartScreen = false;
            gameState.gameStarted = true;
            
            // Esconder tela de in√≠cio
            document.getElementById('start-screen').style.display = 'none';
            
            // Configurar personagem com os stats base do Escolhido
            setupCharacter(currentChampion.baseHealth, currentChampion.baseMana, currentChampion.baseDamage, currentChampion.baseSpeed);
            
            // Mostrar controles mobile se necess√°rio
            if (isMobile) {
                updateMobileControlsVisibility();
            }
            
            stopMusic(); // Para a m√∫sica do menu
            showIntroCutscene(); // Inicia a cinem√°tica de introdu√ß√£o
        }

        function setupCharacter(health, mana, damage, speed) {
            gameState.playerMaxHealth = health;
            gameState.playerHealth = gameState.playerMaxHealth;
            gameState.playerMaxMana = mana;
            gameState.playerMana = gameState.playerMaxMana;
            gameState.playerSpeed = speed;
            gameState.playerDamage = damage;
            
            // Atualizar tooltips das habilidades
            updateAbilityTooltips();
            
            // Atualizar UI
            updateAllUI();
        }

        function updateAbilityTooltips() {
            if (!currentChampion) return;
            
            currentChampion.abilities.forEach(ability => {
                const key = ability.key.toLowerCase();
                const nameEl = document.getElementById(`tooltip-${key}-name`);
                const descEl = document.getElementById(`tooltip-${key}-desc`);
                const costEl = document.getElementById(`tooltip-${key}-cost`);
                
                if (nameEl) nameEl.textContent = ability.name;
                if (descEl) descEl.textContent = ability.description;
                if (costEl) costEl.textContent = `Custo: ${ability.manaCost} Mana`;
            });
        }

        function exitToMenu() {
            // Salvar progresso antes de sair
            saveProgress();
            
            // Reset do estado do jogo para o menu inicial (mant√©m o playerName salvo)
            gameState = {
                ...gameState, // Copia o estado atual para manter o playerName
                playerClass: 'Escolhido',
                playerHealth: 100, playerMaxHealth: 100,
                playerMana: 100, playerMaxMana: 100,
                playerPosition: { x: 100, y: 300 },
                playerVelocity: { x: 0, y: 0 },
                playerLevel: 1, playerXP: 0, playerNextLevelXP: 100,
                playerDamage: 15, playerSpeed: CONFIG.PLAYER_SPEED,
                isGrounded: false, isCrouching: false, isInvincible: false, facing: 'right', currentAnimation: 'idle',
                isUmbraFurious: false, umbraFuryTimer: 0,
                abilitiesCooldown: { U: 0, I: 0, O: 0, P: 0 },
                abilitiesMaxCooldown: { U: 0.5, I: 2, O: 4, P: 20 },
                gamePaused: false, inDialog: false, inCutscene: false,
                inStartScreen: true, // Volta para a tela inicial
                gameStarted: false,
                cameraOffset: { x: 0, y: 0 }, targetCameraOffset: { x: 0, y: 0 },
                currentPhase: 0, currentCheckpoint: 'start',
                inBossFight: false, bossDefeated: false,
                inTarekEncounter: false, tarekDialogStep: 0, tarekDialogCompleted: false,
                fixedCamera: false, fixedCameraTarget: { x: 0, y: 0 }
            };

            // Reset de entidades
            platforms = []; enemies = []; abilityEffects = []; particles = []; damageNumbers = []; checkpoints = []; fallingSpikes = [];
            
            // Mostrar tela de in√≠cio
            document.getElementById('start-screen').style.display = 'flex';
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('mobile-controls').style.display = 'none';
            document.getElementById('abilities-container').style.display = 'flex'; // Volta a exibir em desktop
            document.getElementById('player-name').value = ''; // Limpa o nome na tela inicial
            document.getElementById('start-game-btn').disabled = true; // Desabilita o bot√£o

            // Reset UI
            updateAllUI();
            
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            stopMusic();
            playMusic('music_menu', true); // Toca a m√∫sica do menu
        }

        // ===== SISTEMA DE FASES E NARRATIVA =====
        function loadPhase(phaseNumber) {
            gameState.currentPhase = phaseNumber;
            
            // Reset posi√ß√£o do jogador
            gameState.playerPosition = { x: 100, y: 300 };
            gameState.playerVelocity = { x: 0, y: 0 };
            gameState.isGrounded = false;
            gameState.isCrouching = false;
            
            // Limpar arrays
            enemies = [];
            abilityEffects = [];
            particles = [];
            damageNumbers = [];
            fallingSpikes = []; // Limpa espinhos que caem
            
            // Configurar fase espec√≠fica
            switch(phaseNumber) {
                case 1: // Intro Cinematic
                    showIntroCutscene();
                    break;
                case 2: // Plataform (Pre-Tarek)
                    setupPhase2_Platforming();
                    stopMusic();
                    playMusic('music_platforming', true);
                    break;
                case 3: // Encontro com Tarek (C√¢mera Fixa, Di√°logo)
                    setupPhase3_TarekEncounter();
                    break;
                case 4: // Batalha contra Tarek
                    setupPhase4_TarekBossFight();
                    break;
                // Adicione outras fases aqui
                default:
                    setupPhase2_Platforming(); // Fallback para fase de plataforma
            }
            
            // Reset c√¢mera (ser√° ajustado por fixedCamera se necess√°rio)
            gameState.cameraOffset = { x: 0, y: 0 };
            gameState.targetCameraOffset = { x: 0, y: 0 };
        }

        function setupPhase2_Platforming() {
            // Muralhas da Aurora - Parte inicial de plataforma
            // Aqui o jogador atravessa o ambiente at√© chegar aos port√µes de Tup√£ry
            platforms = [
                { x: 0, y: 400, width: 600, height: 50, type: 'ground' }, // Ch√£o principal
                { x: 200, y: 350, width: 80, height: 20, type: 'platform' },
                { x: 350, y: 300, width: 80, height: 20, type: 'platform', slippery: true }, // Plataforma escorregadia
                { x: 500, y: 250, width: 100, height: 20, type: 'platform' },
                { x: 700, y: 320, width: 120, height: 20, type: 'platform' },
                { x: 900, y: 380, width: 50, height: 20, type: 'platform' },
                
                // Exemplo de Plataforma com Espinhos fixos
                { x: 1100, y: 400, width: 150, height: 50, type: 'ground' }, 
                { x: 1100, y: 350, width: 150, height: 50, type: 'spike' }, 
                
                // Se√ß√£o com Sentinelas e mais plataformas
                { x: 1300, y: 400, width: 400, height: 50, type: 'ground' },
                { x: 1400, y: 300, width: 100, height: 20, type: 'platform' },
                { x: 1550, y: 250, width: 120, height: 20, type: 'platform' },

                // Plataformas com espinhos que caem (definir √°reas de spawn)
                { x: 1800, y: 400, width: 500, height: 50, type: 'ground' },
                { x: 1900, y: 300, width: 100, height: 20, type: 'platform', fallingSpikeZone: true }, // Zona de espinhos caindo
                { x: 2100, y: 250, width: 150, height: 20, type: 'platform', fallingSpikeZone: true },
                { x: 2300, y: 350, width: 100, height: 20, type: 'platform' },
                { x: 2500, y: 400, width: 500, height: 50, type: 'ground' },
            ];
            
            // Adicionar Sentinelas (inimigos mais fracos)
            enemies.push({
                type: 'sentinel',
                name: 'Sentinela de Gelo',
                position: { x: 1450, y: 300 },
                facing: 'left',
                health: 50,
                maxHealth: 50,
                damage: 10, // Dano de colis√£o da sentinela
                speed: 1,
                velocity: { x: 0, y: 0 },
                isGrounded: false,
                xpValue: 20,
                pattern: 'patrol', // Exemplo de IA simples
                patrolRange: 100,
                attackCooldown: 0,
                attackRange: 150,
                lastAttackTime: 0
            });
            enemies.push({
                type: 'sentinel',
                name: 'Sentinela de Gelo',
                position: { x: 2000, y: 300 },
                facing: 'left',
                health: 50,
                maxHealth: 50,
                damage: 10,
                speed: 1,
                velocity: { x: 0, y: 0 },
                isGrounded: false,
                xpValue: 20,
                pattern: 'patrol',
                patrolRange: 100,
                attackCooldown: 0,
                attackRange: 150,
                lastAttackTime: 0
            });
            
            checkpoints = []; // N√£o h√° checkpoints antes do encontro com Tarek
            
            backgroundLayers = [
                { path: CONFIG.ASSET_PATHS.bg_sky, speed: 0.1, type: 'sky' },
                { path: CONFIG.ASSET_PATHS.bg_mountains, speed: 0.3, type: 'mountains' },
                { path: CONFIG.ASSET_PATHS.bg_hills, speed: 0.5, type: 'hills' },
                { path: CONFIG.ASSET_PATHS.bg_foreground, speed: 0.7, type: 'foreground' }
            ];

            // Posi√ß√£o para o jogador chegar e iniciar o encontro com Tarek
            // CONFIG.WORLD_WIDTH √© o limite total do mundo, mas para o encontro, definimos um limite local
            CONFIG.WORLD_WIDTH_CURRENT_PHASE = 2800; // Ajuste o tamanho do mundo para esta parte
            
            // Reset do estado de encontro com Tarek
            gameState.inTarekEncounter = false;
            gameState.tarekDialogStep = 0;
            gameState.tarekDialogCompleted = false;
            gameState.fixedCamera = false;
        }

        function setupPhase3_TarekEncounter() {
            // Fase de encontro com Tarek: c√¢mera fixa e di√°logo
            platforms = [
                { x: 0, y: 400, width: canvas.width, height: 50, type: 'ground' } // Ch√£o simples para o encontro
            ];
            enemies = []; // Sem inimigos at√© a luta
            checkpoints = []; // Sem checkpoints durante di√°logo
            fallingSpikes = []; // Garante que n√£o h√° espinhos caindo

            backgroundLayers = [
                { path: CONFIG.ASSET_PATHS.bg_sky, speed: 0.1, type: 'sky' },
                { path: CONFIG.ASSET_PATHS.bg_mountains, speed: 0.3, type: 'mountains' }
            ];

            gameState.fixedCamera = true;
            gameState.fixedCameraTarget = { x: 0, y: 0 }; // C√¢mera fixa na posi√ß√£o inicial do canvas
            gameState.playerPosition = { x: 150, y: 300 }; // Posi√ß√£o inicial do jogador
            gameState.playerVelocity = { x: 0, y: 0 };

            const tarek = {
                type: 'boss_dialogue', // Tipo espec√≠fico para Tarek em di√°logo
                name: 'Tarek, o Guerreiro',
                position: { x: canvas.width - 200, y: 300 }, // Posi√ß√£o de Tarek na cena fixa
                facing: 'left', // Tarek olhando para o jogador
                health: 1, maxHealth: 1, // N√£o √© um inimigo real ainda
                damage: 0 // N√£o causa dano
            };
            enemies.push(tarek);
            
            gameState.inTarekEncounter = true;
            // Inicia a cutscene de introdu√ß√£o do Tarek
            showTarekIntroCutscene();
        }

        function setupPhase4_TarekBossFight() {
            // Fase de batalha contra Tarek
            platforms = [
                { x: 0, y: 400, width: canvas.width, height: 50, type: 'ground' } // Arena simples
            ];
            enemies = []; // Limpa inimigos antes de adicionar Tarek como boss
            checkpoints = [];
            fallingSpikes = []; // Garante que n√£o h√° espinhos caindo
            
            backgroundLayers = [
                { path: CONFIG.ASSET_PATHS.bg_sky, speed: 0.1, type: 'sky' },
                { path: CONFIG.ASSET_PATHS.bg_mountains, speed: 0.3, type: 'mountains' }
            ];

            gameState.fixedCamera = true;
            gameState.fixedCameraTarget = { x: 0, y: 0 }; // C√¢mera fixa na arena
            gameState.playerPosition = { x: 150, y: 300 }; // Posi√ß√£o inicial do jogador
            
            // Reiniciar vida e mana do jogador para o m√°ximo antes da batalha do boss
            gameState.playerHealth = gameState.playerMaxHealth;
            gameState.playerMana = gameState.playerMaxMana;
            updateAllUI(); // Atualiza a UI para refletir a vida/mana cheia

            // Adicionar Tarek como oponente da luta
            triggerBossFight(); // Fun√ß√£o que cria e adiciona Tarek aos inimigos
            stopMusic();
            playMusic('music_boss_tarek', true);
        }


        // ===== CUTSCENES E NARRATIVA =====
        let cinematicSequence = null; // Armazena a sequ√™ncia atual de cutscenes
        let currentCinematicStep = 0; // Passo atual da cutscene

        function showCinematic(sequences, nextPhaseAction) {
            gameState.inCutscene = true;
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            
            overlay.classList.add('active'); // Ativa o fade-in

            cinematicSequence = sequences;
            
            function showNextStep() {
                if (currentCinematicStep < cinematicSequence.length) {
                    const step = cinematicSequence[currentCinematicStep];
                    
                    titleElement.textContent = step.title;
                    textElement.textContent = step.text;
                    
                    // Reset animations (para que o fade-in ocorra para cada texto)
                    titleElement.style.animation = 'none';
                    textElement.style.animation = 'none';
                    void titleElement.offsetWidth; // Trigger reflow
                    void textElement.offsetWidth;
                    
                    titleElement.style.animation = 'fadeInText 2s forwards';
                    textElement.style.animation = 'fadeInText 3s forwards 0.5s';
                    
                    currentCinematicStep++;
                    // Define um timer para o pr√≥ximo passo ou para finalizar a cutscene
                    cinematicTimer = setTimeout(showNextStep, 5000); // Exibe cada trecho por 5 segundos
                } else {
                    // Ap√≥s a √∫ltima cutscene, transiciona para o pr√≥ximo estado/fase
                    overlay.classList.remove('active'); // Ativa o fade-out
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        gameState.inCutscene = false;
                        cinematicSequence = null;
                        currentCinematicStep = 0;
                        nextPhaseAction(); // Chama a a√ß√£o final, como carregar uma fase
                    }, 500); // Espera o fade-out
                }
            }
            
            showNextStep(); // Inicia a primeira etapa
        }

        function showIntroCutscene() {
            // Define as cutscenes de introdu√ß√£o
            const introSequences = [
                {
                    title: "O DESEQUIL√çBRIO",
                    text: "O mundo treme sob o peso do desequil√≠brio. Ignys, o Reino do Fogo, deseja guerra e j√° move suas tropas em dire√ß√£o aos reinos vizinhos."
                },
                {
                    title: "O CORA√á√ÉO DE GELO",
                    text: "Em Tup√£ry, o Cora√ß√£o de Gelo guarda a metade maligna de Anhang√°, o esp√≠rito que traz caos."
                },
                {
                    title: "A CONVOCA√á√ÉO",
                    text: `Umbra convoca voc√™, ${gameState.playerName}, o Escolhido: recuperar o Cora√ß√£o de Gelo e impedir que Ignys obtenha poder suficiente para dominar todos os reinos.`
                },
                {
                    title: "O DESTINO",
                    text: "Cada passo, cada luta, cada escolha ser√° decisiva para a sobreviv√™ncia de todos."
                }
            ];

            // A√ß√£o a ser executada ap√≥s a √∫ltima cutscene (iniciar fase de plataforma)
            const nextAction = () => {
                loadPhase(2); // Transiciona para a fase de plataforma (agora fase 2)
            };
            
            // Se j√° estamos em uma cutscene, apenas avan√ßa para o pr√≥ximo passo
            if (gameState.inCutscene && cinematicSequence === introSequences) {
                clearTimeout(cinematicTimer); // Limpa o timer anterior
                showCinematic(introSequences, nextAction); // Chama para avan√ßar o passo
            } else {
                // Inicia a cutscene do zero
                currentCinematicStep = 0;
                showCinematic(introSequences, nextAction);
            }
            document.getElementById('cinematic-overlay').style.display = 'flex'; // Garante que o overlay esteja vis√≠vel
        }

        function showTarekIntroCutscene() {
            // Define as cutscenes de introdu√ß√£o de Tarek
            const tarekIntroSequences = [
                {
                    title: "ENCONTRO COM TAREK",
                    text: "Tarek, o Guerreiro. Guardi√£o das Muralhas da Aurora. Ningu√©m passa por ele sem provar seu valor."
                },
                {
                    title: "UM GUARDI√ÉO IMPLAC√ÅVEL",
                    text: `Ele te aguarda, ${gameState.playerName}, com uma determina√ß√£o inabal√°vel. Sua honra est√° em jogo.`
                }
            ];

            // A√ß√£o a ser executada ap√≥s a √∫ltima cutscene (iniciar di√°logo com Tarek)
            const nextAction = () => {
                startTarekDialogue();
            };
            
            // Se j√° estamos em uma cutscene, apenas avan√ßa para o pr√≥ximo passo
            if (gameState.inCutscene && cinematicSequence === tarekIntroSequences) {
                clearTimeout(cinematicTimer); // Limpa o timer anterior
                showCinematic(tarekIntroSequences, nextAction); // Chama para avan√ßar o passo
            } else {
                // Inicia a cutscene do zero
                currentCinematicStep = 0;
                showCinematic(tarekIntroSequences, nextAction);
            }
            document.getElementById('cinematic-overlay').style.display = 'flex'; // Garante que o overlay esteja vis√≠vel
        }

        function skipCutscene() {
            const overlay = document.getElementById('cinematic-overlay');
            overlay.classList.remove('active'); // Inicia o fade-out
            
            clearTimeout(cinematicTimer); // Limpa o timer atual para interromper a sequ√™ncia
            
            // For√ßa a finaliza√ß√£o da cutscene atual
            if (cinematicSequence) {
                currentCinematicStep = cinematicSequence.length; // Avan√ßa para o final
                // Chama a pr√≥xima etapa para finalizar a cutscene
                if (cinematicSequence === introSequences) {
                    showIntroCutscene(); // Chama para finalizar a intro principal
                } else if (cinematicSequence === tarekIntroSequences) {
                    showTarekIntroCutscene(); // Chama para finalizar a intro do Tarek
                }
            } else {
                // Se n√£o h√° uma sequ√™ncia ativa, apenas esconde o overlay
                setTimeout(() => {
                    overlay.style.display = 'none';
                    gameState.inCutscene = false;
                    cinematicSequence = null;
                    currentCinematicStep = 0;
                }, 500); // Espera o fade-out
            }
        }

        function showDialog(speaker, text, options = null) {
            gameState.inDialog = true;
            gameState.gamePaused = true; // Pausa o jogo durante o di√°logo
            const dialogContainer = document.getElementById('dialog-container');
            const speakerElement = document.getElementById('dialog-speaker');
            const textElement = document.getElementById('dialog-text');
            const optionsElement = document.getElementById('dialog-options');
            
            dialogContainer.style.display = 'block';
            speakerElement.textContent = speaker;
            textElement.textContent = text;
            
            // Limpar op√ß√µes anteriores
            optionsElement.innerHTML = '';
            
            if (options && options.length > 0) {
                options.forEach((option, index) => {
                    const button = document.createElement('div');
                    button.className = 'dialog-option';
                    button.textContent = option.text;
                    button.addEventListener('click', () => {
                        dialogContainer.style.display = 'none';
                        gameState.inDialog = false;
                        gameState.gamePaused = false; // Despausa o jogo ao fechar di√°logo
                        if (option.action) option.action();
                    });
                    optionsElement.appendChild(button);
                });
            } else {
                const button = document.createElement('div');
                button.className = 'dialog-option';
                button.textContent = 'Continuar';
                button.addEventListener('click', () => {
                    dialogContainer.style.display = 'none';
                    gameState.inDialog = false;
                    gameState.gamePaused = false; // Despausa o jogo ao fechar di√°logo
                });
                optionsElement.appendChild(button);
            }
        }

        function startTarekDialogue() {
            gameState.tarekDialogStep = 0;
            const tarekDialogs = [
                { speaker: "TAREK, O GUERREIRO", text: `Ent√£o voc√™ √© ${gameState.playerName}, o tal Escolhido?` },
                { speaker: "TAREK, O GUERREIRO", text: "Estas muralhas n√£o s√£o lugar para forasteiros fracos." },
                { speaker: "TAREK, O GUERREIRO", text: "Prove que merece passar por aqui, ou volte de onde veio!" }
            ];

            function showTarekLine() {
                if (gameState.tarekDialogStep < tarekDialogs.length) {
                    const line = tarekDialogs[gameState.tarekDialogStep];
                    showDialog(line.speaker, line.text, [{ text: "Continuar", action: () => {
                        gameState.tarekDialogStep++;
                        showTarekLine();
                    }}]);
                } else {
                    // Di√°logo completo, inicia a batalha
                    gameState.tarekDialogCompleted = true;
                    gameState.inTarekEncounter = false;
                    loadPhase(4); // Transiciona para a fase de batalha contra Tarek (agora fase 4)
                }
            }
            showTarekLine();
        }

        // ===== SISTEMA DE CHECKPOINTS =====
        function saveCheckpoint(checkpointName) {
            gameState.currentCheckpoint = checkpointName;
            
            const checkpointData = {
                name: checkpointName,
                phase: gameState.currentPhase,
                position: { ...gameState.playerPosition },
                health: gameState.playerHealth,
                mana: gameState.playerMana,
                xp: gameState.playerXP,
                level: gameState.playerLevel
            };
            
            setCookie('tupary_checkpoint', JSON.stringify(checkpointData));
            showCheckpointNotification('Checkpoint Salvo', `Progresso salvo em: ${getCheckpointDescription(checkpointName)}`);
        }

        function loadCheckpoint() {
            const checkpointData = getCookie('tupary_checkpoint');
            if (checkpointData) {
                try {
                    const data = JSON.parse(checkpointData);
                    
                    gameState.currentPhase = data.phase;
                    gameState.currentCheckpoint = data.name;
                    gameState.playerPosition = { ...data.position };
                    gameState.playerHealth = data.health;
                    gameState.playerMana = data.mana;
                    gameState.playerXP = data.xp;
                    gameState.playerLevel = data.level;
                    
                    loadPhase(data.phase);
                    setupCharacter(gameState.playerMaxHealth, gameState.playerMaxMana, gameState.playerDamage, gameState.playerSpeed); // Atualiza stats
                    updateAllUI(); // Atualiza UI com stats carregados
                    return true;
                } catch (e) {
                    console.error('Erro ao carregar checkpoint:', e);
                }
            }
            return false;
        }

        function getCheckpointDescription(checkpointName) {
            const checkpoint = checkpoints.find(cp => cp.name === checkpointName);
            return checkpoint ? checkpoint.description : 'Localiza√ß√£o Desconhecida';
        }

        function showCheckpointNotification(title, description) {
            const notification = document.getElementById('checkpoint-notification');
            const titleEl = notification.querySelector('.checkpoint-text');
            const descEl = notification.querySelector('.checkpoint-description');
            
            titleEl.textContent = title;
            descEl.textContent = description;
            
            notification.style.display = 'block';
            notification.style.animation = 'checkpointPulse 2s ease-in-out';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }

        function restartFromCheckpoint() {
            togglePause();
            
            if (loadCheckpoint()) {
                showCheckpointNotification('Checkpoint Carregado', 'Retornando ao √∫ltimo checkpoint salvo...');
            } else {
                loadPhase(gameState.currentPhase); // Se n√£o h√° checkpoint, reiniciar fase atual
                gameState.playerHealth = gameState.playerMaxHealth; // Garante vida cheia
                gameState.playerMana = gameState.playerMaxMana; // Garante mana cheia
                updateAllUI();
            }
        }

        // ===== LOOP PRINCIPAL DO JOGO =====
        function gameLoop(timestamp) {
            // Calcular delta time
            let deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            // Limitar delta time para evitar grandes saltos
            deltaTime = Math.min(deltaTime, CONFIG.DELTA_TIME_CAP);
            
            if (!gameState.gamePaused && gameState.gameStarted) { // Apenas atualiza e renderiza se o jogo estiver rodando e n√£o pausado
                // Atualizar l√≥gica do jogo apenas se n√£o estiver em cutscene/di√°logo
                if (!gameState.inCutscene && !gameState.inDialog) {
                    update(deltaTime);
                }
                render(); // Sempre renderiza, mesmo em di√°logo/cutscene para exibir a UI
            } else if (gameState.inStartScreen) { // Renderiza apenas a tela inicial
                // N√£o h√° update de l√≥gica, apenas renderiza√ß√£o est√°tica
                render(); // Renderiza o canvas para exibir fundo, mesmo que est√°tico
            } else if (gameState.inCutscene || gameState.inDialog || gameState.gamePaused) {
                render(); // Continua renderizando a UI ou cutscene parada
            }
            
            // Continuar o loop
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function update(deltaTime) {
            // Atualizar jogador
            updatePlayer(deltaTime);
            
            // Atualizar inimigos
            updateEnemies(deltaTime);
            
            // Atualizar efeitos de habilidades
            updateAbilityEffects(deltaTime);
            
            // Atualizar part√≠culas
            updateParticles(deltaTime);

            // Atualizar espinhos que caem
            updateFallingSpikes(deltaTime);
            
            // Atualizar n√∫meros de dano
            updateDamageNumbers(deltaTime);
            
            // Atualizar cooldowns
            updateCooldowns(deltaTime);
            
            // Regenera√ß√£o
            updateRegeneration(deltaTime);
            
            // Atualizar c√¢mera
            updateCamera(deltaTime);
            
            // Verificar checkpoints (apenas em fases de plataforma)
            if (gameState.currentPhase === 2 || gameState.currentPhase === 5) { // Ex: 2: Plataforma pr√©-Tarek, 5: Futuras fases de plataforma
                checkCheckpoints();
            }
            
            // Verificar condi√ß√µes de vit√≥ria/derrota
            checkGameConditions();
        }

        // Fun√ß√£o auxiliar para limitar um valor entre um m√≠nimo e um m√°ximo
        function clamp(value, min, max) {
            return Math.max(min, Math.min(value, max));
        }

        function updatePlayer(deltaTime) {
            // Movimento horizontal (Teclado e Mobile)
            let moveX = 0;
            if (keys['a'] || keys['arrowleft'] || mobileControls.left) moveX = -1;
            if (keys['d'] || keys['arrowright'] || mobileControls.right) moveX = 1;
            
            // Aplicar buffs da F√∫ria de Umbra
            let currentSpeed = gameState.playerSpeed;
            if (gameState.isUmbraFurious) {
                currentSpeed *= CONFIG.UMBRA_FURY_SPEED_BOOST;
                gameState.umbraFuryTimer -= deltaTime;
                if (gameState.umbraFuryTimer <= 0) {
                    gameState.isUmbraFurious = false;
                    gameState.currentAnimation = 'idle'; // Volta para anima√ß√£o normal
                }
            }

            // Aplicar velocidade
            gameState.playerVelocity.x = moveX * currentSpeed;
            
            // Pular (Teclado e Mobile)
            if ((keys['w'] || keys['arrowup'] || keys[' '] || mobileControls.up) && gameState.isGrounded && !gameState.isCrouching) {
                gameState.playerVelocity.y = -CONFIG.JUMP_FORCE;
                gameState.isGrounded = false;
                playSound('sfx_jump');
                // Part√≠culas de pulo
                addParticles('jumpDust', gameState.playerPosition.x + CONFIG.PLAYER_WIDTH / 2, gameState.playerPosition.y + CONFIG.NORMAL_HEIGHT, 8);
                
                // Reset da tecla/controle para evitar pulos m√∫ltiplos
                keys['w'] = false; keys['arrowup'] = false; keys[' '] = false; mobileControls.up = false;
            }
            
            // Crouch (abaixar) (Teclado e Mobile)
            if (keys['s'] || keys['arrowdown'] || mobileControls.down) {
                if (!gameState.isCrouching && gameState.isGrounded) {
                    gameState.isCrouching = true;
                    // Ajusta a posi√ß√£o Y para que o ch√£o seja mantido (o player "encolhe" para baixo)
                    gameState.playerPosition.y += CONFIG.NORMAL_HEIGHT - CONFIG.CROUCH_HEIGHT;
                }
            } else {
                if (gameState.isCrouching) {
                    // Verificar se h√° espa√ßo para ficar em p√©
                    const newY = gameState.playerPosition.y - (CONFIG.NORMAL_HEIGHT - CONFIG.CROUCH_HEIGHT);
                    if (canStandUp(gameState.playerPosition.x, newY)) {
                        gameState.isCrouching = false;
                        gameState.playerPosition.y = newY;
                    }
                }
            }
            
            // Aplicar gravidade
            gameState.playerVelocity.y += CONFIG.GRAVITY;
            
            // Limitar velocidade vertical
            if (gameState.playerVelocity.y > 15) {
                gameState.playerVelocity.y = 15;
            }
            
            // Atualizar posi√ß√£o
            gameState.playerPosition.x += gameState.playerVelocity.x;
            gameState.playerPosition.y += gameState.playerVelocity.y;
            
            // Verificar colis√µes
            checkPlatformCollisions();
            checkEnemyCollisions();
            checkEffectCollisions();
            checkFallingSpikeCollisions(); // Nova checagem de colis√£o
            
            // Atualizar anima√ß√£o (apenas se n√£o estiver em estado de ataque ou ultimate)
            if (!gameState.currentAnimation.startsWith('attack_') && gameState.currentAnimation !== 'umbra_fury') {
                updatePlayerAnimation();
            }
            
            // Atualizar dire√ß√£o
            if (moveX > 0) gameState.facing = 'right';
            if (moveX < 0) gameState.facing = 'left';
            
            // Limitar jogador dentro do mundo (Ajustado para fases fixas)
            if (!gameState.fixedCamera) { // Apenas se a c√¢mera n√£o estiver fixa
                gameState.playerPosition.x = clamp(gameState.playerPosition.x, 0, CONFIG.WORLD_WIDTH_CURRENT_PHASE - CONFIG.PLAYER_WIDTH);
                // Para n√£o permitir que o jogador caia para sempre (pode ser ajustado para um buraco sem fim)
                gameState.playerPosition.y = clamp(gameState.playerPosition.y, -100, CONFIG.WORLD_HEIGHT + 100); 
            } else { // Se a c√¢mera estiver fixa, limita o jogador √† tela atual
                gameState.playerPosition.x = clamp(gameState.playerPosition.x, 0, canvas.width - CONFIG.PLAYER_WIDTH);
                gameState.playerPosition.y = clamp(gameState.playerPosition.y, 0, canvas.height - CONFIG.NORMAL_HEIGHT);
            }


            // Verificar queda fora do mundo (morte instant√¢nea)
            if (gameState.playerPosition.y > CONFIG.WORLD_HEIGHT + 100) {
                takeDamage(gameState.playerMaxHealth); // Morte instant√¢nea por queda
            }
            
            // Reduzir invencibilidade
            if (gameState.isInvincible) {
                gameState.invincibilityTimer -= deltaTime;
                if (gameState.invincibilityTimer <= 0) {
                    gameState.isInvincible = false;
                }
            }
        }

        function canStandUp(x, y) {
            const playerWidth = CONFIG.PLAYER_WIDTH;
            const playerHeight = CONFIG.NORMAL_HEIGHT;
            
            for (const platform of platforms) {
                if (x < platform.x + platform.width &&
                    x + playerWidth > platform.x &&
                    y < platform.y + platform.height &&
                    y + playerHeight > platform.y) {
                    return false;
                }
            }
            return true;
        }

        function checkPlatformCollisions() {
            gameState.isGrounded = false;
            const playerWidth = CONFIG.PLAYER_WIDTH;
            const playerHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
            
            for (const platform of platforms) {
                // Verificar colis√£o AABB
                if (gameState.playerPosition.x < platform.x + platform.width &&
                    gameState.playerPosition.x + playerWidth > platform.x &&
                    gameState.playerPosition.y < platform.y + platform.height &&
                    gameState.playerPosition.y + playerHeight > platform.y) {
                    
                    // Se for um espinho fixo, causa dano
                    if (platform.type === 'spike') {
                        takeDamage(10); // Dano fixo de espinho
                        // N√£o permite aterrissar ou parar no espinho, simula cair atrav√©s ou ser empurrado
                        continue; 
                    }

                    // Colis√£o de cima (aterrissando)
                    if (gameState.playerVelocity.y > 0 && 
                        gameState.playerPosition.y + playerHeight - gameState.playerVelocity.y <= platform.y) {
                        gameState.playerPosition.y = platform.y - playerHeight;
                        gameState.playerVelocity.y = 0;
                        gameState.isGrounded = true;
                        
                        // Part√≠culas de aterrissagem
                        if (gameState.playerVelocity.y > 8) {
                            addParticles('landDust', gameState.playerPosition.x + playerWidth/2, gameState.playerPosition.y + playerHeight, 12);
                            screenShake(3, 150);
                        }
                        
                        // Efeito de plataforma escorregadia
                        if (platform.slippery && Math.abs(gameState.playerVelocity.x) > 0) {
                            gameState.playerVelocity.x *= 1.2; // Aumenta deslizamento
                        }

                        // Zona de espinhos caindo
                        if (platform.fallingSpikeZone && Math.random() < 0.005) { // Pequena chance de spawnar espinho
                            addFallingSpike(platform.x + Math.random() * platform.width, 0);
                        }

                    }
                    // Colis√£o de baixo
                    else if (gameState.playerVelocity.y < 0) {
                        gameState.playerPosition.y = platform.y + platform.height;
                        gameState.playerVelocity.y = 0;
                    }
                    // Colis√£o lateral
                    else if (gameState.playerVelocity.x !== 0) {
                        if (gameState.playerPosition.x < platform.x) {
                            gameState.playerPosition.x = platform.x - playerWidth;
                        } else {
                            gameState.playerPosition.x = platform.x + platform.width;
                        }
                        gameState.playerVelocity.x = 0;
                    }
                }
            }
        }

        function checkEnemyCollisions() {
            if (gameState.isInvincible) return;
            
            const playerWidth = CONFIG.PLAYER_WIDTH;
            const playerHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
            
            for (const enemy of enemies) {
                // N√£o colide com Tarek em modo di√°logo
                if (enemy.type === 'boss_dialogue') continue;

                // AABB collision check
                const enemyWidth = enemy.type === 'boss' ? 70 : 50; // Tarek √© maior
                const enemyHeight = enemy.type === 'boss' ? 70 : 50;
                
                if (gameState.playerPosition.x < enemy.position.x + enemyWidth &&
                    gameState.playerPosition.x + playerWidth > enemy.position.x &&
                    gameState.playerPosition.y < enemy.position.y + enemyHeight &&
                    gameState.playerPosition.y + playerHeight > enemy.position.y) {
                    
                    takeDamage(enemy.damage);
                    
                    // Knockback
                    const knockbackForce = 8;
                    const dx = (gameState.playerPosition.x + playerWidth/2) - (enemy.position.x + enemyWidth/2);
                    gameState.playerVelocity.x = dx > 0 ? knockbackForce : -knockbackForce;
                    gameState.playerVelocity.y = -5;
                    
                    break; // Apenas um dano por frame
                }
            }
        }

        function checkFallingSpikeCollisions() {
            if (gameState.isInvincible) return;

            const playerWidth = CONFIG.PLAYER_WIDTH;
            const playerHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;

            for (let i = fallingSpikes.length - 1; i >= 0; i--) {
                const spike = fallingSpikes[i];
                if (spike.active &&
                    gameState.playerPosition.x < spike.x + spike.width &&
                    gameState.playerPosition.x + playerWidth > spike.x &&
                    gameState.playerPosition.y < spike.y + spike.height &&
                    gameState.playerPosition.y + playerHeight > spike.y) {
                    
                    takeDamage(spike.damage);
                    fallingSpikes.splice(i, 1); // Remove o espinho ap√≥s colis√£o
                    vibrate(200); // Feedback t√°til
                }
            }
        }

        function checkEffectCollisions() {
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                
                // Efeitos causados pelo jogador
                if (effect.damage && effect.origin === 'player' && effect.active !== false) {
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const enemy = enemies[j];
                        // Ignora Tarek em modo di√°logo
                        if (enemy.type === 'boss_dialogue') continue;

                        // Verificar se j√° atingiu este inimigo (para efeitos piercing ou √°rea)
                        if (effect.hitTargets && effect.hitTargets.includes(enemy)) {
                            continue;
                        }
                        
                        const enemyWidth = enemy.type === 'boss' ? 70 : 50;
                        const enemyHeight = enemy.type === 'boss' ? 70 : 50;

                        // Verifica colis√£o do efeito com o inimigo
                        if (effect.x < enemy.position.x + enemyWidth &&
                            effect.x + effect.width > enemy.position.x &&
                            effect.y < enemy.position.y + enemyHeight &&
                            effect.y + effect.height > enemy.position.y) {
                            
                            // Causar dano
                            enemy.health -= effect.damage;
                            playSound('sfx_damage_enemy'); // Som de dano no inimigo
                            
                            // Adicionar √† lista de alvos atingidos
                            if (effect.hitTargets) {
                                effect.hitTargets.push(enemy);
                            }
                            
                            // Efeitos visuais
                            showDamageNumber(effect.damage, enemy.position.x + enemyWidth/2, enemy.position.y);
                            addParticles('hitSpark', enemy.position.x + enemyWidth/2, enemy.position.y + enemyHeight/2, 8);
                            screenShake(2, 100);
                            
                            // Knockback no inimigo
                            if (effect.knockback) {
                                const knockDirection = (enemy.position.x + enemyWidth/2) - (effect.x + effect.width/2) > 0 ? 1 : -1;
                                enemy.position.x += knockDirection * effect.knockback;
                            }
                            
                            // Verificar se inimigo morreu
                            if (enemy.health <= 0) {
                                gainXP(enemy.xpValue);
                                // Efeitos de morte
                                addParticles('deathExplosion', enemy.position.x + enemyWidth/2, enemy.position.y + enemyHeight/2, 20);
                                screenShake(4, 200);
                                enemies.splice(j, 1); // Remover inimigo
                                
                                if (enemy.type === 'boss') {
                                    defeatBoss(enemy);
                                }
                            }
                            
                            // Desativar efeito se n√£o for piercing ou de √°rea
                            if (!effect.piercing && !effect.areaEffect) {
                                effect.active = false;
                            }
                        }
                    }
                }
                
                // Efeitos causados por inimigos
                if (effect.damage && effect.origin === 'enemy' && !gameState.isInvincible && effect.active !== false) {
                    const playerWidth = CONFIG.PLAYER_WIDTH;
                    const playerHeight = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
                    
                    // Verifica colis√£o do efeito com o jogador
                    if (effect.x < gameState.playerPosition.x + playerWidth &&
                        effect.x + effect.width > gameState.playerPosition.x &&
                        effect.y < gameState.playerPosition.y + playerHeight &&
                        effect.y + effect.height > gameState.playerPosition.y) {
                        
                        takeDamage(effect.damage);
                        effect.active = false; // Efeitos de inimigo geralmente n√£o s√£o piercing para o jogador
                        vibrate(200); // Feedback t√°til
                    }
                }
            }
        }

        function updatePlayerAnimation() {
            if (gameState.isUmbraFurious) {
                gameState.currentAnimation = 'umbra_fury'; 
            } else if (!gameState.isGrounded) {
                gameState.currentAnimation = 'jump';
            } else if (gameState.isCrouching) {
                gameState.currentAnimation = 'crouch';
            } else if (Math.abs(gameState.playerVelocity.x) > 0.1) {
                gameState.currentAnimation = 'walk';
            } else {
                gameState.currentAnimation = 'idle';
            }
        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // N√£o atualiza inimigos em modo di√°logo
                if (enemy.type === 'boss_dialogue') continue;

                // Reduzir timer de congelamento (se aplic√°vel para futuros inimigos)
                if (enemy.frozen) {
                    enemy.frozenTimer -= deltaTime;
                    if (enemy.frozenTimer <= 0) {
                        enemy.frozen = false;
                    }
                    continue; // Pular atualiza√ß√£o se congelado
                }
                
                // Padr√£o de movimento
                if (enemy.type === 'sentinel' && enemy.pattern === 'patrol') {
                    updateEnemyPatrol(enemy, deltaTime);
                } else if (enemy.type === 'sentinel') { // IA padr√£o para sentinelas
                    updateEnemyAI(enemy, deltaTime);
                } else if (enemy.type === 'boss') {
                    updateBossAI(enemy, deltaTime);
                }
                
                // Aplicar gravidade
                enemy.velocity = enemy.velocity || { x: 0, y: 0 };
                enemy.velocity.y += CONFIG.GRAVITY;
                
                // Atualizar posi√ß√£o
                enemy.position.x += enemy.velocity.x;
                enemy.position.y += enemy.velocity.y;
                
                // Verificar colis√µes com plataformas
                checkEnemyPlatformCollisions(enemy);
            }
        }

        function updateEnemyPatrol(enemy, deltaTime) {
            if (!enemy.direction) {
                enemy.direction = 1;
                enemy.patrolStartX = enemy.position.x;
            }
            
            enemy.position.x += enemy.speed * enemy.direction;
            
            // Verificar limites de patrulha
            if (enemy.position.x > enemy.patrolStartX + enemy.patrolRange) {
                enemy.direction = -1;
            } else if (enemy.position.x < enemy.patrolStartX - enemy.patrolRange) {
                enemy.direction = 1;
            }
        }

        function updateEnemyAI(enemy, deltaTime) {
            const distanceToPlayer = Math.abs(enemy.position.x - gameState.playerPosition.x);
            const playerInRange = distanceToPlayer < enemy.attackRange; 
            const currentTime = Date.now();
            
            // L√≥gica de ataque
            if (playerInRange && (currentTime - (enemy.lastAttackTime || 0) > enemy.attackCooldown)) {
                enemyAttack(enemy);
                enemy.lastAttackTime = currentTime;
            }
            
            // Mover em dire√ß√£o ao jogador se n√£o estiver atacando e estiver longe
            if (!playerInRange || distanceToPlayer > enemy.attackRange * 0.5) {
                const direction = gameState.playerPosition.x > enemy.position.x ? 1 : -1;
                enemy.position.x += direction * enemy.speed;
                enemy.facing = direction === 1 ? 'right' : 'left';
            } else {
                enemy.velocity.x = 0; // Para quando est√° perto
            }
        }

        function enemyAttack(enemy) {
            const direction = gameState.playerPosition.x > enemy.position.x ? 1 : -1;
            
            switch(enemy.type) {
                case 'sentinel':
                    // Proj√©til de gelo da sentinela
                    addAbilityEffect({
                        type: 'enemyIceShot',
                        x: enemy.position.x + (direction > 0 ? 50 : -25),
                        y: enemy.position.y + 15,
                        width: 20,
                        height: 6,
                        duration: 2000,
                        damage: enemy.damage,
                        direction: direction,
                        speed: 5,
                        origin: 'enemy'
                    });
                    
                    addParticles('enemyMuzzle', enemy.position.x + 25, enemy.position.y + 15, 6);
                    playSound('sfx_ability_i'); // Reutilizando som, pode ser um novo
                    break;
            }
        }

        function checkEnemyPlatformCollisions(enemy) {
            enemy.isGrounded = false;
            const enemyWidth = enemy.type === 'boss' ? 70 : 50;
            const enemyHeight = enemy.type === 'boss' ? 70 : 50;
            
            for (const platform of platforms) {
                // Inimigos n√£o colidem com espinhos fixos
                if (platform.type === 'spike') continue;

                if (enemy.position.x < platform.x + platform.width &&
                    enemy.position.x + enemyWidth > platform.x &&
                    enemy.position.y < platform.y + platform.height &&
                    enemy.position.y + enemyHeight > platform.y) {
                    
                    if (enemy.velocity.y > 0 && 
                        enemy.position.y + enemyHeight - enemy.velocity.y <= platform.y) {
                        enemy.position.y = platform.y - enemyHeight;
                        enemy.velocity.y = 0;
                        enemy.isGrounded = true;
                    }
                }
            }
        }

        function addFallingSpike(x, y) {
            playSound('sfx_spike_fall');
            fallingSpikes.push({
                x: x,
                y: y,
                width: 30, // Largura do espinho
                height: 50, // Altura do espinho
                velocity: 0,
                damage: 20,
                active: true,
                sprite: ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.falling_spike_sprite)
            });
        }

        function updateFallingSpikes(deltaTime) {
            for (let i = fallingSpikes.length - 1; i >= 0; i--) {
                const spike = fallingSpikes[i];
                if (!spike.active) continue;

                spike.velocity += CONFIG.GRAVITY;
                spike.y += spike.velocity;

                // Colis√£o com o ch√£o ou plataformas (destruir espinho)
                if (spike.y + spike.height > CONFIG.WORLD_HEIGHT) { // Ch√£o do mundo
                    spike.active = false; // Desativa
                    fallingSpikes.splice(i, 1);
                    addParticles('explosion', spike.x + spike.width/2, spike.y + spike.height, 10);
                } else {
                    for (const platform of platforms) {
                        // Colis√£o com plataformas
                        if (platform.type !== 'spike' &&
                            spike.x < platform.x + platform.width &&
                            spike.x + spike.width > platform.x &&
                            spike.y + spike.height > platform.y &&
                            spike.y < platform.y + platform.height) {
                            
                            spike.active = false;
                            fallingSpikes.splice(i, 1);
                            addParticles('explosion', spike.x + spike.width/2, spike.y + spike.height, 10);
                            break;
                        }
                    }
                }
            }
        }


        function updateAbilityEffects(deltaTime) {
            for (let i = abilityEffects.length - 1; i >= 0; i--) {
                const effect = abilityEffects[i];
                effect.timer -= deltaTime;
                
                // Movimento baseado no tipo
                switch(effect.type) {
                    case 'energyProjectile': // Proj√©til do Escolhido
                    case 'enemyIceShot': // Proj√©til da Sentinela
                    case 'bossIceOrb': // Proj√©til de Tarek
                        effect.x += effect.speed * effect.direction;
                        // Part√≠culas de rastro
                        if (Math.random() < 0.4) {
                            addParticles('projectileTrail', effect.x + effect.width/2, effect.y + effect.height/2, 2, effect.type === 'bossIceOrb' ? '#81d4fa' : '#3a86ff');
                        }
                        break;
                    case 'bossDash': // Investida de Tarek
                        if (effect.followBoss && effect.followBoss.position) {
                            effect.x = effect.followBoss.position.x;
                            effect.y = effect.followBoss.position.y;
                        }
                        break;
                    case 'bossPrison': // Pris√£o de Gelo de Tarek
                        if (effect.delay && effect.delay > 0) {
                            effect.delay -= deltaTime;
                            if (effect.delay <= 0) {
                                effect.active = true;
                                addParticles('prisonActivate', effect.x + effect.width/2, effect.y + effect.height/2, 20);
                            }
                        }
                        if (effect.trapping && effect.active) {
                            // Se o jogador estiver na √°rea da pris√£o e a pris√£o estiver ativa
                            const playerInTrap = 
                                gameState.playerPosition.x > effect.x - 20 &&
                                gameState.playerPosition.x < effect.x + effect.width + 20 &&
                                gameState.playerPosition.y > effect.y - 10 &&
                                gameState.playerPosition.y < effect.y + effect.height + 10;
                            
                            if (playerInTrap) {
                                // Reduzir movimento do jogador
                                gameState.playerVelocity.x *= 0.1;
                                gameState.playerVelocity.y *= 0.1;
                                
                                // Dano cont√≠nuo
                                if (Math.random() < 0.05) { // 5% de chance de causar dano por frame
                                    takeDamage(effect.damage * (deltaTime / 1000)); // Dano cont√≠nuo baseado no tempo
                                }
                            }
                        }
                        break;
                }
                
                // Remover efeitos expirados
                if (effect.timer <= 0 || effect.active === false) { // Adicionado effect.active para remo√ß√£o manual
                    abilityEffects.splice(i, 1);
                }
            }
        }

        function updateParticles(deltaTime) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Atualizar posi√ß√£o
                particle.x += particle.vx * (deltaTime / 16);
                particle.y += particle.vy * (deltaTime / 16);
                
                // Aplicar gravidade em algumas part√≠culas
                if (particle.gravity) {
                    particle.vy += CONFIG.GRAVITY * 0.3;
                }
                
                // Reduzir vida
                particle.life -= deltaTime;
                
                // Fade out
                if (particle.life < particle.maxLife * 0.3) {
                    particle.alpha = particle.life / (particle.maxLife * 0.3);
                }
                
                // Remover part√≠culas mortas
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
            
            // Limitar n√∫mero de part√≠culas
            if (particles.length > CONFIG.MAX_PARTICLES) {
                particles.splice(0, particles.length - CONFIG.MAX_PARTICLES);
            }
            
            // Adicionar neve ambiente (apenas se n√£o estiver na tela inicial ou menu)
            if (!gameState.inStartScreen && !gameState.gamePaused) {
                if (Math.random() < CONFIG.SNOW_SPAWN_RATE) {
                    addParticles('snow', gameState.cameraOffset.x + Math.random() * canvas.width, -10 + gameState.cameraOffset.y, 1);
                }
            }
        }

        function updateDamageNumbers(deltaTime) {
            // Os n√∫meros de dano s√£o elementos DOM, sua anima√ß√£o √© controlada por CSS.
            // Aqui, apenas os removemos quando o timer de data-timeLeft expira.
            const damageContainer = document.getElementById('particle-container');
            const existingNumbers = damageContainer.querySelectorAll('.damage-number, .xp-number');
            
            existingNumbers.forEach(number => {
                const timeLeft = parseFloat(number.dataset.timeLeft) - deltaTime;
                number.dataset.timeLeft = timeLeft;
                
                if (timeLeft <= 0) {
                    number.remove();
                }
            });
        }

        function updateCooldowns(deltaTime) {
            for (const key in gameState.abilitiesCooldown) {
                if (gameState.abilitiesCooldown[key] > 0) {
                    gameState.abilitiesCooldown[key] -= deltaTime / 1000;
                    
                    // Atualizar visualiza√ß√£o
                    updateCooldownVisual(key);
                }
            }
        }

        function updateCooldownVisual(key) {
            const btn = document.getElementById(`ability-${key.toLowerCase()}`);
            const overlay = btn?.querySelector('.cooldown-overlay');
            
            if (btn && overlay) {
                const cooldownRatio = gameState.abilitiesCooldown[key] / gameState.abilitiesMaxCooldown[key];
                
                if (cooldownRatio > 0) {
                    btn.classList.add('cooldown');
                    const angle = 360 * (1 - cooldownRatio);
                    overlay.style.background = `conic-gradient(from 0deg, transparent ${angle}deg, rgba(0, 0, 0, 0.8) ${angle}deg)`;
                } else {
                    btn.classList.remove('cooldown');
                    overlay.style.background = '';
                }
            }
        }

        function updateRegeneration(deltaTime) {
            // Regenera√ß√£o de mana (aumentada pelo CONFIG.MANA_REGEN_RATE)
            if (gameState.playerMana < gameState.playerMaxMana) {
                gameState.playerMana += CONFIG.MANA_REGEN_RATE * (deltaTime / 1000);
                gameState.playerMana = Math.min(gameState.playerMana, gameState.playerMaxMana);
                updateManaBar();
            }
            
            // Regenera√ß√£o lenta de vida (apenas fora de combate)
            if (gameState.playerHealth < gameState.playerMaxHealth && !gameState.isInvincible) {
                gameState.playerHealth += CONFIG.HEALTH_REGEN_RATE * (deltaTime / 1000);
                gameState.playerHealth = Math.min(gameState.playerHealth, gameState.playerMaxHealth);
                updateHealthBar();
            }
        }

        function updateCamera(deltaTime) {
            if (gameState.fixedCamera) {
                // Se a c√¢mera for fixa, ela n√£o se move
                gameState.cameraOffset.x = gameState.fixedCameraTarget.x;
                gameState.cameraOffset.y = gameState.fixedCameraTarget.y;
                return;
            }

            // Calcular posi√ß√£o alvo da c√¢mera
            gameState.targetCameraOffset.x = gameState.playerPosition.x - canvas.width / 2;
            gameState.targetCameraOffset.y = gameState.playerPosition.y - canvas.height / 2;
            
            // Limitar c√¢mera
            gameState.targetCameraOffset.x = clamp(gameState.targetCameraOffset.x, 0, CONFIG.WORLD_WIDTH_CURRENT_PHASE - canvas.width);
            gameState.targetCameraOffset.y = clamp(gameState.targetCameraOffset.y, -100, CONFIG.WORLD_HEIGHT - canvas.height + 100);
            
            // Suavizar movimento
            gameState.cameraOffset.x += (gameState.targetCameraOffset.x - gameState.cameraOffset.x) * CONFIG.CAMERA_SMOOTHING;
            gameState.cameraOffset.y += (gameState.targetCameraOffset.y - gameState.cameraOffset.y) * CONFIG.CAMERA_SMOOTHING;

            // Se o jogador chegou ao final da fase de plataforma pr√©-Tarek, transiciona para o encontro
            if (gameState.currentPhase === 2 && gameState.playerPosition.x >= CONFIG.WORLD_WIDTH_CURRENT_PHASE - CONFIG.PLAYER_WIDTH - 50) { // Margem
                loadPhase(3); // Transiciona para o encontro com Tarek (di√°logo)
            }
        }

        function checkCheckpoints() {
            // Checkpoints s√£o definidos por fase
            if (gameState.currentPhase === 2) { // Checkpoints para a fase de plataforma pr√©-Tarek
                if (gameState.playerPosition.x >= CONFIG.WORLD_WIDTH_CURRENT_PHASE - 100 && gameState.currentCheckpoint !== 'pre_tarek_gate') {
                    saveCheckpoint('pre_tarek_gate');
                }
            }
            // Adicione outros checkpoints para outras fases aqui
        }

        function checkGameConditions() {
            // Verificar morte do jogador
            if (gameState.playerHealth <= 0) {
                gameOver();
            }
            
            // Verificar vit√≥ria da fase (ex: Tarek derrotado)
            if (gameState.bossDefeated && gameState.currentPhase === 4) {
                // Ap√≥s derrotar Tarek, o jogo aguardar√° o di√°logo de vit√≥ria para prosseguir
                // Nada a fazer aqui, a derrota do boss j√° chama o di√°logo de vit√≥ria
            }
        }

        // ===== SISTEMA DE HABILIDADES =====
        function useAbility(key) {
            if (!currentChampion || gameState.abilitiesCooldown[key] > 0) return;
            
            const ability = currentChampion.abilities.find(a => a.key === key);
            if (!ability) return;
            
            if (gameState.playerMana < ability.manaCost) {
                // Feedback visual de mana insuficiente
                flashScreen(getComputedStyle(document.documentElement).getPropertyValue('--mana-color'), 200);
                vibrate(50); // Vibra√ß√£o curta
                return;
            }
            
            // Consumir mana
            gameState.playerMana -= ability.manaCost;
            
            // Definir cooldown
            gameState.abilitiesCooldown[key] = ability.cooldown;
            
            // Executar habilidade
            ability.execute();
            
            // Atualizar UI
            updateManaBar();
        }

        function addAbilityEffect(effect) {
            effect.timer = effect.duration || 1000;
            effect.origin = effect.origin || 'player';
            effect.active = effect.active !== false; // Efeito pode ser desativado manualmente (ex: impacto)
            effect.hitTargets = effect.hitTargets || []; // Para controlar inimigos j√° atingidos por piercing/√°rea
            
            abilityEffects.push(effect);
        }

        // ===== SISTEMA DE PART√çCULAS =====
        function addParticles(type, x, y, count, color = null) {
            for (let i = 0; i < count; i++) {
                const particle = createParticle(type, x, y, color);
                particles.push(particle);
            }
        }

        function createParticle(type, x, y, customColor = null) {
            const baseParticle = {
                x: x + (Math.random() - 0.5) * 20,
                y: y + (Math.random() - 0.5) * 20,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                size: 2 + Math.random() * 3,
                alpha: 1,
                gravity: false,
                type: type // Adiciona o tipo para renderiza√ß√£o espec√≠fica
            };
            
            switch(type) {
                case 'snow':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: 1 + Math.random() * 2,
                        size: 2 + Math.random() * 4,
                        color: customColor || '#ffffff',
                        life: 8000 + Math.random() * 4000,
                        maxLife: 12000
                    };
                case 'jumpDust':
                case 'landDust':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -1 - Math.random() * 2,
                        color: customColor || '#aaaaaa',
                        life: 400 + Math.random() * 200,
                        maxLife: 600,
                        gravity: true
                    };
                case 'hitSpark':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6,
                        color: customColor || '#ffff00',
                        life: 300 + Math.random() * 200,
                        maxLife: 500
                    };
                case 'deathExplosion':
                case 'explosion':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        color: customColor || (Math.random() > 0.5 ? '#ff6666' : '#ffaa66'),
                        life: 800 + Math.random() * 400,
                        maxLife: 1200,
                        size: 3 + Math.random() * 5
                    };
                case 'projectileTrail':
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        color: customColor || '#3a86ff', // Cor padr√£o para rastro de proj√©til do Escolhido
                        life: 300 + Math.random() * 200,
                        maxLife: 500,
                        size: 1 + Math.random() * 2
                    };
                case 'umbraFuria': // Part√≠culas para a F√∫ria de Umbra
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 5,
                        vy: (Math.random() - 0.5) * 5,
                        color: customColor || '#d4af37', // Dourado/√¢mbar
                        life: 500 + Math.random() * 300,
                        maxLife: 800,
                        size: 3 + Math.random() * 4,
                        gravity: false
                    };
                case 'bossIntro': // Part√≠culas para a introdu√ß√£o do boss
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        color: customColor || '#ff6b6b', // Vermelho fogo
                        life: 1000 + Math.random() * 500,
                        maxLife: 1500,
                        size: 4 + Math.random() * 6
                    };
                case 'victoryExplosion': // Explos√£o de vit√≥ria
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 12,
                        vy: (Math.random() - 0.5) * 12,
                        color: customColor || getComputedStyle(document.documentElement).getPropertyValue('--accent-gold'),
                        life: 1200 + Math.random() * 600,
                        maxLife: 1800,
                        size: 5 + Math.random() * 7,
                        gravity: true
                    };
                case 'xpGain': // Part√≠culas de ganho de XP
                    return {
                        ...baseParticle,
                        vx: (Math.random() - 0.5) * 3,
                        vy: -2 - Math.random() * 3,
                        color: customColor || getComputedStyle(document.documentElement).getPropertyValue('--xp-color'),
                        life: 800 + Math.random() * 400,
                        maxLife: 1200,
                        size: 2 + Math.random() * 3,
                        gravity: true
                    };
                default:
                    return { ...baseParticle, color: customColor || '#ffffff', life: 500, maxLife: 500 };
            }
        }

        // ===== SISTEMA DE DANO E COMBATE =====
        function takeDamage(amount) {
            if (gameState.isInvincible) return;
            
            let finalDamage = amount;
            if (gameState.isUmbraFurious) {
                finalDamage *= CONFIG.UMBRA_FURY_DAMAGE_REDUCTION; // Reduz dano recebido na ultimate
            }

            gameState.playerHealth -= finalDamage;
            gameState.playerHealth = Math.max(0, gameState.playerHealth);
            
            playSound('sfx_damage_player'); // Som de dano no jogador
            vibrate(300); // Feedback t√°til de dano

            // Ativar invencibilidade tempor√°ria
            gameState.isInvincible = true;
            gameState.invincibilityTimer = CONFIG.INVINCIBILITY_DURATION;
            
            // Efeitos visuais
            flashScreen(getComputedStyle(document.documentElement).getPropertyValue('--health-color'), CONFIG.DAMAGE_FLASH_DURATION);
            screenShake(5, 300);
            showDamageNumber(finalDamage, gameState.playerPosition.x + CONFIG.PLAYER_WIDTH / 2, gameState.playerPosition.y, true);
            
            // Atualizar UI
            updateHealthBar();
            
            // Verificar morte
            if (gameState.playerHealth <= 0) {
                gameOver();
            }
        }

        function showDamageNumber(damage, x, y, isPlayerDamage = false) {
            const damageContainer = document.getElementById('particle-container');
            const damageNumber = document.createElement('div');
            
            damageNumber.className = isPlayerDamage ? 'damage-number' : 'damage-number'; // Classe gen√©rica, pode diferenciar CSS
            damageNumber.textContent = Math.round(damage);
            damageNumber.style.left = (x - gameState.cameraOffset.x) + 'px';
            damageNumber.style.top = (y - gameState.cameraOffset.y) + 'px';
            damageNumber.style.color = isPlayerDamage ? getComputedStyle(document.documentElement).getPropertyValue('--health-color') : getComputedStyle(document.documentElement).getPropertyValue('--text-light');
            damageNumber.dataset.timeLeft = '1000';
            
            damageContainer.appendChild(damageNumber);
        }

        function gainXP(amount) {
            gameState.playerXP += amount;
            
            // Mostrar n√∫mero de XP
            const xpContainer = document.getElementById('particle-container');
            const xpNumber = document.createElement('div');
            xpNumber.className = 'xp-number';
            xpNumber.textContent = `+${amount} XP`;
            xpNumber.style.left = (gameState.playerPosition.x + CONFIG.PLAYER_WIDTH / 2 - gameState.cameraOffset.x) + 'px';
            xpNumber.style.top = (gameState.playerPosition.y - gameState.cameraOffset.y) + 'px';
            xpNumber.dataset.timeLeft = '1500';
            xpContainer.appendChild(xpNumber);
            
            // Part√≠culas de XP
            addParticles('xpGain', gameState.playerPosition.x + CONFIG.PLAYER_WIDTH / 2, gameState.playerPosition.y, 8, getComputedStyle(document.documentElement).getPropertyValue('--xp-color'));
            
            // Verificar level up
            if (gameState.playerXP >= gameState.playerNextLevelXP) {
                levelUp();
            }
            
            updateXPBar();
            updatePlayerStats();
        }

        function levelUp() {
            playSound('sfx_level_up'); // Som de level up
            gameState.playerLevel++;
            gameState.playerXP -= gameState.playerNextLevelXP;
            gameState.playerNextLevelXP = Math.floor(gameState.playerNextLevelXP * 1.5); // XP para o pr√≥ximo n√≠vel cresce mais r√°pido
            
            // Aumentos autom√°ticos de atributos (sem escolha do jogador)
            gameState.playerMaxHealth += 10;
            gameState.playerHealth = gameState.playerMaxHealth; // Cura completa
            gameState.playerMaxMana += 15;
            gameState.playerMana = gameState.playerMaxMana; // Restaura completa
            gameState.playerDamage += 5;
            gameState.playerSpeed += 0.2;
            
            // Efeitos visuais
            flashScreen(getComputedStyle(document.documentElement).getPropertyValue('--xp-color'), 500);
            addParticles('umbraFuria', gameState.playerPosition.x + CONFIG.PLAYER_WIDTH / 2, gameState.playerPosition.y + CONFIG.NORMAL_HEIGHT / 2, 30); // Part√≠culas douradas para level up
            
            // Mostrar notifica√ß√£o de level up (sem op√ß√µes)
            showLevelUpNotification();
            updateAllUI(); // Atualiza UI com novos stats
            saveProgress(); // Salva o progresso ap√≥s level up
        }

        function showLevelUpNotification() {
            const levelUpMenu = document.getElementById('level-up');
            levelUpMenu.style.display = 'block';
            levelUpMenu.style.animation = 'levelUpAnimation 0.8s forwards';
            gameState.gamePaused = true;
        }

        // ===== BOSS FIGHT - TAREK =====
        function triggerBossFight() {
            gameState.inBossFight = true;
            gameState.fixedCamera = true; // Mant√©m a c√¢mera fixa na arena
            
            playSound('sfx_boss_roar'); // Som de rugido do boss

            const tarek = {
                type: 'boss',
                name: 'Tarek, o Guerreiro',
                position: { x: canvas.width - 200, y: 300 }, // Posi√ß√£o de Tarek na arena fixa
                facing: 'left', // Tarek olhando para o jogador
                health: 500, // Vida do boss
                maxHealth: 500,
                damage: 25, // Dano b√°sico de colis√£o
                speed: 1.5,
                velocity: { x: 0, y: 0 },
                isGrounded: false,
                xpValue: 500, // XP por derrotar Tarek
                
                // IA do Boss
                aiState: 'combat', // Come√ßa em combate
                aiTimer: 0,
                attackCooldown: 0,
                lastAttack: 0,
                
                // Habilidades do Boss (Nome, Cooldown em ms, Range, Dano)
                abilities: [
                    { name: 'Golpe Devastador', cooldown: 3000, range: 80, damage: 35, lastUsed: 0 },
                    { name: 'Investida G√©lida', cooldown: 6000, range: 300, damage: 45, lastUsed: 0 },
                    { name: 'Orbe Congelante', cooldown: 5000, range: 400, damage: 30, lastUsed: 0 },
                    { name: 'Pris√£o de Gelo', cooldown: 10000, range: 200, damage: 20, lastUsed: 0 }
                ]
            };
            
            enemies.push(tarek);
            
            // Mostrar barra de vida do boss
            document.getElementById('boss-name').style.display = 'block';
            document.getElementById('boss-health-bar').style.display = 'block';
            updateBossHealthBar(tarek);
            
            // Salvar checkpoint antes do boss
            saveCheckpoint('tarek_fight_start');
            
            // Efeitos visuais de in√≠cio da luta
            screenShake(8, 500);
            flashScreen(getComputedStyle(document.documentElement).getPropertyValue('--accent-fire'), 300);
            addParticles('bossIntro', tarek.position.x + 35, tarek.position.y + 35, 40);
        }

        function updateBossAI(boss, deltaTime) {
            const distanceToPlayer = Math.abs(boss.position.x - gameState.playerPosition.x);
            const verticalDistance = Math.abs(boss.position.y - gameState.playerPosition.y);
            const currentTime = Date.now();
            
            // Verifica se Tarek est√° "enraged" (menos vida)
            if (boss.health < boss.maxHealth * 0.4 && !boss.enraged) {
                boss.enraged = true;
                boss.speed *= 1.3; // Aumenta velocidade
                boss.damage *= 1.1; // Aumenta dano
                // Reduz cooldowns das habilidades (para ter mais ataques)
                boss.abilities.forEach(ab => ab.cooldown *= 0.8);

                flashScreen(getComputedStyle(document.documentElement).getPropertyValue('--accent-fire'), 500);
                addParticles('bossIntro', boss.position.x + 35, boss.position.y + 35, 50); // Mais part√≠culas

                showDialog("TAREK", "Voc√™... √© mais forte do que pensei! Mas n√£o vou cair facilmente!", []);
            }
            
            // Atualizar cooldowns das habilidades do boss
            boss.abilities.forEach(ability => {
                // Para boss, usamos Date.now() para √∫ltimo uso e cooldown
                if (currentTime - (ability.lastUsed || 0) < ability.cooldown) {
                    ability.ready = false;
                } else {
                    ability.ready = true;
                }
            });
            
            boss.aiTimer += deltaTime;
            
            switch(boss.aiState) {
                case 'combat':
                    // Decide qual habilidade usar baseado na dist√¢ncia e se est√° pronta
                    let chosenAbility = null;
                    const rand = Math.random(); 

                    // Prioriza habilidades de curta dist√¢ncia se perto
                    if (distanceToPlayer < boss.abilities[0].range && boss.abilities[0].ready) { // Golpe Devastador
                        chosenAbility = boss.abilities[0];
                    } 
                    // Considera Investida ou Orbe se em m√©dia/longa dist√¢ncia
                    else if (distanceToPlayer > 50 && distanceToPlayer < boss.abilities[1].range && boss.abilities[1].ready && rand < 0.7) { // Investida G√©lida
                        chosenAbility = boss.abilities[1];
                    }
                    else if (distanceToPlayer > 100 && boss.abilities[2].ready) { // Orbe Congelante
                        chosenAbility = boss.abilities[2];
                    }
                    // Usa Pris√£o de Gelo ocasionalmente, independentemente da dist√¢ncia imediata
                    else if (boss.abilities[3].ready && rand < 0.3 && boss.aiTimer > 2000) { // Pris√£o de Gelo (ocasionalmente)
                        chosenAbility = boss.abilities[3];
                    }
                    
                    if (chosenAbility && boss.aiTimer > 500) { // Pequeno delay entre a√ß√µes
                        executeBossAbility(boss, chosenAbility);
                        boss.aiState = 'attacking'; // Entra em estado de ataque
                        boss.aiTimer = 0; // Reseta o timer para controlar a dura√ß√£o do ataque
                        boss.currentAnimation = 'attack'; // Anima√ß√£o de ataque
                        setTimeout(() => { boss.currentAnimation = 'idle'; }, 500); // Reseta anima√ß√£o
                    } else {
                        // Se n√£o puder atacar, move-se em dire√ß√£o ao jogador
                        moveBossTowardsPlayer(boss, distanceToPlayer);
                    }
                    break;
                    
                case 'attacking':
                    // Permanece neste estado por um tempo, simulando a execu√ß√£o do ataque
                    if (boss.aiTimer > 1000) { // Dura√ß√£o da anima√ß√£o/execu√ß√£o do ataque
                        boss.aiState = 'combat';
                        boss.aiTimer = 0;
                    }
                    break;
            }
            updateBossHealthBar(boss); // Atualiza a barra de vida do boss
        }

        function moveBossTowardsPlayer(boss, distance) {
            // Tarek se move em dire√ß√£o ao jogador se n√£o estiver muito perto
            if (distance > 50) {
                const direction = gameState.playerPosition.x > boss.position.x ? 1 : -1;
                boss.position.x += direction * boss.speed;
                boss.facing = direction === 1 ? 'right' : 'left'; // Atualiza a dire√ß√£o do Tarek
                boss.currentAnimation = 'walk'; // Anima√ß√£o de andar

                // Clamp Tarek's position to keep him on screen
                boss.position.x = clamp(boss.position.x, 0, canvas.width - 70); // 70 = boss width

                // Tarek tamb√©m tenta pular se o jogador estiver em uma plataforma superior (e Tarek estiver no ch√£o)
                if (gameState.isGrounded && gameState.playerPosition.y < boss.position.y - 50 && boss.isGrounded) {
                    boss.velocity.y = -CONFIG.JUMP_FORCE * 0.8;
                    boss.isGrounded = false;
                    boss.currentAnimation = 'jump'; // Anima√ß√£o de pulo
                }
            } else {
                boss.velocity.x = 0; // Para quando est√° perto
                boss.currentAnimation = 'idle'; // Anima√ß√£o parada
            }
        }

        function executeBossAbility(boss, ability) {
            const direction = gameState.playerPosition.x > boss.position.x ? 1 : -1;
            ability.lastUsed = Date.now(); // Marca o √∫ltimo uso para cooldown
            
            switch(ability.name) {
                case 'Golpe Devastador':
                    addAbilityEffect({
                        type: 'bossSlash',
                        x: boss.position.x + (direction > 0 ? 70 : -50),
                        y: boss.position.y + 10,
                        width: 70,
                        height: 30,
                        duration: 300,
                        damage: ability.damage,
                        origin: 'enemy',
                        knockback: 20
                    });
                    screenShake(6, 300);
                    playSound('sfx_attack_u'); // Reutilizando som
                    break;
                case 'Investida G√©lida':
                    boss.velocity.x = direction * 10; // Impulso para o dash
                    addAbilityEffect({
                        type: 'bossDash',
                        x: boss.position.x,
                        y: boss.position.y,
                        width: 70,
                        height: 50,
                        duration: 800,
                        damage: ability.damage,
                        origin: 'enemy',
                        followBoss: boss // Efeito segue o boss durante o dash
                    });
                    addParticles('dashIce', boss.position.x + 35, boss.position.y + 35, 30);
                    screenShake(8, 400);
                    playSound('sfx_ability_o'); // Reutilizando som
                    break;
                case 'Orbe Congelante':
                    addAbilityEffect({
                        type: 'bossIceOrb',
                        x: boss.position.x + (direction > 0 ? 80 : -30),
                        y: boss.position.y + 20,
                        width: 40,
                        height: 40,
                        duration: 3000,
                        damage: ability.damage,
                        direction: direction,
                        speed: 4,
                        origin: 'enemy'
                    });
                    playSound('sfx_ability_i'); // Reutilizando som
                    break;
                case 'Pris√£o de Gelo':
                    // Cria m√∫ltiplas pris√µes ao redor do jogador
                    for (let i = 0; i < 3; i++) {
                        const offsetX = (i - 1) * 80; // Espa√ßamento
                        addAbilityEffect({
                            type: 'bossPrison',
                            x: gameState.playerPosition.x + offsetX - 15, // Posi√ß√£o em rela√ß√£o ao jogador
                            y: gameState.playerPosition.y - 60,
                            width: 30,
                            height: 120,
                            duration: 5000, // Dura√ß√£o da pris√£o
                            damage: ability.damage, // Dano cont√≠nuo ou inicial
                            origin: 'enemy',
                            trapping: true, // Indica que o efeito prende
                            delay: i * 200, // Cada pris√£o aparece com um pequeno delay
                            active: false // Inicialmente inativo at√© o delay passar
                        });
                    }
                    screenShake(5, 600);
                    playSound('sfx_ability_p'); // Reutilizando som
                    break;
            }
        }

        function updateBossHealthBar(boss) {
            const healthFill = document.getElementById('boss-health-fill');
            const healthPercentage = (boss.health / boss.maxHealth) * 100;
            healthFill.style.width = healthPercentage + '%';
            
            // Mudar cor baseada na vida (pode ser ajustado no CSS tamb√©m)
            if (healthPercentage > 60) {
                healthFill.style.background = 'linear-gradient(90deg, #4caf50, #8bc34a)';
            } else if (healthPercentage > 30) {
                healthFill.style.background = 'linear-gradient(90deg, #ff9800, #ffc107)';
            } else {
                healthFill.style.background = 'linear-gradient(90deg, #f44336, #e53935)';
            }
        }

        function defeatBoss(boss) {
            gameState.bossDefeated = true;
            gameState.inBossFight = false;
            
            stopMusic(); // Para a m√∫sica de boss
            
            // Esconder barra do boss
            document.getElementById('boss-name').style.display = 'none';
            document.getElementById('boss-health-bar').style.display = 'none';
            
            // Efeitos visuais de vit√≥ria
            flashScreen(getComputedStyle(document.documentElement).getPropertyValue('--accent-gold'), 800);
            screenShake(10, 1000);
            addParticles('victoryExplosion', boss.position.x + 35, boss.position.y + 35, 60);
            
            // XP massivo por derrotar o boss
            gainXP(boss.xpValue);
            
            // Remover boss
            const bossIndex = enemies.indexOf(boss);
            if (bossIndex > -1) {
                enemies.splice(bossIndex, 1);
            }
            
            // Di√°logo de vit√≥ria
            setTimeout(() => {
                showDialog(
                    "TAREK",
                    `Impressionante, ${gameState.playerName}... Voc√™ realmente tem a for√ßa de um Escolhido. Pode passar, mas saiba que desafios ainda maiores o aguardam adiante.`,
                    [
                        {
                            text: "Obrigado pela luta honrosa, Tarek.",
                            action: () => {
                                showDialog(
                                    "TAREK",
                                    "Que os ventos gelados guiem seus passos, Escolhido. E que voc√™ encontre o que procura antes que seja tarde demais.",
                                    [
                                        {
                                            text: "Continuar jornada (Parte 2 em breve)",
                                            action: () => {
                                                saveCheckpoint('boss_defeated');
                                                showVictoryScreen(); // Mostrar tela de vit√≥ria de demo
                                            }
                                        }
                                    ]
                                );
                            }
                        }
                    ]
                );
            }, 2000);
        }

        // ===== EFEITOS VISUAIS =====
        function screenShake(intensity, duration) {
            if (!gameSettings.screenShake) return; // Se o usu√°rio desativou no settings
            const gameContainer = document.getElementById('game-container');
            const originalTransform = gameContainer.style.transform;
            
            const startTime = Date.now();
            
            function shake() {
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    const currentIntensity = intensity * (1 - progress);
                    
                    const offsetX = (Math.random() - 0.5) * currentIntensity;
                    const offsetY = (Math.random() - 0.5) * currentIntensity;
                    
                    gameContainer.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
                    requestAnimationFrame(shake);
                } else {
                    gameContainer.style.transform = originalTransform;
                }
            }
            
            shake();
        }

        function flashScreen(color, duration) {
            const flash = document.getElementById('screen-flash');
            flash.style.background = color;
            flash.classList.add('active');
            
            setTimeout(() => {
                flash.classList.remove('active');
            }, duration);
        }

        // ===== RENDERIZA√á√ÉO =====
        function render() {
            // Limpar canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Renderizar background com parallax
            renderBackground();
            
            // Renderizar plataformas
            renderPlatforms();
            
            // Renderizar efeitos de habilidades (atr√°s dos personagens)
            renderAbilityEffects();
            
            // Renderizar espinhos caindo
            renderFallingSpikes();

            // Renderizar jogador
            renderPlayer();
            
            // Renderizar inimigos
            renderEnemies();
            
            // Renderizar part√≠culas
            renderParticles();
            
            // Renderizar efeitos de debug (se necess√°rio)
            if (window.DEBUG_MODE) {
                renderDebugInfo();
            }
        }

        function renderBackground() {
            // Gradiente base do c√©u
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--primary-dark'));
            gradient.addColorStop(0.3, getComputedStyle(document.documentElement).getPropertyValue('--primary-medium'));
            gradient.addColorStop(0.7, getComputedStyle(document.documentElement).getPropertyValue('--primary-light'));
            gradient.addColorStop(1, '#2c3e50'); // Adicionado um tom mais escuro para o horizonte
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Camadas de parallax (usando imagens agora)
            backgroundLayers.forEach((layer, index) => {
                const img = ASSET_MANAGER.getAsset(layer.path);
                if (!img) return; // Se a imagem n√£o carregou, n√£o renderiza

                const parallaxOffset = (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x) * layer.speed;
                const pattern = ctx.createPattern(img, 'repeat-x'); // Repetir horizontalmente

                ctx.fillStyle = pattern;
                ctx.globalAlpha = 1; // Ajuste de opacidade da imagem de fundo
                
                // Desenha a imagem de fundo. Pode ser ajustado para cobrir a tela ou parte dela.
                // Aqui, desenhamos um ret√¢ngulo preenchido com o padr√£o da imagem para simular o parallax.
                ctx.save();
                ctx.translate(-parallaxOffset % img.width, 0); // Move o padr√£o
                // Ajuste Y para posicionar as camadas verticalmente (ex: montanhas no fundo, colinas mais perto)
                // Isto √© um exemplo, ajuste conforme o design dos seus assets de fundo
                let drawY = canvas.height - img.height; 
                if (layer.type === 'sky') drawY = 0;
                else if (layer.type === 'mountains') drawY = canvas.height - img.height - 50;
                else if (layer.type === 'hills') drawY = canvas.height - img.height - 20;

                ctx.fillRect(0, drawY, canvas.width + img.width, img.height); // Desenha um ret√¢ngulo grande o suficiente
                ctx.restore();
            });
            
            ctx.globalAlpha = 1;
        }

        function renderPlatforms() {
            for (const platform of platforms) {
                const x = platform.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = platform.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                // Culling - n√£o renderizar se fora da tela
                if (x + platform.width < -50 || x > canvas.width + 50 || 
                    y + platform.height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                let img = null;
                if (platform.type === 'ground') {
                    img = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.platform_ground);
                } else if (platform.type === 'platform') {
                    img = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.platform_basic);
                } else if (platform.type === 'slippery') {
                    img = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.platform_slippery);
                } else if (platform.type === 'spike') {
                    img = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.spike_trap);
                }

                if (img) {
                    // Desenha a imagem da plataforma. Se a imagem √© pequena, pode repetir como padr√£o.
                    const pattern = ctx.createPattern(img, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(x, y, platform.width, platform.height);
                } else {
                    // Fallback para cor s√≥lida se a imagem n√£o estiver dispon√≠vel
                    ctx.fillStyle = platform.type === 'spike' ? getComputedStyle(document.documentElement).getPropertyValue('--spike-color') : '#888';
                    ctx.fillRect(x, y, platform.width, platform.height);
                }
            }
        }

        function renderFallingSpikes() {
            for (const spike of fallingSpikes) {
                const x = spike.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = spike.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);

                if (spike.active && spike.sprite) {
                    ctx.drawImage(spike.sprite, x, y, spike.width, spike.height);
                } else if (spike.active) {
                    // Fallback para cor s√≥lida
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--spike-color');
                    ctx.fillRect(x, y, spike.width, spike.height);
                }
            }
        }

        function renderPlayer() {
            const x = gameState.playerPosition.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
            const y = gameState.playerPosition.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
            const width = CONFIG.PLAYER_WIDTH;
            const height = gameState.isCrouching ? CONFIG.CROUCH_HEIGHT : CONFIG.NORMAL_HEIGHT;
            
            // Culling
            if (x + width < -50 || x > canvas.width + 50 || y + height < -50 || y > canvas.height + 50) {
                return;
            }
            
            // Efeito de invencibilidade (piscar)
            if (gameState.isInvincible && Math.floor(Date.now() / 100) % 2) {
                ctx.globalAlpha = 0.5;
            }
            
            // Carrega o GIF/Sprite correto para a anima√ß√£o atual do jogador
            let playerSprite = null;
            switch(gameState.currentAnimation) {
                case 'walk':
                    playerSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.player_walk);
                    break;
                case 'jump':
                    playerSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.player_jump);
                    break;
                case 'crouch':
                    playerSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.player_crouch);
                    break;
                case 'attack_u':
                    playerSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.player_attack_u);
                    break;
                case 'attack_i':
                    playerSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.player_attack_i);
                    break;
                case 'attack_o':
                    playerSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.player_attack_o);
                    break;
                case 'umbra_fury':
                    playerSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.player_ultimate);
                    break;
                default: // 'idle' ou outros estados
                    playerSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.player_idle);
                    break;
            }

            if (playerSprite) {
                ctx.save();
                if (gameState.facing === 'left') {
                    ctx.scale(-1, 1); // Espelha horizontalmente
                    ctx.drawImage(playerSprite, -x - width, y, width, height);
                } else {
                    ctx.drawImage(playerSprite, x, y, width, height);
                }
                ctx.restore();
            } else {
                // Fallback para cor s√≥lida se o sprite n√£o carregou
                const playerColor = gameState.isUmbraFurious ? getComputedStyle(document.documentElement).getPropertyValue('--accent-gold') : getComputedStyle(document.documentElement).getPropertyValue('--accent-blue');
                ctx.fillStyle = playerColor;
                ctx.fillRect(x, y, width, height);
            }
            
            ctx.globalAlpha = 1;
        }

        function renderEnemies() {
            for (const enemy of enemies) {
                const x = enemy.position.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = enemy.position.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                const width = enemy.type === 'boss' || enemy.type === 'boss_dialogue' ? 70 : 50; 
                const height = enemy.type === 'boss' || enemy.type === 'boss_dialogue' ? 70 : 50;
                
                // Culling
                if (x + width < -50 || x > canvas.width + 50 || y + height < -50 || y > canvas.height + 50) {
                    continue;
                }
                
                // Efeito de congelamento (se aplic√°vel para futuros inimigos)
                if (enemy.frozen) {
                    ctx.globalAlpha = 0.7;
                    ctx.fillStyle = '#81d4fa';
                    ctx.fillRect(x - 5, y - 5, width + 10, height + 10);
                }
                
                // Renderizar baseado no tipo
                if (enemy.type === 'sentinel') {
                    renderSentinel(enemy, x, y, width, height);
                } else if (enemy.type === 'boss' || enemy.type === 'boss_dialogue') {
                    renderBoss(enemy, x, y, width, height);
                }
                
                // Barra de vida do inimigo (apenas se n√£o for di√°logo ou j√° estiver morto)
                if (enemy.health < enemy.maxHealth && enemy.health > 0 && enemy.type !== 'boss_dialogue') {
                    const barWidth = width + 10; // Barra um pouco maior que o inimigo
                    const barHeight = 6;
                    const barX = x - 5;
                    const barY = y - 15;
                    
                    // Fundo da barra
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                    
                    // Barra de vida
                    const healthPercent = enemy.health / enemy.maxHealth;
                    ctx.fillStyle = healthPercent > 0.5 ? '#4caf50' : healthPercent > 0.25 ? '#ff9800' : '#f44336';
                    ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                    
                    // Borda
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(barX, barY, barWidth, barHeight);
                }
                
                // Nome do inimigo (apenas para boss)
                if ((enemy.type === 'boss' || enemy.type === 'boss_dialogue') && enemy.name) {
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-light');
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(enemy.name, x + width/2, y - 25);
                    ctx.textAlign = 'left';
                }
                
                ctx.globalAlpha = 1;
            }
        }

        function renderSentinel(enemy, x, y, width, height) {
            const sentinelSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.sentinel_sprite);
            if (sentinelSprite) {
                ctx.save();
                if (enemy.facing === 'left') {
                    ctx.scale(-1, 1);
                    ctx.drawImage(sentinelSprite, -x - width, y, width, height);
                } else {
                    ctx.drawImage(sentinelSprite, x, y, width, height);
                }
                ctx.restore();
            } else {
                // Fallback
                ctx.fillStyle = '#78909c'; 
                ctx.fillRect(x, y, width, height);
                ctx.fillStyle = '#cfd8dc'; 
                ctx.fillRect(x + 10, y + 10, width - 20, height - 20);
                ctx.fillStyle = '#00e5ff'; 
                ctx.fillRect(x + 15, y + 5, 4, 4);
                ctx.fillRect(x + 31, y + 5, 4, 4);
            }
        }

        function renderBoss(enemy, x, y, width, height) {
            let bossSprite = null;
            if (enemy.type === 'boss_dialogue') {
                bossSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.tarek_sprite_idle);
            } else { // Boss em combate
                switch(enemy.currentAnimation) {
                    case 'walk':
                        bossSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.tarek_sprite_walk);
                        break;
                    case 'attack':
                        bossSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.tarek_sprite_attack);
                        break;
                    default: // idle
                        bossSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.tarek_sprite_idle);
                        break;
                }
            }

            if (bossSprite) {
                ctx.save();
                if (enemy.facing === 'left') {
                    ctx.scale(-1, 1);
                    ctx.drawImage(bossSprite, -x - width, y, width, height);
                } else {
                    ctx.drawImage(bossSprite, x, y, width, height);
                }
                ctx.restore();
            } else {
                // Fallback para cor s√≥lida
                if (enemy.enraged) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
                    ctx.fillRect(x - 5, y - 5, width + 10, height + 10);
                }
                const bossGradient = ctx.createLinearGradient(x, y, x, y + height);
                bossGradient.addColorStop(0, '#a0522d'); 
                bossGradient.addColorStop(0.5, '#8b4513');
                bossGradient.addColorStop(1, '#692e0e');
                ctx.fillStyle = bossGradient;
                ctx.fillRect(x, y, width, height);
                ctx.fillStyle = '#4a2d1d'; 
                ctx.fillRect(x + 10, y + 15, width - 20, 20); 
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-fire');
                ctx.fillRect(x + 20, y + 8, 6, 6);
                ctx.fillRect(x + width - 26, y + 8, 6, 6);
            }
        }

        function renderAbilityEffects() {
            for (const effect of abilityEffects) {
                const x = effect.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = effect.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                // Culling
                if (x + effect.width < -50 || x > canvas.width + 50 || 
                    y + effect.height < -50 || y > canvas.height + 50 || !effect.active) {
                    continue;
                }
                
                let effectSprite = null;
                switch(effect.type) {
                    case 'meleeAttack':
                        // Para ataques melee, pode ser apenas uma cor ou um efeito de linha/flash
                        ctx.globalAlpha = (1 - (effect.duration - effect.timer) / effect.duration) * 0.8;
                        ctx.fillStyle = effect.umbraBoosted ? getComputedStyle(document.documentElement).getPropertyValue('--accent-gold-light') : getComputedStyle(document.documentElement).getPropertyValue('--text-light');
                        ctx.fillRect(x, y, effect.width, effect.height);
                        ctx.globalAlpha = 1;
                        break;
                    case 'energyProjectile':
                        effectSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.projectile_i);
                        break;
                    case 'arcaneExplosion':
                        effectSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.explosion_o);
                        // Para explos√µes, pode ser melhor desenhar a imagem centralizada e escalando
                        if (effectSprite) {
                            const progress = 1 - (effect.timer / effect.duration);
                            const currentSize = effect.width * progress;
                            ctx.globalAlpha = (1 - progress) * 0.7;
                            ctx.drawImage(effectSprite, x + effect.width/2 - currentSize/2, y + effect.height/2 - currentSize/2, currentSize, currentSize);
                            ctx.globalAlpha = 1;
                        } else {
                            const progress = 1 - (effect.timer / effect.duration);            
                            const maxRadius = effect.width / 2;
                            const currentRadius = maxRadius * progress;
                            ctx.globalAlpha = (1 - progress) * 0.7; 
                            const gradient = ctx.createRadialGradient(x + effect.width/2, y + effect.height/2, 0, x + effect.width/2, y + effect.height/2, currentRadius);
                            gradient.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue('--accent-gold-light'));
                            gradient.addColorStop(0.5, getComputedStyle(document.documentElement).getPropertyValue('--accent-gold'));
                            gradient.addColorStop(1, 'rgba(255, 107, 107, 0)');
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(x + effect.width/2, y + effect.height/2, currentRadius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                        break;
                    case 'bossSlash':
                        // Ataque de Tarek - Golpe Devastador (similar ao melee do player por enquanto)
                        ctx.globalAlpha = (1 - (effect.duration - effect.timer) / effect.duration) * 0.8;
                        ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent-fire');
                        ctx.fillRect(x, y, effect.width, effect.height);
                        ctx.globalAlpha = 1;
                        break;
                    case 'bossIceOrb':
                        effectSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.tarek_ice_orb);
                        break;
                    case 'bossPrison':
                        effectSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.tarek_prison);
                        break;
                    case 'enemyIceShot':
                        // Reutiliza o sprite do proj√©til de energia ou cria um novo para inimigos
                        effectSprite = ASSET_MANAGER.getAsset(CONFIG.ASSET_PATHS.projectile_i); 
                        break;
                }

                if (effectSprite) {
                    ctx.drawImage(effectSprite, x, y, effect.width, effect.height);
                }
            }
        }

        function renderParticles() {
            for (const particle of particles) {
                const x = particle.x - (gameState.fixedCamera ? gameState.fixedCameraTarget.x : gameState.cameraOffset.x);
                const y = particle.y - (gameState.fixedCamera ? gameState.fixedCameraTarget.y : gameState.cameraOffset.y);
                
                // Culling
                if (x < -20 || x > canvas.width + 20 || y < -20 || y > canvas.height + 20) {
                    continue;
                }
                
                ctx.globalAlpha = particle.alpha || 1;
                ctx.fillStyle = particle.color;
                
                // Renderizar baseado no tipo
                switch(particle.type) {
                    case 'snow':
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    default:
                        // Part√≠cula circular padr√£o
                        ctx.beginPath();
                        ctx.arc(x, y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
            }
            
            ctx.globalAlpha = 1;
        }

        function renderDebugInfo() {
            // Informa√ß√µes de debug (apenas se DEBUG_MODE estiver ativo)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, canvas.height - 150, 200, 140);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = '12px monospace';
            ctx.fillText(`FPS: ${Math.round(1000 / (Date.now() - lastTime))}`, 15, canvas.height - 130);
            ctx.fillText(`Player: ${Math.round(gameState.playerPosition.x)}, ${Math.round(gameState.playerPosition.y)}`, 15, canvas.height - 115);
            ctx.fillText(`Velocity: ${Math.round(gameState.playerVelocity.x)}, ${Math.round(gameState.playerVelocity.y)}`, 15, canvas.height - 100);
            ctx.fillText(`Camera: ${Math.round(gameState.cameraOffset.x)}, ${Math.round(gameState.cameraOffset.y)}`, 15, canvas.height - 85);
            ctx.fillText(`Enemies: ${enemies.length}`, 15, canvas.height - 70);
            ctx.fillText(`Particles: ${particles.length}`, 15, canvas.height - 55);
            ctx.fillText(`Effects: ${abilityEffects.length}`, 15, canvas.height - 40);
            ctx.fillText(`Grounded: ${gameState.isGrounded}`, 15, canvas.height - 25);
            ctx.fillText(`Animation: ${gameState.currentAnimation}`, 15, canvas.height - 10);
        }

        // ===== ATUALIZA√á√ÉO DE UI =====
        function updateAllUI() {
            updateHealthBar();
            updateManaBar();
            updateXPBar();
            updatePlayerStats();
        }

        function updateHealthBar() {
            const healthFill = document.getElementById('health-fill');
            const healthText = document.getElementById('health-text');
            
            if (healthFill && healthText) {
                const percentage = (gameState.playerHealth / gameState.playerMaxHealth) * 100;
                healthFill.style.width = percentage + '%';
                healthText.textContent = `${Math.round(gameState.playerHealth)}/${gameState.playerMaxHealth}`;
            }
        }

        function updateManaBar() {
            const manaFill = document.getElementById('mana-fill');
            const manaText = document.getElementById('mana-text');
            
            if (manaFill && manaText) {
                const percentage = (gameState.playerMana / gameState.playerMaxMana) * 100;
                manaFill.style.width = percentage + '%';
                manaText.textContent = `${Math.round(gameState.playerMana)}/${gameState.playerMaxMana}`;
            }
        }

        function updateXPBar() {
            const xpFill = document.getElementById('xp-fill');
            const xpText = document.getElementById('xp-text');
            
            if (xpFill && xpText) {
                const percentage = (gameState.playerXP / gameState.playerNextLevelXP) * 100;
                xpFill.style.width = percentage + '%';
                xpText.textContent = `${gameState.playerXP}/${gameState.playerNextLevelXP}`;
            }
        }

        function updatePlayerStats() {
            const levelEl = document.getElementById('player-level');
            const classEl = document.getElementById('player-class');
            const damageEl = document.getElementById('player-damage');
            
            if (levelEl) levelEl.textContent = gameState.playerLevel;
            if (classEl) classEl.textContent = gameState.playerClass; // Agora √© sempre "Escolhido"
            if (damageEl) damageEl.textContent = Math.round(gameState.playerDamage);
        }

        // ===== CONTROLE DE JOGO =====
        function togglePause() {
            if (gameState.inStartScreen || gameState.inCutscene || gameState.inDialog) return; // N√£o pode pausar nesses estados
            
            gameState.gamePaused = !gameState.gamePaused;
            const pauseMenu = document.getElementById('pause-menu');
            
            if (gameState.gamePaused) {
                pauseMenu.style.display = 'flex';
                stopMusic(); // Pausa a m√∫sica
            } else {
                pauseMenu.style.display = 'none';
                if (gameState.inBossFight) {
                    playMusic('music_boss_tarek', true); // Retoma m√∫sica do boss
                } else {
                    playMusic('music_platforming', true); // Retoma m√∫sica da fase
                }
            }
        }

        function gameOver() {
            gameState.gamePaused = true;
            stopMusic(); // Para a m√∫sica
            
            // Efeitos visuais de game over
            flashScreen('rgba(0, 0, 0, 0.8)', 1000);
            
            setTimeout(() => {
                showDialog(
                    "SISTEMA",
                    `${gameState.playerName} foi derrotado... Mas a jornada n√£o termina aqui. O destino de todos os reinos ainda depende de suas escolhas.`,
                    [
                        {
                            text: "Voltar ao √∫ltimo checkpoint",
                            action: () => {
                                restartFromCheckpoint();
                            }
                        },
                        {
                            text: "Reiniciar fase atual",
                            action: () => {
                                loadPhase(gameState.currentPhase);
                                gameState.gamePaused = false;
                            }
                        },
                        {
                            text: "Voltar ao menu principal",
                            action: () => {
                                exitToMenu();
                            }
                        }
                    ]
                );
            }, 1500);
        }

        function completePhase() {
            gameState.gamePaused = true;
            stopMusic();
            
            // Efeitos de vit√≥ria
            flashScreen(getComputedStyle(document.documentElement).getPropertyValue('--accent-gold'), 800);
            addParticles('victoryExplosion', gameState.playerPosition.x + CONFIG.PLAYER_WIDTH / 2, gameState.playerPosition.y + CONFIG.NORMAL_HEIGHT / 2, 50);
            
            setTimeout(() => {
                if (gameState.currentPhase < 4) { // Se houver mais fases ap√≥s a 4 (Tarek)
                    showDialog(
                        "SISTEMA",
                        "Fase conclu√≠da com maestria! Voc√™ provou ser digno do t√≠tulo de Escolhido. Preparando para os pr√≥ximos desafios...",
                        [
                            {
                                text: "Continuar para pr√≥xima fase",
                                action: () => {
                                    // loadPhase(gameState.currentPhase + 1); // Descomente para carregar pr√≥xima fase
                                    showVictoryScreen(); // Por enquanto, vai para a tela de vit√≥ria de demo
                                    gameState.gamePaused = false;
                                }
                            },
                            {
                                text: "Salvar e voltar ao menu",
                                action: () => {
                                    saveProgress();
                                    exitToMenu();
                                }
                            }
                        ]
                    );
                } else {
                    showVictoryScreen();
                }
            }, 2000);
        }

        function showVictoryScreen() {
            const overlay = document.getElementById('cinematic-overlay');
            const titleElement = document.getElementById('cinematic-title');
            const textElement = document.getElementById('cinematic-text');
            
            overlay.classList.add('active'); // Ativa o fade-in

            titleElement.textContent = "VIT√ìRIA!";
            textElement.innerHTML = `
                <p>Parab√©ns, ${gameState.playerName}!</p>
                <br>
                <p>Voc√™ completou a primeira parte da jornada em Tup√£ry. Tarek foi derrotado e o caminho para o interior do reino gelado est√° aberto.</p>
                <br>
                <p>Mas esta √© apenas a primeira de muitas prova√ß√µes. O Cora√ß√£o de Gelo ainda aguarda, e Ignys se aproxima...</p>
                <br>
                <p><strong>Estat√≠sticas Finais:</strong></p>
                <p>N√≠vel Alcan√ßado: ${gameState.playerLevel}</p>
                <p>Classe: ${gameState.playerClass}</p>
                <p>XP Total: ${gameState.playerXP}</p>
                <br>
                <p><em>Obrigado por jogar Tup√£ry: O Reino Congelado!</em></p>
                <p><em>Mais cap√≠tulos em breve...</em></p>
            `;
            
            titleElement.style.animation = 'none';
            textElement.style.animation = 'none';
            void titleElement.offsetWidth;
            void textElement.offsetWidth;
            titleElement.style.animation = 'fadeInText 2s forwards';
            textElement.style.animation = 'fadeInText 3s forwards 1s';
            
            // Bot√£o especial de vit√≥ria
            const skipBtn = document.getElementById('skip-btn');
            skipBtn.textContent = 'Voltar ao Menu';
            skipBtn.onclick = () => {
                // Limpar save para permitir novo jogo
                setCookie('tupary_save', '', -1);
                setCookie('tupary_checkpoint', '', -1);
                exitToMenu();
            };
        }

        // ===== SISTEMA DE CONFIGURA√á√ïES =====
        const gameSettings = {
            volume: 0.7,
            sfxVolume: 0.8,
            musicVolume: 0.6,
            showFPS: false,
            particleQuality: 'high', // low, medium, high
            screenShake: true,
            
            load: function() {
                const saved = getCookie('tupary_settings');
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        Object.assign(this, settings);
                    } catch (e) {
                        console.error('Erro ao carregar configura√ß√µes:', e);
                    }
                }
            },
            
            save: function() {
                setCookie('tupary_settings', JSON.stringify(this));
            }
        };

        // ===== OTIMIZA√á√ïES DE PERFORMANCE =====
        function optimizePerformance() {
            // Ajustar qualidade baseada na performance (exemplo)
            const fps = 1000 / (Date.now() - lastTime);
            
            if (fps < 30) {
                CONFIG.MAX_PARTICLES = Math.max(50, CONFIG.MAX_PARTICLES - 10);
                CONFIG.SNOW_SPAWN_RATE *= 0.8;
            } else if (fps > 55) {
                CONFIG.MAX_PARTICLES = Math.min(200, CONFIG.MAX_PARTICLES + 5);
                CONFIG.SNOW_SPAWN_RATE = Math.min(0.15, CONFIG.SNOW_SPAWN_RATE * 1.1);
            }
        }

        // ===== INICIALIZA√á√ÉO FINAL =====
        function finalizeInitialization() {
            gameSettings.load();
            
            // Configurar debug mode
            if (window.location.hash === '#debug') {
                window.DEBUG_MODE = true;
                console.log('Debug mode ativado');
            }
            
            // Otimiza√ß√£o cont√≠nua
            setInterval(optimizePerformance, 5000);
            
            console.log('Tup√£ry: O Reino Congelado - Inicializado com sucesso!');
        }

        // ===== EVENTOS DE JANELA =====
        window.addEventListener('beforeunload', (e) => {
            // Salvar progresso antes de fechar
            if (gameState.gameStarted && !gameState.inStartScreen) {
                saveProgress();
            }
        });

        window.addEventListener('visibilitychange', () => {
            // Pausar quando aba perde foco
            if (document.hidden && gameState.gameStarted && !gameState.inStartScreen && !gameState.gamePaused) {
                togglePause();
            }
        });

        // ===== IN√çCIO DO JOGO =====
        window.addEventListener('DOMContentLoaded', () => {
            init();
            finalizeInitialization();
        });

        // ===== EXPOSI√á√ÉO GLOBAL PARA DEBUG =====
        if (window.DEBUG_MODE) {
            window.gameState = gameState;
            window.CONFIG = CONFIG;
            window.enemies = enemies;
            window.particles = particles;
            window.abilityEffects = abilityEffects;
            window.platforms = platforms;
            window.fallingSpikes = fallingSpikes; // Adicionado para debug
            
            // Comandos de debug
            window.debugCommands = {
                godMode: () => {
                    gameState.playerMaxHealth = 9999;
                    gameState.playerHealth = 9999;
                    gameState.playerMaxMana = 9999;
                    gameState.playerMana = 9999;
                    updateAllUI();
                },
                
                levelUp: () => {
                    gainXP(gameState.playerNextLevelXP); // For√ßa level up
                },
                
                teleport: (x, y) => {
                    gameState.playerPosition.x = x || CONFIG.WORLD_WIDTH_CURRENT_PHASE - CONFIG.PLAYER_WIDTH - 10; // Teleporta para o final da fase, por exemplo
                    gameState.playerPosition.y = y || 300;
                },
                
                spawnBoss: () => { // Usado para debugar a luta com Tarek diretamente
                    loadPhase(4); // Carrega a fase de batalha com Tarek
                },
                
                clearEnemies: () => {
                    enemies.length = 0;
                },

                addFallingSpikeAtPlayer: () => { // Adiciona um espinho caindo na posi√ß√£o do player
                    addFallingSpike(gameState.playerPosition.x + CONFIG.PLAYER_WIDTH / 2 - 15, 0);
                },
                
                addParticles: (type, count) => {
                    addParticles(type || 'snow', gameState.playerPosition.x, gameState.playerPosition.y, count || 50);
                }
            };
            
            console.log('Debug commands available:', Object.keys(window.debugCommands));
        }
    </script>
</body>
</html>